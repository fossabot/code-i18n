(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('to-fast-properties'), require('ms'), require('supports-color'), require('globals'), require('js-tokens'), require('chalk')) :
  typeof define === 'function' && define.amd ? define(['exports', 'to-fast-properties', 'ms', 'supports-color', 'globals', 'js-tokens', 'chalk'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.CodeI18n = {}, global.require$$0$1, global.require$$0$2, global.require$$2, global.require$$3, global.require$$0$3, global.require$$2$1));
}(this, (function (exports, require$$0$1, require$$0$2, require$$2, require$$3, require$$0$3, require$$2$1) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
  var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);
  var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
  var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);
  var require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);
  var require$$2__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$2$1);

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var lib$b = {};

  Object.defineProperty(lib$b, '__esModule', { value: true });

  const beforeExpr = true;
  const startsExpr = true;
  const isLoop$1 = true;
  const isAssign = true;
  const prefix = true;
  const postfix = true;
  class TokenType {
    constructor(label, conf = {}) {
      this.label = void 0;
      this.keyword = void 0;
      this.beforeExpr = void 0;
      this.startsExpr = void 0;
      this.rightAssociative = void 0;
      this.isLoop = void 0;
      this.isAssign = void 0;
      this.prefix = void 0;
      this.postfix = void 0;
      this.binop = void 0;
      this.updateContext = void 0;
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.rightAssociative = !!conf.rightAssociative;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop != null ? conf.binop : null;
      this.updateContext = null;
    }

  }
  const keywords$1 = new Map();

  function createKeyword(name, options = {}) {
    options.keyword = name;
    const token = new TokenType(name, options);
    keywords$1.set(name, token);
    return token;
  }

  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr,
      binop
    });
  }

  const types$1 = {
    num: new TokenType("num", {
      startsExpr
    }),
    bigint: new TokenType("bigint", {
      startsExpr
    }),
    decimal: new TokenType("decimal", {
      startsExpr
    }),
    regexp: new TokenType("regexp", {
      startsExpr
    }),
    string: new TokenType("string", {
      startsExpr
    }),
    name: new TokenType("name", {
      startsExpr
    }),
    privateName: new TokenType("#name", {
      startsExpr
    }),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr,
      startsExpr
    }),
    bracketHashL: new TokenType("#[", {
      beforeExpr,
      startsExpr
    }),
    bracketBarL: new TokenType("[|", {
      beforeExpr,
      startsExpr
    }),
    bracketR: new TokenType("]"),
    bracketBarR: new TokenType("|]"),
    braceL: new TokenType("{", {
      beforeExpr,
      startsExpr
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr,
      startsExpr
    }),
    braceHashL: new TokenType("#{", {
      beforeExpr,
      startsExpr
    }),
    braceR: new TokenType("}", {
      beforeExpr
    }),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr,
      startsExpr
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", {
      beforeExpr
    }),
    semi: new TokenType(";", {
      beforeExpr
    }),
    colon: new TokenType(":", {
      beforeExpr
    }),
    doubleColon: new TokenType("::", {
      beforeExpr
    }),
    dot: new TokenType("."),
    question: new TokenType("?", {
      beforeExpr
    }),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", {
      beforeExpr
    }),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", {
      beforeExpr
    }),
    backQuote: new TokenType("`", {
      startsExpr
    }),
    dollarBraceL: new TokenType("${", {
      beforeExpr,
      startsExpr
    }),
    at: new TokenType("@"),
    hash: new TokenType("#", {
      startsExpr
    }),
    interpreterDirective: new TokenType("#!..."),
    eq: new TokenType("=", {
      beforeExpr,
      isAssign
    }),
    assign: new TokenType("_=", {
      beforeExpr,
      isAssign
    }),
    slashAssign: new TokenType("_=", {
      beforeExpr,
      isAssign
    }),
    incDec: new TokenType("++/--", {
      prefix,
      postfix,
      startsExpr
    }),
    bang: new TokenType("!", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    tilde: new TokenType("~", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr,
      binop: 9,
      prefix,
      startsExpr
    }),
    modulo: new TokenType("%", {
      beforeExpr,
      binop: 10,
      startsExpr
    }),
    star: new TokenType("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr
    }),
    _do: createKeyword("do", {
      isLoop: isLoop$1,
      beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr
    }),
    _finally: createKeyword("finally"),
    _for: createKeyword("for", {
      isLoop: isLoop$1
    }),
    _function: createKeyword("function", {
      startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _while: createKeyword("while", {
      isLoop: isLoop$1
    }),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr,
      startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr
    }),
    _in: createKeyword("in", {
      beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr,
      binop: 7
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr,
      prefix,
      startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr,
      prefix,
      startsExpr
    })
  };

  const lineBreak = /\r\n?|[\n\u2028\u2029]/;
  const lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;

      default:
        return false;
    }
  }
  const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  function isWhitespace(code) {
    switch (code) {
      case 0x0009:
      case 0x000b:
      case 0x000c:
      case 32:
      case 160:
      case 5760:
      case 0x2000:
      case 0x2001:
      case 0x2002:
      case 0x2003:
      case 0x2004:
      case 0x2005:
      case 0x2006:
      case 0x2007:
      case 0x2008:
      case 0x2009:
      case 0x200a:
      case 0x202f:
      case 0x205f:
      case 0x3000:
      case 0xfeff:
        return true;

      default:
        return false;
    }
  }

  class Position {
    constructor(line, col) {
      this.line = void 0;
      this.column = void 0;
      this.line = line;
      this.column = col;
    }

  }
  class SourceLocation {
    constructor(start, end) {
      this.start = void 0;
      this.end = void 0;
      this.filename = void 0;
      this.identifierName = void 0;
      this.start = start;
      this.end = end;
    }

  }
  function getLineInfo(input, offset) {
    let line = 1;
    let lineStart = 0;
    let match;
    lineBreakG.lastIndex = 0;

    while ((match = lineBreakG.exec(input)) && match.index < offset) {
      line++;
      lineStart = lineBreakG.lastIndex;
    }

    return new Position(line, offset - lineStart);
  }

  class BaseParser {
    constructor() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }

    hasPlugin(name) {
      return this.plugins.has(name);
    }

    getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    }

  }

  function last$1(stack) {
    return stack[stack.length - 1];
  }

  class CommentsParser extends BaseParser {
    addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    }

    adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      let lastElement = null;
      let i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (let j = 0; j < this.state.leadingComments.length; j++) {
        if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      const newTrailingComments = [];

      for (let i = 0; i < this.state.leadingComments.length; i++) {
        const leadingComment = this.state.leadingComments[i];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(i, 1);
            i--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    }

    processComment(node) {
      if (node.type === "Program" && node.body.length > 0) return;
      const stack = this.state.commentStack;
      let firstChild, lastChild, trailingComments, i, j;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        const lastInStack = last$1(stack);

        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last$1(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last$1(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case "ObjectExpression":
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case "ObjectPattern":
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case "CallExpression":
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case "ArrayExpression":
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case "ArrayPattern":
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
        this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && lastChild.leadingComments.length > 0 && last$1(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last$1(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          const leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last$1(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          const firstTrailingCommentIndex = trailingComments.findIndex(comment => comment.end >= node.end);

          if (firstTrailingCommentIndex > 0) {
            node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);
            node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);
          } else {
            node.trailingComments = trailingComments;
          }
        }
      }

      stack.push(node);
    }

  }

  const ErrorCodes = Object.freeze({
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
  });

  const ErrorMessages = makeErrorTemplates({
    AccessorIsGenerator: "A %0ter cannot be a generator.",
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accesor must not have any formal parameters.",
    BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: "'%0' require an initialization value.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: "Unsyntactic %0.",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: "`import()` requires exactly %0.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: "Expected number in radix %0.",
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
    InvalidIdentifier: "Invalid identifier %0.",
    InvalidLhs: "Invalid left-hand side in %0.",
    InvalidLhsBinding: "Binding invalid left-hand side in %0.",
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: "Unexpected character '%0'.",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: "Label '%0' is already declared.",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
    ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
    ModuleExportUndefined: "Export '%0' is not defined.",
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
    PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
    PrivateNameRedeclaration: "Duplicate private name #%0.",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    StaticPrototype: "Classes may not have static property named prototype.",
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: "Assigning to '%0' in strict mode.",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: "Unexpected keyword '%0'.",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'.",
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: "Unexpected token '%0'.",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    VarRedeclaration: "Identifier '%0' has already been declared.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, ErrorCodes.SyntaxError);
  const SourceTypeModuleErrorMessages = makeErrorTemplates({
    ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`,
    ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'`
  }, ErrorCodes.SourceTypeModuleError);

  function makeErrorTemplates(messages, code) {
    const templates = {};
    Object.keys(messages).forEach(reasonCode => {
      templates[reasonCode] = Object.freeze({
        code,
        reasonCode,
        template: messages[reasonCode]
      });
    });
    return Object.freeze(templates);
  }
  class ParserError extends CommentsParser {
    getLocationForPosition(pos) {
      let loc;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    }

    raise(pos, {
      code,
      reasonCode,
      template
    }, ...params) {
      return this.raiseWithData(pos, {
        code,
        reasonCode
      }, template, ...params);
    }

    raiseOverwrite(pos, {
      code,
      template
    }, ...params) {
      const loc = this.getLocationForPosition(pos);
      const message = template.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;

      if (this.options.errorRecovery) {
        const errors = this.state.errors;

        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];

          if (error.pos === pos) {
            return Object.assign(error, {
              message
            });
          } else if (error.pos < pos) {
            break;
          }
        }
      }

      return this._raise({
        code,
        loc,
        pos
      }, message);
    }

    raiseWithData(pos, data, errorTemplate, ...params) {
      const loc = this.getLocationForPosition(pos);
      const message = errorTemplate.replace(/%(\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;
      return this._raise(Object.assign({
        loc,
        pos
      }, data), message);
    }

    _raise(errorContext, message) {
      const err = new SyntaxError(message);
      Object.assign(err, errorContext);

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    }

  }

  var estree = (superClass => class extends superClass {
    parseRegExpLiteral({
      pattern,
      flags
    }) {
      let regex = null;

      try {
        regex = new RegExp(pattern, flags);
      } catch (e) {}

      const node = this.estreeParseLiteral(regex);
      node.regex = {
        pattern,
        flags
      };
      return node;
    }

    parseBigIntLiteral(value) {
      let bigInt;

      try {
        bigInt = BigInt(value);
      } catch (_unused) {
        bigInt = null;
      }

      const node = this.estreeParseLiteral(bigInt);
      node.bigint = String(node.value || value);
      return node;
    }

    parseDecimalLiteral(value) {
      const decimal = null;
      const node = this.estreeParseLiteral(decimal);
      node.decimal = String(node.value || value);
      return node;
    }

    estreeParseLiteral(value) {
      return this.parseLiteral(value, "Literal");
    }

    parseStringLiteral(value) {
      return this.estreeParseLiteral(value);
    }

    parseNumericLiteral(value) {
      return this.estreeParseLiteral(value);
    }

    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }

    parseBooleanLiteral(value) {
      return this.estreeParseLiteral(value);
    }

    directiveToStmt(directive) {
      const directiveLiteral = directive.value;
      const stmt = this.startNodeAt(directive.start, directive.loc.start);
      const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
      expression.value = directiveLiteral.extra.expressionValue;
      expression.raw = directiveLiteral.extra.raw;
      stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
      return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
    }

    initFunction(node, isAsync) {
      super.initFunction(node, isAsync);
      node.expression = false;
    }

    checkDeclaration(node) {
      if (node != null && this.isObjectProperty(node)) {
        this.checkDeclaration(node.value);
      } else {
        super.checkDeclaration(node);
      }
    }

    getObjectOrClassMethodParams(method) {
      return method.value.params;
    }

    isValidDirective(stmt) {
      var _stmt$expression$extr;

      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
    }

    stmtToDirective(stmt) {
      const directive = super.stmtToDirective(stmt);
      const value = stmt.expression.value;
      this.addExtra(directive.value, "expressionValue", value);
      return directive;
    }

    parseBlockBody(node, ...args) {
      super.parseBlockBody(node, ...args);
      const directiveStatements = node.directives.map(d => this.directiveToStmt(d));
      node.body = directiveStatements.concat(node.body);
      delete node.directives;
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

      if (method.typeParameters) {
        method.value.typeParameters = method.typeParameters;
        delete method.typeParameters;
      }

      classBody.body.push(method);
    }

    parseMaybePrivateName(...args) {
      const node = super.parseMaybePrivateName(...args);

      if (node.type === "PrivateName" && this.getPluginOption("estree", "classFeatures")) {
        return this.convertPrivateNameToPrivateIdentifier(node);
      }

      return node;
    }

    convertPrivateNameToPrivateIdentifier(node) {
      const name = super.getPrivateNameSV(node);
      node = node;
      delete node.id;
      node.name = name;
      node.type = "PrivateIdentifier";
      return node;
    }

    isPrivateName(node) {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return super.isPrivateName(node);
      }

      return node.type === "PrivateIdentifier";
    }

    getPrivateNameSV(node) {
      if (!this.getPluginOption("estree", "classFeatures")) {
        return super.getPrivateNameSV(node);
      }

      return node.name;
    }

    parseLiteral(value, type) {
      const node = super.parseLiteral(value, type);
      node.raw = node.extra.raw;
      delete node.extra;
      return node;
    }

    parseFunctionBody(node, allowExpression, isMethod = false) {
      super.parseFunctionBody(node, allowExpression, isMethod);
      node.expression = node.body.type !== "BlockStatement";
    }

    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      let funcNode = this.startNode();
      funcNode.kind = node.kind;
      funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
      funcNode.type = "FunctionExpression";
      delete funcNode.kind;
      node.value = funcNode;

      if (type === "ClassPrivateMethod") {
        node.computed = false;
      }

      type = "MethodDefinition";
      return this.finishNode(node, type);
    }

    parseClassProperty(...args) {
      const propertyNode = super.parseClassProperty(...args);

      if (this.getPluginOption("estree", "classFeatures")) {
        propertyNode.type = "PropertyDefinition";
      }

      return propertyNode;
    }

    parseClassPrivateProperty(...args) {
      const propertyNode = super.parseClassPrivateProperty(...args);

      if (this.getPluginOption("estree", "classFeatures")) {
        propertyNode.type = "PropertyDefinition";
        propertyNode.computed = false;
      }

      return propertyNode;
    }

    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);

      if (node) {
        node.type = "Property";
        if (node.kind === "method") node.kind = "init";
        node.shorthand = false;
      }

      return node;
    }

    parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);

      if (node) {
        node.kind = "init";
        node.type = "Property";
      }

      return node;
    }

    toAssignable(node, isLHS = false) {
      if (node != null && this.isObjectProperty(node)) {
        this.toAssignable(node.value, isLHS);
        return node;
      }

      return super.toAssignable(node, isLHS);
    }

    toAssignableObjectExpressionProp(prop, ...args) {
      if (prop.kind === "get" || prop.kind === "set") {
        this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
      } else if (prop.method) {
        this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
      } else {
        super.toAssignableObjectExpressionProp(prop, ...args);
      }
    }

    finishCallExpression(node, optional) {
      super.finishCallExpression(node, optional);

      if (node.callee.type === "Import") {
        node.type = "ImportExpression";
        node.source = node.arguments[0];

        if (this.hasPlugin("importAssertions")) {
          var _node$arguments$;

          node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
        }

        delete node.arguments;
        delete node.callee;
      }

      return node;
    }

    toReferencedArguments(node) {
      if (node.type === "ImportExpression") {
        return;
      }

      super.toReferencedArguments(node);
    }

    parseExport(node) {
      super.parseExport(node);

      switch (node.type) {
        case "ExportAllDeclaration":
          node.exported = null;
          break;

        case "ExportNamedDeclaration":
          if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
            node.type = "ExportAllDeclaration";
            node.exported = node.specifiers[0].exported;
            delete node.specifiers;
          }

          break;
      }

      return node;
    }

    parseSubscript(base, startPos, startLoc, noCalls, state) {
      const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);

      if (state.optionalChainMember) {
        if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
          node.type = node.type.substring(8);
        }

        if (state.stop) {
          const chain = this.startNodeAtNode(node);
          chain.expression = node;
          return this.finishNode(chain, "ChainExpression");
        }
      } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
        node.optional = false;
      }

      return node;
    }

    hasPropertyAsPrivateName(node) {
      if (node.type === "ChainExpression") {
        node = node.expression;
      }

      return super.hasPropertyAsPrivateName(node);
    }

    isOptionalChain(node) {
      return node.type === "ChainExpression";
    }

    isObjectProperty(node) {
      return node.type === "Property" && node.kind === "init" && !node.method;
    }

    isObjectMethod(node) {
      return node.method || node.kind === "get" || node.kind === "set";
    }

  });

  class TokContext {
    constructor(token, preserveSpace) {
      this.token = void 0;
      this.preserveSpace = void 0;
      this.token = token;
      this.preserveSpace = !!preserveSpace;
    }

  }
  const types$2 = {
    brace: new TokContext("{"),
    template: new TokContext("`", true)
  };

  types$1.braceR.updateContext = context => {
    context.pop();
  };

  types$1.braceL.updateContext = types$1.braceHashL.updateContext = types$1.dollarBraceL.updateContext = context => {
    context.push(types$2.brace);
  };

  types$1.backQuote.updateContext = context => {
    if (context[context.length - 1] === types$2.template) {
      context.pop();
    } else {
      context.push(types$2.template);
    }
  };

  let nonASCIIidentifierStartChars$1 = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  let nonASCIIidentifierChars$1 = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  const nonASCIIidentifierStart$1 = new RegExp("[" + nonASCIIidentifierStartChars$1 + "]");
  const nonASCIIidentifier$1 = new RegExp("[" + nonASCIIidentifierStartChars$1 + nonASCIIidentifierChars$1 + "]");
  nonASCIIidentifierStartChars$1 = nonASCIIidentifierChars$1 = null;
  const astralIdentifierStartCodes$1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  const astralIdentifierCodes$1 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  function isInAstralSet$1(code, set) {
    let pos = 0x10000;

    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart$1(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart$1.test(String.fromCharCode(code));
    }

    return isInAstralSet$1(code, astralIdentifierStartCodes$1);
  }
  function isIdentifierChar$1(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier$1.test(String.fromCharCode(code));
    }

    return isInAstralSet$1(code, astralIdentifierStartCodes$1) || isInAstralSet$1(code, astralIdentifierCodes$1);
  }

  const reservedWords$1 = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  const keywords$2 = new Set(reservedWords$1.keyword);
  const reservedWordsStrictSet$1 = new Set(reservedWords$1.strict);
  const reservedWordsStrictBindSet$1 = new Set(reservedWords$1.strictBind);
  function isReservedWord$1(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord$1(word, inModule) {
    return isReservedWord$1(word, inModule) || reservedWordsStrictSet$1.has(word);
  }
  function isStrictBindOnlyReservedWord$1(word) {
    return reservedWordsStrictBindSet$1.has(word);
  }
  function isStrictBindReservedWord$1(word, inModule) {
    return isStrictReservedWord$1(word, inModule) || isStrictBindOnlyReservedWord$1(word);
  }
  function isKeyword$1(word) {
    return keywords$2.has(word);
  }

  function isIteratorStart(current, next) {
    return current === 64 && next === 64;
  }
  const reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
  }

  const SCOPE_OTHER = 0b000000000,
        SCOPE_PROGRAM = 0b000000001,
        SCOPE_FUNCTION = 0b000000010,
        SCOPE_ARROW = 0b000000100,
        SCOPE_SIMPLE_CATCH = 0b000001000,
        SCOPE_SUPER = 0b000010000,
        SCOPE_DIRECT_SUPER = 0b000100000,
        SCOPE_CLASS = 0b001000000,
        SCOPE_STATIC_BLOCK = 0b010000000,
        SCOPE_TS_MODULE = 0b100000000,
        SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
  const BIND_KIND_VALUE = 0b000000000001,
        BIND_KIND_TYPE = 0b000000000010,
        BIND_SCOPE_VAR = 0b000000000100,
        BIND_SCOPE_LEXICAL = 0b000000001000,
        BIND_SCOPE_FUNCTION = 0b000000010000,
        BIND_FLAGS_NONE = 0b000001000000,
        BIND_FLAGS_CLASS = 0b000010000000,
        BIND_FLAGS_TS_ENUM = 0b000100000000,
        BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,
        BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,
        BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;
  const BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
        BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
        BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
        BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
        BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
        BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
        BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
        BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
        BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
        BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
        BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
        BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
        BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
  const CLASS_ELEMENT_FLAG_STATIC = 0b100,
        CLASS_ELEMENT_KIND_GETTER = 0b010,
        CLASS_ELEMENT_KIND_SETTER = 0b001,
        CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
  const CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
        CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
        CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
        CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
        CLASS_ELEMENT_OTHER = 0;

  class Scope$2 {
    constructor(flags) {
      this.var = new Set();
      this.lexical = new Set();
      this.functions = new Set();
      this.flags = flags;
    }

  }
  class ScopeHandler {
    constructor(raise, inModule) {
      this.scopeStack = [];
      this.undefinedExports = new Map();
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
      this.inModule = inModule;
    }

    get inFunction() {
      return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
    }

    get allowSuper() {
      return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
    }

    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
    }

    get inClass() {
      return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
    }

    get inClassAndNotInNonArrowFunction() {
      const flags = this.currentThisScopeFlags();
      return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
    }

    get inStaticBlock() {
      return (this.currentThisScopeFlags() & SCOPE_STATIC_BLOCK) > 0;
    }

    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
    }

    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }

    createScope(flags) {
      return new Scope$2(flags);
    }

    enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    }

    exit() {
      this.scopeStack.pop();
    }

    treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    }

    declareName(name, bindingType, pos) {
      let scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.add(name);
        } else {
          scope.lexical.add(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (let i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope.var.add(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }

    maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports.delete(name);
      }
    }

    checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, ErrorMessages.VarRedeclaration, name);
      }
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);
      }

      return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    }

    checkLocalExport(id) {
      const {
        name
      } = id;
      const topLevelScope = this.scopeStack[0];

      if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {
        this.undefinedExports.set(name, id.start);
      }
    }

    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }

    currentVarScopeFlags() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];

        if (flags & SCOPE_VAR) {
          return flags;
        }
      }
    }

    currentThisScopeFlags() {
      for (let i = this.scopeStack.length - 1;; i--) {
        const {
          flags
        } = this.scopeStack[i];

        if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
          return flags;
        }
      }
    }

  }

  class FlowScope extends Scope$2 {
    constructor(...args) {
      super(...args);
      this.declareFunctions = new Set();
    }

  }

  class FlowScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new FlowScope(flags);
    }

    declareName(name, bindingType, pos) {
      const scope = this.currentScope();

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }

      super.declareName(...arguments);
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (super.isRedeclaredInScope(...arguments)) return true;

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
      }

      return false;
    }

    checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        super.checkLocalExport(id);
      }
    }

  }

  const reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  const FlowErrors = makeErrorTemplates({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: "Cannot overwrite reserved type %0.",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: "Unexpected reserved type %0.",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  }, ErrorCodes.SyntaxError);

  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }

  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }

  function isMaybeDefaultImport(state) {
    return (state.type === types$1.name || !!state.type.keyword) && state.value !== "from";
  }

  const exportSuggestions = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };

  function partition(list, test) {
    const list1 = [];
    const list2 = [];

    for (let i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }

    return [list1, list2];
  }

  const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow$1 = (superClass => class extends superClass {
    constructor(...args) {
      super(...args);
      this.flowPragma = undefined;
    }

    getScopeHandler() {
      return FlowScopeHandler;
    }

    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }

    shouldParseEnums() {
      return !!this.getPluginOption("flow", "enums");
    }

    finishToken(type, val) {
      if (type !== types$1.string && type !== types$1.semi && type !== types$1.interpreterDirective) {
        if (this.flowPragma === undefined) {
          this.flowPragma = null;
        }
      }

      return super.finishToken(type, val);
    }

    addComment(comment) {
      if (this.flowPragma === undefined) {
        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);

        if (!matches) ; else if (matches[1] === "flow") {
          this.flowPragma = "flow";
        } else if (matches[1] === "noflow") {
          this.flowPragma = "noflow";
        } else {
          throw new Error("Unexpected flow pragma");
        }
      }

      return super.addComment(comment);
    }

    flowParseTypeInitialiser(tok) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(tok || types$1.colon);
      const type = this.flowParseType();
      this.state.inType = oldInType;
      return type;
    }

    flowParsePredicate() {
      const node = this.startNode();
      const moduloPos = this.state.start;
      this.next();
      this.expectContextual("checks");

      if (this.state.lastTokStart > moduloPos + 1) {
        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
      }

      if (this.eat(types$1.parenL)) {
        node.value = this.parseExpression();
        this.expect(types$1.parenR);
        return this.finishNode(node, "DeclaredPredicate");
      } else {
        return this.finishNode(node, "InferredPredicate");
      }
    }

    flowParseTypeAndPredicateInitialiser() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      this.expect(types$1.colon);
      let type = null;
      let predicate = null;

      if (this.match(types$1.modulo)) {
        this.state.inType = oldInType;
        predicate = this.flowParsePredicate();
      } else {
        type = this.flowParseType();
        this.state.inType = oldInType;

        if (this.match(types$1.modulo)) {
          predicate = this.flowParsePredicate();
        }
      }

      return [type, predicate];
    }

    flowParseDeclareClass(node) {
      this.next();
      this.flowParseInterfaceish(node, true);
      return this.finishNode(node, "DeclareClass");
    }

    flowParseDeclareFunction(node) {
      this.next();
      const id = node.id = this.parseIdentifier();
      const typeNode = this.startNode();
      const typeContainer = this.startNode();

      if (this.isRelational("<")) {
        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        typeNode.typeParameters = null;
      }

      this.expect(types$1.parenL);
      const tmp = this.flowParseFunctionTypeParams();
      typeNode.params = tmp.params;
      typeNode.rest = tmp.rest;
      typeNode.this = tmp._this;
      this.expect(types$1.parenR);
      [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
      typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
      id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
      this.resetEndLocation(id);
      this.semicolon();
      this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);
      return this.finishNode(node, "DeclareFunction");
    }

    flowParseDeclare(node, insideModule) {
      if (this.match(types$1._class)) {
        return this.flowParseDeclareClass(node);
      } else if (this.match(types$1._function)) {
        return this.flowParseDeclareFunction(node);
      } else if (this.match(types$1._var)) {
        return this.flowParseDeclareVariable(node);
      } else if (this.eatContextual("module")) {
        if (this.match(types$1.dot)) {
          return this.flowParseDeclareModuleExports(node);
        } else {
          if (insideModule) {
            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
          }

          return this.flowParseDeclareModule(node);
        }
      } else if (this.isContextual("type")) {
        return this.flowParseDeclareTypeAlias(node);
      } else if (this.isContextual("opaque")) {
        return this.flowParseDeclareOpaqueType(node);
      } else if (this.isContextual("interface")) {
        return this.flowParseDeclareInterface(node);
      } else if (this.match(types$1._export)) {
        return this.flowParseDeclareExportDeclaration(node, insideModule);
      } else {
        throw this.unexpected();
      }
    }

    flowParseDeclareVariable(node) {
      this.next();
      node.id = this.flowParseTypeAnnotatableIdentifier(true);
      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
      this.semicolon();
      return this.finishNode(node, "DeclareVariable");
    }

    flowParseDeclareModule(node) {
      this.scope.enter(SCOPE_OTHER);

      if (this.match(types$1.string)) {
        node.id = this.parseExprAtom();
      } else {
        node.id = this.parseIdentifier();
      }

      const bodyNode = node.body = this.startNode();
      const body = bodyNode.body = [];
      this.expect(types$1.braceL);

      while (!this.match(types$1.braceR)) {
        let bodyNode = this.startNode();

        if (this.match(types$1._import)) {
          this.next();

          if (!this.isContextual("type") && !this.match(types$1._typeof)) {
            this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
          }

          this.parseImport(bodyNode);
        } else {
          this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
          bodyNode = this.flowParseDeclare(bodyNode, true);
        }

        body.push(bodyNode);
      }

      this.scope.exit();
      this.expect(types$1.braceR);
      this.finishNode(bodyNode, "BlockStatement");
      let kind = null;
      let hasModuleExport = false;
      body.forEach(bodyElement => {
        if (isEsModuleType(bodyElement)) {
          if (kind === "CommonJS") {
            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
          }

          kind = "ES";
        } else if (bodyElement.type === "DeclareModuleExports") {
          if (hasModuleExport) {
            this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
          }

          if (kind === "ES") {
            this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
          }

          kind = "CommonJS";
          hasModuleExport = true;
        }
      });
      node.kind = kind || "CommonJS";
      return this.finishNode(node, "DeclareModule");
    }

    flowParseDeclareExportDeclaration(node, insideModule) {
      this.expect(types$1._export);

      if (this.eat(types$1._default)) {
        if (this.match(types$1._function) || this.match(types$1._class)) {
          node.declaration = this.flowParseDeclare(this.startNode());
        } else {
          node.declaration = this.flowParseType();
          this.semicolon();
        }

        node.default = true;
        return this.finishNode(node, "DeclareExportDeclaration");
      } else {
        if (this.match(types$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
          const label = this.state.value;
          const suggestion = exportSuggestions[label];
          throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
        }

        if (this.match(types$1._var) || this.match(types$1._function) || this.match(types$1._class) || this.isContextual("opaque")) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(types$1.star) || this.match(types$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
            node = this.parseExport(node);

            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }

            node.type = "Declare" + node.type;
            return node;
          }
      }

      throw this.unexpected();
    }

    flowParseDeclareModuleExports(node) {
      this.next();
      this.expectContextual("exports");
      node.typeAnnotation = this.flowParseTypeAnnotation();
      this.semicolon();
      return this.finishNode(node, "DeclareModuleExports");
    }

    flowParseDeclareTypeAlias(node) {
      this.next();
      this.flowParseTypeAlias(node);
      node.type = "DeclareTypeAlias";
      return node;
    }

    flowParseDeclareOpaqueType(node) {
      this.next();
      this.flowParseOpaqueType(node, true);
      node.type = "DeclareOpaqueType";
      return node;
    }

    flowParseDeclareInterface(node) {
      this.next();
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "DeclareInterface");
    }

    flowParseInterfaceish(node, isClass = false) {
      node.id = this.flowParseRestrictedIdentifier(!isClass, true);
      this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }

      node.extends = [];
      node.implements = [];
      node.mixins = [];

      if (this.eat(types$1._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (!isClass && this.eat(types$1.comma));
      }

      if (this.isContextual("mixins")) {
        this.next();

        do {
          node.mixins.push(this.flowParseInterfaceExtends());
        } while (this.eat(types$1.comma));
      }

      if (this.isContextual("implements")) {
        this.next();

        do {
          node.implements.push(this.flowParseInterfaceExtends());
        } while (this.eat(types$1.comma));
      }

      node.body = this.flowParseObjectType({
        allowStatic: isClass,
        allowExact: false,
        allowSpread: false,
        allowProto: isClass,
        allowInexact: false
      });
    }

    flowParseInterfaceExtends() {
      const node = this.startNode();
      node.id = this.flowParseQualifiedTypeIdentifier();

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      } else {
        node.typeParameters = null;
      }

      return this.finishNode(node, "InterfaceExtends");
    }

    flowParseInterface(node) {
      this.flowParseInterfaceish(node);
      return this.finishNode(node, "InterfaceDeclaration");
    }

    checkNotUnderscore(word) {
      if (word === "_") {
        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
      }
    }

    checkReservedType(word, startLoc, declaration) {
      if (!reservedTypes.has(word)) return;
      this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
    }

    flowParseRestrictedIdentifier(liberal, declaration) {
      this.checkReservedType(this.state.value, this.state.start, declaration);
      return this.parseIdentifier(liberal);
    }

    flowParseTypeAlias(node) {
      node.id = this.flowParseRestrictedIdentifier(false, true);
      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }

      node.right = this.flowParseTypeInitialiser(types$1.eq);
      this.semicolon();
      return this.finishNode(node, "TypeAlias");
    }

    flowParseOpaqueType(node, declare) {
      this.expectContextual("type");
      node.id = this.flowParseRestrictedIdentifier(true, true);
      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      } else {
        node.typeParameters = null;
      }

      node.supertype = null;

      if (this.match(types$1.colon)) {
        node.supertype = this.flowParseTypeInitialiser(types$1.colon);
      }

      node.impltype = null;

      if (!declare) {
        node.impltype = this.flowParseTypeInitialiser(types$1.eq);
      }

      this.semicolon();
      return this.finishNode(node, "OpaqueType");
    }

    flowParseTypeParameter(requireDefault = false) {
      const nodeStart = this.state.start;
      const node = this.startNode();
      const variance = this.flowParseVariance();
      const ident = this.flowParseTypeAnnotatableIdentifier();
      node.name = ident.name;
      node.variance = variance;
      node.bound = ident.typeAnnotation;

      if (this.match(types$1.eq)) {
        this.eat(types$1.eq);
        node.default = this.flowParseType();
      } else {
        if (requireDefault) {
          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
        }
      }

      return this.finishNode(node, "TypeParameter");
    }

    flowParseTypeParameterDeclaration() {
      const oldInType = this.state.inType;
      const node = this.startNode();
      node.params = [];
      this.state.inType = true;

      if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }

      let defaultRequired = false;

      do {
        const typeParameter = this.flowParseTypeParameter(defaultRequired);
        node.params.push(typeParameter);

        if (typeParameter.default) {
          defaultRequired = true;
        }

        if (!this.isRelational(">")) {
          this.expect(types$1.comma);
        }
      } while (!this.isRelational(">"));

      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterDeclaration");
    }

    flowParseTypeParameterInstantiation() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = false;

      while (!this.isRelational(">")) {
        node.params.push(this.flowParseType());

        if (!this.isRelational(">")) {
          this.expect(types$1.comma);
        }
      }

      this.state.noAnonFunctionType = oldNoAnonFunctionType;
      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }

    flowParseTypeParameterInstantiationCallOrNew() {
      const node = this.startNode();
      const oldInType = this.state.inType;
      node.params = [];
      this.state.inType = true;
      this.expectRelational("<");

      while (!this.isRelational(">")) {
        node.params.push(this.flowParseTypeOrImplicitInstantiation());

        if (!this.isRelational(">")) {
          this.expect(types$1.comma);
        }
      }

      this.expectRelational(">");
      this.state.inType = oldInType;
      return this.finishNode(node, "TypeParameterInstantiation");
    }

    flowParseInterfaceType() {
      const node = this.startNode();
      this.expectContextual("interface");
      node.extends = [];

      if (this.eat(types$1._extends)) {
        do {
          node.extends.push(this.flowParseInterfaceExtends());
        } while (this.eat(types$1.comma));
      }

      node.body = this.flowParseObjectType({
        allowStatic: false,
        allowExact: false,
        allowSpread: false,
        allowProto: false,
        allowInexact: false
      });
      return this.finishNode(node, "InterfaceTypeAnnotation");
    }

    flowParseObjectPropertyKey() {
      return this.match(types$1.num) || this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    }

    flowParseObjectTypeIndexer(node, isStatic, variance) {
      node.static = isStatic;

      if (this.lookahead().type === types$1.colon) {
        node.id = this.flowParseObjectPropertyKey();
        node.key = this.flowParseTypeInitialiser();
      } else {
        node.id = null;
        node.key = this.flowParseType();
      }

      this.expect(types$1.bracketR);
      node.value = this.flowParseTypeInitialiser();
      node.variance = variance;
      return this.finishNode(node, "ObjectTypeIndexer");
    }

    flowParseObjectTypeInternalSlot(node, isStatic) {
      node.static = isStatic;
      node.id = this.flowParseObjectPropertyKey();
      this.expect(types$1.bracketR);
      this.expect(types$1.bracketR);

      if (this.isRelational("<") || this.match(types$1.parenL)) {
        node.method = true;
        node.optional = false;
        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
      } else {
        node.method = false;

        if (this.eat(types$1.question)) {
          node.optional = true;
        }

        node.value = this.flowParseTypeInitialiser();
      }

      return this.finishNode(node, "ObjectTypeInternalSlot");
    }

    flowParseObjectTypeMethodish(node) {
      node.params = [];
      node.rest = null;
      node.typeParameters = null;
      node.this = null;

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      this.expect(types$1.parenL);

      if (this.match(types$1._this)) {
        node.this = this.flowParseFunctionTypeParam(true);
        node.this.name = null;

        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }

      while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
        node.params.push(this.flowParseFunctionTypeParam(false));

        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }

      if (this.eat(types$1.ellipsis)) {
        node.rest = this.flowParseFunctionTypeParam(false);
      }

      this.expect(types$1.parenR);
      node.returnType = this.flowParseTypeInitialiser();
      return this.finishNode(node, "FunctionTypeAnnotation");
    }

    flowParseObjectTypeCallProperty(node, isStatic) {
      const valueNode = this.startNode();
      node.static = isStatic;
      node.value = this.flowParseObjectTypeMethodish(valueNode);
      return this.finishNode(node, "ObjectTypeCallProperty");
    }

    flowParseObjectType({
      allowStatic,
      allowExact,
      allowSpread,
      allowProto,
      allowInexact
    }) {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const nodeStart = this.startNode();
      nodeStart.callProperties = [];
      nodeStart.properties = [];
      nodeStart.indexers = [];
      nodeStart.internalSlots = [];
      let endDelim;
      let exact;
      let inexact = false;

      if (allowExact && this.match(types$1.braceBarL)) {
        this.expect(types$1.braceBarL);
        endDelim = types$1.braceBarR;
        exact = true;
      } else {
        this.expect(types$1.braceL);
        endDelim = types$1.braceR;
        exact = false;
      }

      nodeStart.exact = exact;

      while (!this.match(endDelim)) {
        let isStatic = false;
        let protoStart = null;
        let inexactStart = null;
        const node = this.startNode();

        if (allowProto && this.isContextual("proto")) {
          const lookahead = this.lookahead();

          if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
            this.next();
            protoStart = this.state.start;
            allowStatic = false;
          }
        }

        if (allowStatic && this.isContextual("static")) {
          const lookahead = this.lookahead();

          if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
            this.next();
            isStatic = true;
          }
        }

        const variance = this.flowParseVariance();

        if (this.eat(types$1.bracketL)) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (this.eat(types$1.bracketL)) {
            if (variance) {
              this.unexpected(variance.start);
            }

            nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
          } else {
            nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
          }
        } else if (this.match(types$1.parenL) || this.isRelational("<")) {
          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.unexpected(variance.start);
          }

          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
        } else {
          let kind = "init";

          if (this.isContextual("get") || this.isContextual("set")) {
            const lookahead = this.lookahead();

            if (lookahead.type === types$1.name || lookahead.type === types$1.string || lookahead.type === types$1.num) {
              kind = this.state.value;
              this.next();
            }
          }

          const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

          if (propOrInexact === null) {
            inexact = true;
            inexactStart = this.state.lastTokStart;
          } else {
            nodeStart.properties.push(propOrInexact);
          }
        }

        this.flowObjectTypeSemicolon();

        if (inexactStart && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
          this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
        }
      }

      this.expect(endDelim);

      if (allowSpread) {
        nodeStart.inexact = inexact;
      }

      const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
      this.state.inType = oldInType;
      return out;
    }

    flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
      if (this.eat(types$1.ellipsis)) {
        const isInexactToken = this.match(types$1.comma) || this.match(types$1.semi) || this.match(types$1.braceR) || this.match(types$1.braceBarR);

        if (isInexactToken) {
          if (!allowSpread) {
            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
          } else if (!allowInexact) {
            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
          }

          if (variance) {
            this.raise(variance.start, FlowErrors.InexactVariance);
          }

          return null;
        }

        if (!allowSpread) {
          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
        }

        if (protoStart != null) {
          this.unexpected(protoStart);
        }

        if (variance) {
          this.raise(variance.start, FlowErrors.SpreadVariance);
        }

        node.argument = this.flowParseType();
        return this.finishNode(node, "ObjectTypeSpreadProperty");
      } else {
        node.key = this.flowParseObjectPropertyKey();
        node.static = isStatic;
        node.proto = protoStart != null;
        node.kind = kind;
        let optional = false;

        if (this.isRelational("<") || this.match(types$1.parenL)) {
          node.method = true;

          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.unexpected(variance.start);
          }

          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

          if (kind === "get" || kind === "set") {
            this.flowCheckGetterSetterParams(node);
          }

          if (!allowSpread && node.key.name === "constructor" && node.value.this) {
            this.raise(node.value.this.start, FlowErrors.ThisParamBannedInConstructor);
          }
        } else {
          if (kind !== "init") this.unexpected();
          node.method = false;

          if (this.eat(types$1.question)) {
            optional = true;
          }

          node.value = this.flowParseTypeInitialiser();
          node.variance = variance;
        }

        node.optional = optional;
        return this.finishNode(node, "ObjectTypeProperty");
      }
    }

    flowCheckGetterSetterParams(property) {
      const paramCount = property.kind === "get" ? 0 : 1;
      const start = property.start;
      const length = property.value.params.length + (property.value.rest ? 1 : 0);

      if (property.value.this) {
        this.raise(property.value.this.start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
      }

      if (length !== paramCount) {
        if (property.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (property.kind === "set" && property.value.rest) {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }

    flowObjectTypeSemicolon() {
      if (!this.eat(types$1.semi) && !this.eat(types$1.comma) && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
        this.unexpected();
      }
    }

    flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
      startPos = startPos || this.state.start;
      startLoc = startLoc || this.state.startLoc;
      let node = id || this.flowParseRestrictedIdentifier(true);

      while (this.eat(types$1.dot)) {
        const node2 = this.startNodeAt(startPos, startLoc);
        node2.qualification = node;
        node2.id = this.flowParseRestrictedIdentifier(true);
        node = this.finishNode(node2, "QualifiedTypeIdentifier");
      }

      return node;
    }

    flowParseGenericType(startPos, startLoc, id) {
      const node = this.startNodeAt(startPos, startLoc);
      node.typeParameters = null;
      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterInstantiation();
      }

      return this.finishNode(node, "GenericTypeAnnotation");
    }

    flowParseTypeofType() {
      const node = this.startNode();
      this.expect(types$1._typeof);
      node.argument = this.flowParsePrimaryType();
      return this.finishNode(node, "TypeofTypeAnnotation");
    }

    flowParseTupleType() {
      const node = this.startNode();
      node.types = [];
      this.expect(types$1.bracketL);

      while (this.state.pos < this.length && !this.match(types$1.bracketR)) {
        node.types.push(this.flowParseType());
        if (this.match(types$1.bracketR)) break;
        this.expect(types$1.comma);
      }

      this.expect(types$1.bracketR);
      return this.finishNode(node, "TupleTypeAnnotation");
    }

    flowParseFunctionTypeParam(first) {
      let name = null;
      let optional = false;
      let typeAnnotation = null;
      const node = this.startNode();
      const lh = this.lookahead();
      const isThis = this.state.type === types$1._this;

      if (lh.type === types$1.colon || lh.type === types$1.question) {
        if (isThis && !first) {
          this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
        }

        name = this.parseIdentifier(isThis);

        if (this.eat(types$1.question)) {
          optional = true;

          if (isThis) {
            this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
          }
        }

        typeAnnotation = this.flowParseTypeInitialiser();
      } else {
        typeAnnotation = this.flowParseType();
      }

      node.name = name;
      node.optional = optional;
      node.typeAnnotation = typeAnnotation;
      return this.finishNode(node, "FunctionTypeParam");
    }

    reinterpretTypeAsFunctionTypeParam(type) {
      const node = this.startNodeAt(type.start, type.loc.start);
      node.name = null;
      node.optional = false;
      node.typeAnnotation = type;
      return this.finishNode(node, "FunctionTypeParam");
    }

    flowParseFunctionTypeParams(params = []) {
      let rest = null;
      let _this = null;

      if (this.match(types$1._this)) {
        _this = this.flowParseFunctionTypeParam(true);
        _this.name = null;

        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }

      while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
        params.push(this.flowParseFunctionTypeParam(false));

        if (!this.match(types$1.parenR)) {
          this.expect(types$1.comma);
        }
      }

      if (this.eat(types$1.ellipsis)) {
        rest = this.flowParseFunctionTypeParam(false);
      }

      return {
        params,
        rest,
        _this
      };
    }

    flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
      switch (id.name) {
        case "any":
          return this.finishNode(node, "AnyTypeAnnotation");

        case "bool":
        case "boolean":
          return this.finishNode(node, "BooleanTypeAnnotation");

        case "mixed":
          return this.finishNode(node, "MixedTypeAnnotation");

        case "empty":
          return this.finishNode(node, "EmptyTypeAnnotation");

        case "number":
          return this.finishNode(node, "NumberTypeAnnotation");

        case "string":
          return this.finishNode(node, "StringTypeAnnotation");

        case "symbol":
          return this.finishNode(node, "SymbolTypeAnnotation");

        default:
          this.checkNotUnderscore(id.name);
          return this.flowParseGenericType(startPos, startLoc, id);
      }
    }

    flowParsePrimaryType() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const node = this.startNode();
      let tmp;
      let type;
      let isGroupedType = false;
      const oldNoAnonFunctionType = this.state.noAnonFunctionType;

      switch (this.state.type) {
        case types$1.name:
          if (this.isContextual("interface")) {
            return this.flowParseInterfaceType();
          }

          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

        case types$1.braceL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: false,
            allowSpread: true,
            allowProto: false,
            allowInexact: true
          });

        case types$1.braceBarL:
          return this.flowParseObjectType({
            allowStatic: false,
            allowExact: true,
            allowSpread: true,
            allowProto: false,
            allowInexact: false
          });

        case types$1.bracketL:
          this.state.noAnonFunctionType = false;
          type = this.flowParseTupleType();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          return type;

        case types$1.relational:
          if (this.state.value === "<") {
            node.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(types$1.parenL);
            tmp = this.flowParseFunctionTypeParams();
            node.params = tmp.params;
            node.rest = tmp.rest;
            node.this = tmp._this;
            this.expect(types$1.parenR);
            this.expect(types$1.arrow);
            node.returnType = this.flowParseType();
            return this.finishNode(node, "FunctionTypeAnnotation");
          }

          break;

        case types$1.parenL:
          this.next();

          if (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
            if (this.match(types$1.name) || this.match(types$1._this)) {
              const token = this.lookahead().type;
              isGroupedType = token !== types$1.question && token !== types$1.colon;
            } else {
              isGroupedType = true;
            }
          }

          if (isGroupedType) {
            this.state.noAnonFunctionType = false;
            type = this.flowParseType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;

            if (this.state.noAnonFunctionType || !(this.match(types$1.comma) || this.match(types$1.parenR) && this.lookahead().type === types$1.arrow)) {
              this.expect(types$1.parenR);
              return type;
            } else {
              this.eat(types$1.comma);
            }
          }

          if (type) {
            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
          } else {
            tmp = this.flowParseFunctionTypeParams();
          }

          node.params = tmp.params;
          node.rest = tmp.rest;
          node.this = tmp._this;
          this.expect(types$1.parenR);
          this.expect(types$1.arrow);
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");

        case types$1.string:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

        case types$1._true:
        case types$1._false:
          node.value = this.match(types$1._true);
          this.next();
          return this.finishNode(node, "BooleanLiteralTypeAnnotation");

        case types$1.plusMin:
          if (this.state.value === "-") {
            this.next();

            if (this.match(types$1.num)) {
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
            }

            if (this.match(types$1.bigint)) {
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
            }

            throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
          }

          throw this.unexpected();

        case types$1.num:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

        case types$1.bigint:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

        case types$1._void:
          this.next();
          return this.finishNode(node, "VoidTypeAnnotation");

        case types$1._null:
          this.next();
          return this.finishNode(node, "NullLiteralTypeAnnotation");

        case types$1._this:
          this.next();
          return this.finishNode(node, "ThisTypeAnnotation");

        case types$1.star:
          this.next();
          return this.finishNode(node, "ExistsTypeAnnotation");

        default:
          if (this.state.type.keyword === "typeof") {
            return this.flowParseTypeofType();
          } else if (this.state.type.keyword) {
            const label = this.state.type.label;
            this.next();
            return super.createIdentifier(node, label);
          }

      }

      throw this.unexpected();
    }

    flowParsePostfixType() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let type = this.flowParsePrimaryType();
      let seenOptionalIndexedAccess = false;

      while ((this.match(types$1.bracketL) || this.match(types$1.questionDot)) && !this.canInsertSemicolon()) {
        const node = this.startNodeAt(startPos, startLoc);
        const optional = this.eat(types$1.questionDot);
        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
        this.expect(types$1.bracketL);

        if (!optional && this.match(types$1.bracketR)) {
          node.elementType = type;
          this.next();
          type = this.finishNode(node, "ArrayTypeAnnotation");
        } else {
          node.objectType = type;
          node.indexType = this.flowParseType();
          this.expect(types$1.bracketR);

          if (seenOptionalIndexedAccess) {
            node.optional = optional;
            type = this.finishNode(node, "OptionalIndexedAccessType");
          } else {
            type = this.finishNode(node, "IndexedAccessType");
          }
        }
      }

      return type;
    }

    flowParsePrefixType() {
      const node = this.startNode();

      if (this.eat(types$1.question)) {
        node.typeAnnotation = this.flowParsePrefixType();
        return this.finishNode(node, "NullableTypeAnnotation");
      } else {
        return this.flowParsePostfixType();
      }
    }

    flowParseAnonFunctionWithoutParens() {
      const param = this.flowParsePrefixType();

      if (!this.state.noAnonFunctionType && this.eat(types$1.arrow)) {
        const node = this.startNodeAt(param.start, param.loc.start);
        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
        node.rest = null;
        node.this = null;
        node.returnType = this.flowParseType();
        node.typeParameters = null;
        return this.finishNode(node, "FunctionTypeAnnotation");
      }

      return param;
    }

    flowParseIntersectionType() {
      const node = this.startNode();
      this.eat(types$1.bitwiseAND);
      const type = this.flowParseAnonFunctionWithoutParens();
      node.types = [type];

      while (this.eat(types$1.bitwiseAND)) {
        node.types.push(this.flowParseAnonFunctionWithoutParens());
      }

      return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
    }

    flowParseUnionType() {
      const node = this.startNode();
      this.eat(types$1.bitwiseOR);
      const type = this.flowParseIntersectionType();
      node.types = [type];

      while (this.eat(types$1.bitwiseOR)) {
        node.types.push(this.flowParseIntersectionType());
      }

      return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
    }

    flowParseType() {
      const oldInType = this.state.inType;
      this.state.inType = true;
      const type = this.flowParseUnionType();
      this.state.inType = oldInType;
      return type;
    }

    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === types$1.name && this.state.value === "_") {
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        const node = this.parseIdentifier();
        return this.flowParseGenericType(startPos, startLoc, node);
      } else {
        return this.flowParseType();
      }
    }

    flowParseTypeAnnotation() {
      const node = this.startNode();
      node.typeAnnotation = this.flowParseTypeInitialiser();
      return this.finishNode(node, "TypeAnnotation");
    }

    flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
      const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

      if (this.match(types$1.colon)) {
        ident.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(ident);
      }

      return ident;
    }

    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
      return node.expression;
    }

    flowParseVariance() {
      let variance = null;

      if (this.match(types$1.plusMin)) {
        variance = this.startNode();

        if (this.state.value === "+") {
          variance.kind = "plus";
        } else {
          variance.kind = "minus";
        }

        this.next();
        this.finishNode(variance, "Variance");
      }

      return variance;
    }

    parseFunctionBody(node, allowExpressionBody, isMethod = false) {
      if (allowExpressionBody) {
        return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
      }

      return super.parseFunctionBody(node, false, isMethod);
    }

    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(types$1.colon)) {
        const typeNode = this.startNode();
        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }

      super.parseFunctionBodyAndFinish(node, type, isMethod);
    }

    parseStatement(context, topLevel) {
      if (this.state.strict && this.match(types$1.name) && this.state.value === "interface") {
        const lookahead = this.lookahead();

        if (lookahead.type === types$1.name || isKeyword$1(lookahead.value)) {
          const node = this.startNode();
          this.next();
          return this.flowParseInterface(node);
        }
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      }

      const stmt = super.parseStatement(context, topLevel);

      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
        this.flowPragma = null;
      }

      return stmt;
    }

    parseExpressionStatement(node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(types$1._class) || this.match(types$1.name) || this.match(types$1._function) || this.match(types$1._var) || this.match(types$1._export)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(types$1.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          } else if (expr.name === "opaque") {
            return this.flowParseOpaqueType(node, false);
          }
        }
      }

      return super.parseExpressionStatement(node, expr);
    }

    shouldParseExportDeclaration() {
      return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
    }

    isExportDefaultSpecifier() {
      if (this.match(types$1.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
        return false;
      }

      return super.isExportDefaultSpecifier();
    }

    parseExportDefaultExpression() {
      if (this.shouldParseEnums() && this.isContextual("enum")) {
        const node = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(node);
      }

      return super.parseExportDefaultExpression();
    }

    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.match(types$1.question)) return expr;

      if (this.state.maybeInArrowParameters) {
        const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));

        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }

          return expr;
        }

        if (result.error) this.state = result.failState;
        return result.node;
      }

      this.expect(types$1.question);
      const state = this.state.clone();
      const originalNoArrowAt = this.state.noArrowAt;
      const node = this.startNodeAt(startPos, startLoc);
      let {
        consequent,
        failed
      } = this.tryParseConditionalConsequent();
      let [valid, invalid] = this.getArrowLikeExpressions(consequent);

      if (failed || invalid.length > 0) {
        const noArrowAt = [...originalNoArrowAt];

        if (invalid.length > 0) {
          this.state = state;
          this.state.noArrowAt = noArrowAt;

          for (let i = 0; i < invalid.length; i++) {
            noArrowAt.push(invalid[i].start);
          }

          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
          [valid, invalid] = this.getArrowLikeExpressions(consequent);
        }

        if (failed && valid.length > 1) {
          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
        }

        if (failed && valid.length === 1) {
          this.state = state;
          this.state.noArrowAt = noArrowAt.concat(valid[0].start);
          ({
            consequent,
            failed
          } = this.tryParseConditionalConsequent());
        }
      }

      this.getArrowLikeExpressions(consequent, true);
      this.state.noArrowAt = originalNoArrowAt;
      this.expect(types$1.colon);
      node.test = expr;
      node.consequent = consequent;
      node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));
      return this.finishNode(node, "ConditionalExpression");
    }

    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      const consequent = this.parseMaybeAssignAllowIn();
      const failed = !this.match(types$1.colon);
      this.state.noArrowParamsConversionAt.pop();
      return {
        consequent,
        failed
      };
    }

    getArrowLikeExpressions(node, disallowInvalid) {
      const stack = [node];
      const arrows = [];

      while (stack.length !== 0) {
        const node = stack.pop();

        if (node.type === "ArrowFunctionExpression") {
          if (node.typeParameters || !node.returnType) {
            this.finishArrowValidation(node);
          } else {
            arrows.push(node);
          }

          stack.push(node.body);
        } else if (node.type === "ConditionalExpression") {
          stack.push(node.consequent);
          stack.push(node.alternate);
        }
      }

      if (disallowInvalid) {
        arrows.forEach(node => this.finishArrowValidation(node));
        return [arrows, []];
      }

      return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));
    }

    finishArrowValidation(node) {
      var _node$extra;

      this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      super.checkParams(node, false, true);
      this.scope.exit();
    }

    forwardNoArrowParamsConversionAt(node, parse) {
      let result;

      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        result = parse();
        this.state.noArrowParamsConversionAt.pop();
      } else {
        result = parse();
      }

      return result;
    }

    parseParenItem(node, startPos, startLoc) {
      node = super.parseParenItem(node, startPos, startLoc);

      if (this.eat(types$1.question)) {
        node.optional = true;
        this.resetEndLocation(node);
      }

      if (this.match(types$1.colon)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TypeCastExpression");
      }

      return node;
    }

    assertModuleNodeAllowed(node) {
      if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
        return;
      }

      super.assertModuleNodeAllowed(node);
    }

    parseExport(node) {
      const decl = super.parseExport(node);

      if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
        decl.exportKind = decl.exportKind || "value";
      }

      return decl;
    }

    parseExportDeclaration(node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();

        if (this.match(types$1.braceL)) {
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("opaque")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseOpaqueType(declarationNode, false);
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(declarationNode);
      } else if (this.shouldParseEnums() && this.isContextual("enum")) {
        node.exportKind = "value";
        const declarationNode = this.startNode();
        this.next();
        return this.flowParseEnumDeclaration(declarationNode);
      } else {
        return super.parseExportDeclaration(node);
      }
    }

    eatExportStar(node) {
      if (super.eatExportStar(...arguments)) return true;

      if (this.isContextual("type") && this.lookahead().type === types$1.star) {
        node.exportKind = "type";
        this.next();
        this.next();
        return true;
      }

      return false;
    }

    maybeParseExportNamespaceSpecifier(node) {
      const pos = this.state.start;
      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);

      if (hasNamespace && node.exportKind === "type") {
        this.unexpected(pos);
      }

      return hasNamespace;
    }

    parseClassId(node, isStatement, optionalId) {
      super.parseClassId(node, isStatement, optionalId);

      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    }

    parseClassMember(classBody, member, state) {
      const pos = this.state.start;

      if (this.isContextual("declare")) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        member.declare = true;
      }

      super.parseClassMember(classBody, member, state);

      if (member.declare) {
        if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(pos, FlowErrors.DeclareClassElement);
          } else if (member.value) {
          this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
        }
      }
    }

    isIterator(word) {
      return word === "iterator" || word === "asyncIterator";
    }

    readIterator() {
      const word = super.readWord1();
      const fullWord = "@@" + word;

      if (!this.isIterator(word) || !this.state.inType) {
        this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);
      }

      this.finishToken(types$1.name, fullWord);
    }

    getTokenFromCode(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 123 && next === 124) {
        return this.finishOp(types$1.braceBarL, 2);
      } else if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types$1.relational, 1);
      } else if (this.state.inType && code === 63) {
        if (next === 46) {
          return this.finishOp(types$1.questionDot, 2);
        }

        return this.finishOp(types$1.question, 1);
      } else if (isIteratorStart(code, next)) {
        this.state.pos += 2;
        return this.readIterator();
      } else {
        return super.getTokenFromCode(code);
      }
    }

    isAssignable(node, isBinding) {
      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          return true;

        case "ObjectExpression":
          {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type === "SpreadElement") && this.isAssignable(prop);
            });
          }

        case "ObjectProperty":
          return this.isAssignable(node.value);

        case "SpreadElement":
          return this.isAssignable(node.argument);

        case "ArrayExpression":
          return node.elements.every(element => this.isAssignable(element));

        case "AssignmentExpression":
          return node.operator === "=";

        case "ParenthesizedExpression":
        case "TypeCastExpression":
          return this.isAssignable(node.expression);

        case "MemberExpression":
        case "OptionalMemberExpression":
          return !isBinding;

        default:
          return false;
      }
    }

    toAssignable(node, isLHS = false) {
      if (node.type === "TypeCastExpression") {
        return super.toAssignable(this.typeCastToParameter(node), isLHS);
      } else {
        return super.toAssignable(node, isLHS);
      }
    }

    toAssignableList(exprList, trailingCommaPos, isLHS) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];

        if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }

      return super.toAssignableList(exprList, trailingCommaPos, isLHS);
    }

    toReferencedList(exprList, isParenthesizedExpr) {
      for (let i = 0; i < exprList.length; i++) {
        var _expr$extra;

        const expr = exprList[i];

        if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
        }
      }

      return exprList;
    }

    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);

      if (canBePattern && !this.state.maybeInArrowParameters) {
        this.toReferencedList(node.elements);
      }

      return node;
    }

    checkLVal(expr, ...args) {
      if (expr.type !== "TypeCastExpression") {
        return super.checkLVal(expr, ...args);
      }
    }

    parseClassProperty(node) {
      if (this.match(types$1.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }

      return super.parseClassProperty(node);
    }

    parseClassPrivateProperty(node) {
      if (this.match(types$1.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }

      return super.parseClassPrivateProperty(node);
    }

    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }

    isClassProperty() {
      return this.match(types$1.colon) || super.isClassProperty();
    }

    isNonstaticConstructor(method) {
      return !this.match(types$1.colon) && super.isNonstaticConstructor(method);
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      if (method.variance) {
        this.unexpected(method.variance.start);
      }

      delete method.variance;

      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);

      if (method.params && isConstructor) {
        const params = method.params;

        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
        }
      } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
        const params = method.value.params;

        if (params.length > 0 && this.isThisParam(params[0])) {
          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
        }
      }
    }

    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variance.start);
      }

      delete method.variance;

      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }

    parseClassSuper(node) {
      super.parseClassSuper(node);

      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }

      if (this.isContextual("implements")) {
        this.next();
        const implemented = node.implements = [];

        do {
          const node = this.startNode();
          node.id = this.flowParseRestrictedIdentifier(true);

          if (this.isRelational("<")) {
            node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            node.typeParameters = null;
          }

          implemented.push(this.finishNode(node, "ClassImplements"));
        } while (this.eat(types$1.comma));
      }
    }

    checkGetterSetterParams(method) {
      super.checkGetterSetterParams(method);
      const params = this.getObjectOrClassMethodParams(method);

      if (params.length > 0) {
        const param = params[0];

        if (this.isThisParam(param) && method.kind === "get") {
          this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
        } else if (this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
        }
      }
    }

    parsePropertyName(node, isPrivateNameAllowed) {
      const variance = this.flowParseVariance();
      const key = super.parsePropertyName(node, isPrivateNameAllowed);
      node.variance = variance;
      return key;
    }

    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      if (prop.variance) {
        this.unexpected(prop.variance.start);
      }

      delete prop.variance;
      let typeParameters;

      if (this.isRelational("<") && !isAccessor) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(types$1.parenL)) this.unexpected();
      }

      super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);

      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    }

    parseAssignableListItemTypes(param) {
      if (this.eat(types$1.question)) {
        if (param.type !== "Identifier") {
          this.raise(param.start, FlowErrors.OptionalBindingPattern);
        }

        if (this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
        }

        param.optional = true;
      }

      if (this.match(types$1.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      } else if (this.isThisParam(param)) {
        this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
      }

      if (this.match(types$1.eq) && this.isThisParam(param)) {
        this.raise(param.start, FlowErrors.ThisParamNoDefault);
      }

      this.resetEndLocation(param);
      return param;
    }

    parseMaybeDefault(startPos, startLoc, left) {
      const node = super.parseMaybeDefault(startPos, startLoc, left);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
      }

      return node;
    }

    shouldParseDefaultImport(node) {
      if (!hasTypeImportKind(node)) {
        return super.shouldParseDefaultImport(node);
      }

      return isMaybeDefaultImport(this.state);
    }

    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    }

    maybeParseDefaultImportSpecifier(node) {
      node.importKind = "value";
      let kind = null;

      if (this.match(types$1._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }

      if (kind) {
        const lh = this.lookahead();

        if (kind === "type" && lh.type === types$1.star) {
          this.unexpected(lh.start);
        }

        if (isMaybeDefaultImport(lh) || lh.type === types$1.braceL || lh.type === types$1.star) {
          this.next();
          node.importKind = kind;
        }
      }

      return super.maybeParseDefaultImportSpecifier(node);
    }

    parseImportSpecifier(node) {
      const specifier = this.startNode();
      const firstIdentIsString = this.match(types$1.string);
      const firstIdent = this.parseModuleExportName();
      let specifierTypeKind = null;

      if (firstIdent.type === "Identifier") {
        if (firstIdent.name === "type") {
          specifierTypeKind = "type";
        } else if (firstIdent.name === "typeof") {
          specifierTypeKind = "typeof";
        }
      }

      let isBinding = false;

      if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
        const as_ident = this.parseIdentifier(true);

        if (specifierTypeKind !== null && !this.match(types$1.name) && !this.state.type.keyword) {
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = as_ident.__clone();
        } else {
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else if (specifierTypeKind !== null && (this.match(types$1.name) || this.state.type.keyword)) {
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;

        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = specifier.imported.__clone();
        }
      } else {
        if (firstIdentIsString) {
          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
        }

        isBinding = true;
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = specifier.imported.__clone();
      }

      const nodeIsTypeImport = hasTypeImportKind(node);
      const specifierIsTypeImport = hasTypeImportKind(specifier);

      if (nodeIsTypeImport && specifierIsTypeImport) {
        this.raise(specifier.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);
      }

      if (nodeIsTypeImport || specifierIsTypeImport) {
        this.checkReservedType(specifier.local.name, specifier.local.start, true);
      }

      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
        this.checkReservedWord(specifier.local.name, specifier.start, true, true);
      }

      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }

    parseBindingAtom() {
      switch (this.state.type) {
        case types$1._this:
          return this.parseIdentifier(true);

        default:
          return super.parseBindingAtom();
      }
    }

    parseFunctionParams(node, allowModifiers) {
      const kind = node.kind;

      if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      super.parseFunctionParams(node, allowModifiers);
    }

    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);

      if (this.match(types$1.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.resetEndLocation(decl.id);
      }
    }

    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(types$1.colon)) {
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }

      return super.parseAsyncArrowFromCallExpression(node, call);
    }

    shouldParseAsyncArrow() {
      return this.match(types$1.colon) || super.shouldParseAsyncArrow();
    }

    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var _jsx;

      let state = null;
      let jsx;

      if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
        state = this.state.clone();
        jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
        if (!jsx.error) return jsx.node;
        const {
          context
        } = this.state;
        const curContext = context[context.length - 1];

        if (curContext === types$2.j_oTag) {
          context.length -= 2;
        } else if (curContext === types$2.j_expr) {
          context.length -= 1;
        }
      }

      if ((_jsx = jsx) != null && _jsx.error || this.isRelational("<")) {
        var _jsx2, _jsx3;

        state = state || this.state.clone();
        let typeParameters;
        const arrow = this.tryParse(abort => {
          var _arrowExpression$extr;

          typeParameters = this.flowParseTypeParameterDeclaration();
          const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
            const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
            this.resetStartLocationFromNode(result, typeParameters);
            return result;
          });

          if (arrowExpression.type !== "ArrowFunctionExpression" && (_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) {
            abort();
          }

          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);
          expr.typeParameters = typeParameters;
          this.resetStartLocationFromNode(expr, typeParameters);
          return arrowExpression;
        }, state);
        let arrowExpression = null;

        if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
          if (!arrow.error && !arrow.aborted) {
            if (arrow.node.async) {
              this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
            }

            return arrow.node;
          }

          arrowExpression = arrow.node;
        }

        if ((_jsx2 = jsx) != null && _jsx2.node) {
          this.state = jsx.failState;
          return jsx.node;
        }

        if (arrowExpression) {
          this.state = arrow.failState;
          return arrowExpression;
        }

        if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
      }

      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
    }

    parseArrow(node) {
      if (this.match(types$1.colon)) {
        const result = this.tryParse(() => {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(types$1.arrow)) this.unexpected();
          return typeNode;
        });
        if (result.thrown) return null;
        if (result.error) this.state = result.failState;
        node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
      }

      return super.parseArrow(node);
    }

    shouldParseArrow() {
      return this.match(types$1.colon) || super.shouldParseArrow();
    }

    setArrowFunctionParameters(node, params) {
      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        node.params = params;
      } else {
        super.setArrowFunctionParameters(node, params);
      }
    }

    checkParams(node, allowDuplicates, isArrowFunction) {
      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
        return;
      }

      for (let i = 0; i < node.params.length; i++) {
        if (this.isThisParam(node.params[i]) && i > 0) {
          this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);
        }
      }

      return super.checkParams(...arguments);
    }

    parseParenAndDistinguishExpression(canBeArrow) {
      return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
    }

    parseSubscripts(base, startPos, startLoc, noCalls) {
      if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
        this.next();
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        base = this.finishNode(node, "CallExpression");
      } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
        const state = this.state.clone();
        const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);
        if (!arrow.error && !arrow.aborted) return arrow.node;
        const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);
        if (result.node && !result.error) return result.node;

        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }

        if (result.node) {
          this.state = result.failState;
          return result.node;
        }

        throw arrow.error || result.error;
      }

      return super.parseSubscripts(base, startPos, startLoc, noCalls);
    }

    parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
      if (this.match(types$1.questionDot) && this.isLookaheadToken_lt()) {
        subscriptState.optionalChainMember = true;

        if (noCalls) {
          subscriptState.stop = true;
          return base;
        }

        this.next();
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        node.typeArguments = this.flowParseTypeParameterInstantiation();
        this.expect(types$1.parenL);
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        node.optional = true;
        return this.finishCallExpression(node, true);
      } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
        const node = this.startNodeAt(startPos, startLoc);
        node.callee = base;
        const result = this.tryParse(() => {
          node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
          this.expect(types$1.parenL);
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
          if (subscriptState.optionalChainMember) node.optional = false;
          return this.finishCallExpression(node, subscriptState.optionalChainMember);
        });

        if (result.node) {
          if (result.error) this.state = result.failState;
          return result.node;
        }
      }

      return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);
    }

    parseNewArguments(node) {
      let targs = null;

      if (this.shouldParseTypes() && this.isRelational("<")) {
        targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
      }

      node.typeArguments = targs;
      super.parseNewArguments(node);
    }

    parseAsyncArrowWithTypeParameters(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      this.parseFunctionParams(node);
      if (!this.parseArrow(node)) return;
      return this.parseArrowExpression(node, undefined, true);
    }

    readToken_mult_modulo(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 42 && next === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = false;
        this.state.pos += 2;
        this.nextToken();
        return;
      }

      super.readToken_mult_modulo(code);
    }

    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 124 && next === 125) {
        this.finishOp(types$1.braceBarR, 2);
        return;
      }

      super.readToken_pipe_amp(code);
    }

    parseTopLevel(file, program) {
      const fileNode = super.parseTopLevel(file, program);

      if (this.state.hasFlowComment) {
        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
      }

      return fileNode;
    }

    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment) {
          this.unexpected(null, FlowErrors.NestedFlowComment);
        }

        this.hasFlowCommentCompletion();
        this.state.pos += this.skipFlowComment();
        this.state.hasFlowComment = true;
        return;
      }

      if (this.state.hasFlowComment) {
        const end = this.input.indexOf("*-/", this.state.pos += 2);

        if (end === -1) {
          throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
        }

        this.state.pos = end + 3;
        return;
      }

      super.skipBlockComment();
    }

    skipFlowComment() {
      const {
        pos
      } = this.state;
      let shiftToFirstNonWhiteSpace = 2;

      while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
        shiftToFirstNonWhiteSpace++;
      }

      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

      if (ch2 === 58 && ch3 === 58) {
        return shiftToFirstNonWhiteSpace + 2;
      }

      if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
        return shiftToFirstNonWhiteSpace + 12;
      }

      if (ch2 === 58 && ch3 !== 58) {
        return shiftToFirstNonWhiteSpace;
      }

      return false;
    }

    hasFlowCommentCompletion() {
      const end = this.input.indexOf("*/", this.state.pos);

      if (end === -1) {
        throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
      }
    }

    flowEnumErrorBooleanMemberNotInitialized(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
    }

    flowEnumErrorInvalidMemberName(pos, {
      enumName,
      memberName
    }) {
      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);
      this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
    }

    flowEnumErrorDuplicateMemberName(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
    }

    flowEnumErrorInconsistentMemberValues(pos, {
      enumName
    }) {
      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
    }

    flowEnumErrorInvalidExplicitType(pos, {
      enumName,
      suppliedType
    }) {
      return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
    }

    flowEnumErrorInvalidMemberInitializer(pos, {
      enumName,
      explicitType,
      memberName
    }) {
      let message = null;

      switch (explicitType) {
        case "boolean":
        case "number":
        case "string":
          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
          break;

        case "symbol":
          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
          break;

        default:
          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
      }

      return this.raise(pos, message, enumName, memberName, explicitType);
    }

    flowEnumErrorNumberMemberNotInitialized(pos, {
      enumName,
      memberName
    }) {
      this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
    }

    flowEnumErrorStringMemberInconsistentlyInitailized(pos, {
      enumName
    }) {
      this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
    }

    flowEnumMemberInit() {
      const startPos = this.state.start;

      const endOfInit = () => this.match(types$1.comma) || this.match(types$1.braceR);

      switch (this.state.type) {
        case types$1.num:
          {
            const literal = this.parseNumericLiteral(this.state.value);

            if (endOfInit()) {
              return {
                type: "number",
                pos: literal.start,
                value: literal
              };
            }

            return {
              type: "invalid",
              pos: startPos
            };
          }

        case types$1.string:
          {
            const literal = this.parseStringLiteral(this.state.value);

            if (endOfInit()) {
              return {
                type: "string",
                pos: literal.start,
                value: literal
              };
            }

            return {
              type: "invalid",
              pos: startPos
            };
          }

        case types$1._true:
        case types$1._false:
          {
            const literal = this.parseBooleanLiteral(this.match(types$1._true));

            if (endOfInit()) {
              return {
                type: "boolean",
                pos: literal.start,
                value: literal
              };
            }

            return {
              type: "invalid",
              pos: startPos
            };
          }

        default:
          return {
            type: "invalid",
            pos: startPos
          };
      }
    }

    flowEnumMemberRaw() {
      const pos = this.state.start;
      const id = this.parseIdentifier(true);
      const init = this.eat(types$1.eq) ? this.flowEnumMemberInit() : {
        type: "none",
        pos
      };
      return {
        id,
        init
      };
    }

    flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
      const {
        explicitType
      } = context;

      if (explicitType === null) {
        return;
      }

      if (explicitType !== expectedType) {
        this.flowEnumErrorInvalidMemberInitializer(pos, context);
      }
    }

    flowEnumMembers({
      enumName,
      explicitType
    }) {
      const seenNames = new Set();
      const members = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      };
      let hasUnknownMembers = false;

      while (!this.match(types$1.braceR)) {
        if (this.eat(types$1.ellipsis)) {
          hasUnknownMembers = true;
          break;
        }

        const memberNode = this.startNode();
        const {
          id,
          init
        } = this.flowEnumMemberRaw();
        const memberName = id.name;

        if (memberName === "") {
          continue;
        }

        if (/^[a-z]/.test(memberName)) {
          this.flowEnumErrorInvalidMemberName(id.start, {
            enumName,
            memberName
          });
        }

        if (seenNames.has(memberName)) {
          this.flowEnumErrorDuplicateMemberName(id.start, {
            enumName,
            memberName
          });
        }

        seenNames.add(memberName);
        const context = {
          enumName,
          explicitType,
          memberName
        };
        memberNode.id = id;

        switch (init.type) {
          case "boolean":
            {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }

          case "number":
            {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }

          case "string":
            {
              this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }

          case "invalid":
            {
              throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
            }

          case "none":
            {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                  break;

                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                  break;

                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
        }

        if (!this.match(types$1.braceR)) {
          this.expect(types$1.comma);
        }
      }

      return {
        members,
        hasUnknownMembers
      };
    }

    flowEnumStringMembers(initializedMembers, defaultedMembers, {
      enumName
    }) {
      if (initializedMembers.length === 0) {
        return defaultedMembers;
      } else if (defaultedMembers.length === 0) {
        return initializedMembers;
      } else if (defaultedMembers.length > initializedMembers.length) {
        for (const member of initializedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
            enumName
          });
        }

        return defaultedMembers;
      } else {
        for (const member of defaultedMembers) {
          this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
            enumName
          });
        }

        return initializedMembers;
      }
    }

    flowEnumParseExplicitType({
      enumName
    }) {
      if (this.eatContextual("of")) {
        if (!this.match(types$1.name)) {
          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName,
            suppliedType: null
          });
        }

        const {
          value
        } = this.state;
        this.next();

        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.flowEnumErrorInvalidExplicitType(this.state.start, {
            enumName,
            suppliedType: value
          });
        }

        return value;
      }

      return null;
    }

    flowEnumBody(node, {
      enumName,
      nameLoc
    }) {
      const explicitType = this.flowEnumParseExplicitType({
        enumName
      });
      this.expect(types$1.braceL);
      const {
        members,
        hasUnknownMembers
      } = this.flowEnumMembers({
        enumName,
        explicitType
      });
      node.hasUnknownMembers = hasUnknownMembers;

      switch (explicitType) {
        case "boolean":
          node.explicitType = true;
          node.members = members.booleanMembers;
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumBooleanBody");

        case "number":
          node.explicitType = true;
          node.members = members.numberMembers;
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumNumberBody");

        case "string":
          node.explicitType = true;
          node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
            enumName
          });
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumStringBody");

        case "symbol":
          node.members = members.defaultedMembers;
          this.expect(types$1.braceR);
          return this.finishNode(node, "EnumSymbolBody");

        default:
          {
            const empty = () => {
              node.members = [];
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumStringBody");
            };

            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;

            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name
                });
              }

              node.members = members.booleanMembers;
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.start, {
                  enumName,
                  memberName: member.id.name
                });
              }

              node.members = members.numberMembers;
              this.expect(types$1.braceR);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                enumName
              });
              return empty();
            }
          }
      }
    }

    flowParseEnumDeclaration(node) {
      const id = this.parseIdentifier();
      node.id = id;
      node.body = this.flowEnumBody(this.startNode(), {
        enumName: id.name,
        nameLoc: id.start
      });
      return this.finishNode(node, "EnumDeclaration");
    }

    isLookaheadToken_lt() {
      const next = this.nextTokenStart();

      if (this.input.charCodeAt(next) === 60) {
        const afterNext = this.input.charCodeAt(next + 1);
        return afterNext !== 60 && afterNext !== 61;
      }

      return false;
    }

    maybeUnwrapTypeCastExpression(node) {
      return node.type === "TypeCastExpression" ? node.expression : node;
    }

  });

  const entities = {
    quot: "\u0022",
    amp: "&",
    apos: "\u0027",
    lt: "<",
    gt: ">",
    nbsp: "\u00A0",
    iexcl: "\u00A1",
    cent: "\u00A2",
    pound: "\u00A3",
    curren: "\u00A4",
    yen: "\u00A5",
    brvbar: "\u00A6",
    sect: "\u00A7",
    uml: "\u00A8",
    copy: "\u00A9",
    ordf: "\u00AA",
    laquo: "\u00AB",
    not: "\u00AC",
    shy: "\u00AD",
    reg: "\u00AE",
    macr: "\u00AF",
    deg: "\u00B0",
    plusmn: "\u00B1",
    sup2: "\u00B2",
    sup3: "\u00B3",
    acute: "\u00B4",
    micro: "\u00B5",
    para: "\u00B6",
    middot: "\u00B7",
    cedil: "\u00B8",
    sup1: "\u00B9",
    ordm: "\u00BA",
    raquo: "\u00BB",
    frac14: "\u00BC",
    frac12: "\u00BD",
    frac34: "\u00BE",
    iquest: "\u00BF",
    Agrave: "\u00C0",
    Aacute: "\u00C1",
    Acirc: "\u00C2",
    Atilde: "\u00C3",
    Auml: "\u00C4",
    Aring: "\u00C5",
    AElig: "\u00C6",
    Ccedil: "\u00C7",
    Egrave: "\u00C8",
    Eacute: "\u00C9",
    Ecirc: "\u00CA",
    Euml: "\u00CB",
    Igrave: "\u00CC",
    Iacute: "\u00CD",
    Icirc: "\u00CE",
    Iuml: "\u00CF",
    ETH: "\u00D0",
    Ntilde: "\u00D1",
    Ograve: "\u00D2",
    Oacute: "\u00D3",
    Ocirc: "\u00D4",
    Otilde: "\u00D5",
    Ouml: "\u00D6",
    times: "\u00D7",
    Oslash: "\u00D8",
    Ugrave: "\u00D9",
    Uacute: "\u00DA",
    Ucirc: "\u00DB",
    Uuml: "\u00DC",
    Yacute: "\u00DD",
    THORN: "\u00DE",
    szlig: "\u00DF",
    agrave: "\u00E0",
    aacute: "\u00E1",
    acirc: "\u00E2",
    atilde: "\u00E3",
    auml: "\u00E4",
    aring: "\u00E5",
    aelig: "\u00E6",
    ccedil: "\u00E7",
    egrave: "\u00E8",
    eacute: "\u00E9",
    ecirc: "\u00EA",
    euml: "\u00EB",
    igrave: "\u00EC",
    iacute: "\u00ED",
    icirc: "\u00EE",
    iuml: "\u00EF",
    eth: "\u00F0",
    ntilde: "\u00F1",
    ograve: "\u00F2",
    oacute: "\u00F3",
    ocirc: "\u00F4",
    otilde: "\u00F5",
    ouml: "\u00F6",
    divide: "\u00F7",
    oslash: "\u00F8",
    ugrave: "\u00F9",
    uacute: "\u00FA",
    ucirc: "\u00FB",
    uuml: "\u00FC",
    yacute: "\u00FD",
    thorn: "\u00FE",
    yuml: "\u00FF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };

  class State {
    constructor() {
      this.strict = void 0;
      this.curLine = void 0;
      this.startLoc = void 0;
      this.endLoc = void 0;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.maybeInArrowParameters = false;
      this.inPipeline = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.inPropertyName = false;
      this.hasFlowComment = false;
      this.isAmbientContext = false;
      this.inAbstractClass = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.decoratorStack = [[]];
      this.comments = [];
      this.trailingComments = [];
      this.leadingComments = [];
      this.commentStack = [];
      this.commentPreviousNode = null;
      this.pos = 0;
      this.lineStart = 0;
      this.type = types$1.eof;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.lastTokEnd = 0;
      this.context = [types$2.brace];
      this.exprAllowed = true;
      this.containsEsc = false;
      this.strictErrors = new Map();
      this.tokensLength = 0;
    }

    init(options) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    }

    curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    }

    clone(skipArrays) {
      const state = new State();
      const keys = Object.keys(this);

      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];
        let val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    }

  }

  const HEX_NUMBER = /^[\da-fA-F]+$/;
  const DECIMAL_NUMBER = /^\d+$/;
  const JsxErrors = makeErrorTemplates({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  }, ErrorCodes.SyntaxError);
  types$2.j_oTag = new TokContext("<tag");
  types$2.j_cTag = new TokContext("</tag");
  types$2.j_expr = new TokContext("<tag>...</tag>", true);
  types$1.jsxName = new TokenType("jsxName");
  types$1.jsxText = new TokenType("jsxText", {
    beforeExpr: true
  });
  types$1.jsxTagStart = new TokenType("jsxTagStart", {
    startsExpr: true
  });
  types$1.jsxTagEnd = new TokenType("jsxTagEnd");

  types$1.jsxTagStart.updateContext = context => {
    context.push(types$2.j_expr, types$2.j_oTag);
  };

  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }

  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }

    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }

    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }

    throw new Error("Node had unexpected type: " + object.type);
  }

  var jsx$1 = (superClass => class extends superClass {
    jsxReadToken() {
      let out = "";
      let chunkStart = this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
        }

        const ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              if (ch === 60 && this.state.exprAllowed) {
                ++this.state.pos;
                return this.finishToken(types$1.jsxTagStart);
              }

              return super.getTokenFromCode(ch);
            }

            out += this.input.slice(chunkStart, this.state.pos);
            return this.finishToken(types$1.jsxText, out);

          case 38:
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
            break;

          case 62:
          case 125:

          default:
            if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadNewLine(true);
              chunkStart = this.state.pos;
            } else {
              ++this.state.pos;
            }

        }
      }
    }

    jsxReadNewLine(normalizeCRLF) {
      const ch = this.input.charCodeAt(this.state.pos);
      let out;
      ++this.state.pos;

      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
        ++this.state.pos;
        out = normalizeCRLF ? "\n" : "\r\n";
      } else {
        out = String.fromCharCode(ch);
      }

      ++this.state.curLine;
      this.state.lineStart = this.state.pos;
      return out;
    }

    jsxReadString(quote) {
      let out = "";
      let chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 38) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadEntity();
          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(false);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      return this.finishToken(types$1.string, out);
    }

    jsxReadEntity() {
      let str = "";
      let count = 0;
      let entity;
      let ch = this.input[this.state.pos];
      const startPos = ++this.state.pos;

      while (this.state.pos < this.length && count++ < 10) {
        ch = this.input[this.state.pos++];

        if (ch === ";") {
          if (str[0] === "#") {
            if (str[1] === "x") {
              str = str.substr(2);

              if (HEX_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 16));
              }
            } else {
              str = str.substr(1);

              if (DECIMAL_NUMBER.test(str)) {
                entity = String.fromCodePoint(parseInt(str, 10));
              }
            }
          } else {
            entity = entities[str];
          }

          break;
        }

        str += ch;
      }

      if (!entity) {
        this.state.pos = startPos;
        return "&";
      }

      return entity;
    }

    jsxReadWord() {
      let ch;
      const start = this.state.pos;

      do {
        ch = this.input.charCodeAt(++this.state.pos);
      } while (isIdentifierChar$1(ch) || ch === 45);

      return this.finishToken(types$1.jsxName, this.input.slice(start, this.state.pos));
    }

    jsxParseIdentifier() {
      const node = this.startNode();

      if (this.match(types$1.jsxName)) {
        node.name = this.state.value;
      } else if (this.state.type.keyword) {
        node.name = this.state.type.keyword;
      } else {
        this.unexpected();
      }

      this.next();
      return this.finishNode(node, "JSXIdentifier");
    }

    jsxParseNamespacedName() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const name = this.jsxParseIdentifier();
      if (!this.eat(types$1.colon)) return name;
      const node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsxParseIdentifier();
      return this.finishNode(node, "JSXNamespacedName");
    }

    jsxParseElementName() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let node = this.jsxParseNamespacedName();

      if (node.type === "JSXNamespacedName") {
        return node;
      }

      while (this.eat(types$1.dot)) {
        const newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsxParseIdentifier();
        node = this.finishNode(newNode, "JSXMemberExpression");
      }

      return node;
    }

    jsxParseAttributeValue() {
      let node;

      switch (this.state.type) {
        case types$1.braceL:
          node = this.startNode();
          this.next();
          node = this.jsxParseExpressionContainer(node);

          if (node.expression.type === "JSXEmptyExpression") {
            this.raise(node.start, JsxErrors.AttributeIsEmpty);
          }

          return node;

        case types$1.jsxTagStart:
        case types$1.string:
          return this.parseExprAtom();

        default:
          throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
      }
    }

    jsxParseEmptyExpression() {
      const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
      return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
    }

    jsxParseSpreadChild(node) {
      this.next();
      node.expression = this.parseExpression();
      this.expect(types$1.braceR);
      return this.finishNode(node, "JSXSpreadChild");
    }

    jsxParseExpressionContainer(node) {
      if (this.match(types$1.braceR)) {
        node.expression = this.jsxParseEmptyExpression();
      } else {
        const expression = this.parseExpression();
        node.expression = expression;
      }

      this.expect(types$1.braceR);
      return this.finishNode(node, "JSXExpressionContainer");
    }

    jsxParseAttribute() {
      const node = this.startNode();

      if (this.eat(types$1.braceL)) {
        this.expect(types$1.ellipsis);
        node.argument = this.parseMaybeAssignAllowIn();
        this.expect(types$1.braceR);
        return this.finishNode(node, "JSXSpreadAttribute");
      }

      node.name = this.jsxParseNamespacedName();
      node.value = this.eat(types$1.eq) ? this.jsxParseAttributeValue() : null;
      return this.finishNode(node, "JSXAttribute");
    }

    jsxParseOpeningElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);

      if (this.match(types$1.jsxTagEnd)) {
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningFragment");
      }

      node.name = this.jsxParseElementName();
      return this.jsxParseOpeningElementAfterName(node);
    }

    jsxParseOpeningElementAfterName(node) {
      const attributes = [];

      while (!this.match(types$1.slash) && !this.match(types$1.jsxTagEnd)) {
        attributes.push(this.jsxParseAttribute());
      }

      node.attributes = attributes;
      node.selfClosing = this.eat(types$1.slash);
      this.expect(types$1.jsxTagEnd);
      return this.finishNode(node, "JSXOpeningElement");
    }

    jsxParseClosingElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);

      if (this.match(types$1.jsxTagEnd)) {
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXClosingFragment");
      }

      node.name = this.jsxParseElementName();
      this.expect(types$1.jsxTagEnd);
      return this.finishNode(node, "JSXClosingElement");
    }

    jsxParseElementAt(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      const children = [];
      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
      let closingElement = null;

      if (!openingElement.selfClosing) {
        contents: for (;;) {
          switch (this.state.type) {
            case types$1.jsxTagStart:
              startPos = this.state.start;
              startLoc = this.state.startLoc;
              this.next();

              if (this.eat(types$1.slash)) {
                closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                break contents;
              }

              children.push(this.jsxParseElementAt(startPos, startLoc));
              break;

            case types$1.jsxText:
              children.push(this.parseExprAtom());
              break;

            case types$1.braceL:
              {
                const node = this.startNode();
                this.next();

                if (this.match(types$1.ellipsis)) {
                  children.push(this.jsxParseSpreadChild(node));
                } else {
                  children.push(this.jsxParseExpressionContainer(node));
                }

                break;
              }

            default:
              throw this.unexpected();
          }
        }

        if (isFragment(openingElement) && !isFragment(closingElement)) {
          this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
        } else if (!isFragment(openingElement) && isFragment(closingElement)) {
          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
          }
        }
      }

      if (isFragment(openingElement)) {
        node.openingFragment = openingElement;
        node.closingFragment = closingElement;
      } else {
        node.openingElement = openingElement;
        node.closingElement = closingElement;
      }

      node.children = children;

      if (this.isRelational("<")) {
        throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
      }

      return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
    }

    jsxParseElement() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.next();
      return this.jsxParseElementAt(startPos, startLoc);
    }

    parseExprAtom(refExpressionErrors) {
      if (this.match(types$1.jsxText)) {
        return this.parseLiteral(this.state.value, "JSXText");
      } else if (this.match(types$1.jsxTagStart)) {
        return this.jsxParseElement();
      } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
        this.finishToken(types$1.jsxTagStart);
        return this.jsxParseElement();
      } else {
        return super.parseExprAtom(refExpressionErrors);
      }
    }

    createLookaheadState(state) {
      const lookaheadState = super.createLookaheadState(state);
      lookaheadState.inPropertyName = state.inPropertyName;
      return lookaheadState;
    }

    getTokenFromCode(code) {
      if (this.state.inPropertyName) return super.getTokenFromCode(code);
      const context = this.curContext();

      if (context === types$2.j_expr) {
        return this.jsxReadToken();
      }

      if (context === types$2.j_oTag || context === types$2.j_cTag) {
        if (isIdentifierStart$1(code)) {
          return this.jsxReadWord();
        }

        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(types$1.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context === types$2.j_oTag) {
          return this.jsxReadString(code);
        }
      }

      if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos;
        return this.finishToken(types$1.jsxTagStart);
      }

      return super.getTokenFromCode(code);
    }

    updateContext(prevType) {
      super.updateContext(prevType);
      const {
        context,
        type
      } = this.state;

      if (type === types$1.slash && prevType === types$1.jsxTagStart) {
        context.splice(-2, 2, types$2.j_cTag);
        this.state.exprAllowed = false;
      } else if (type === types$1.jsxTagEnd) {
        const out = context.pop();

        if (out === types$2.j_oTag && prevType === types$1.slash || out === types$2.j_cTag) {
          context.pop();
          this.state.exprAllowed = context[context.length - 1] === types$2.j_expr;
        } else {
          this.state.exprAllowed = true;
        }
      } else if (type.keyword && (prevType === types$1.dot || prevType === types$1.questionDot)) {
        this.state.exprAllowed = false;
      } else {
        this.state.exprAllowed = type.beforeExpr;
      }
    }

  });

  class TypeScriptScope extends Scope$2 {
    constructor(...args) {
      super(...args);
      this.types = new Set();
      this.enums = new Set();
      this.constEnums = new Set();
      this.classes = new Set();
      this.exportOnlyBindings = new Set();
    }

  }

  class TypeScriptScopeHandler extends ScopeHandler {
    createScope(flags) {
      return new TypeScriptScope(flags);
    }

    declareName(name, bindingType, pos) {
      const scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.add(name);
        return;
      }

      super.declareName(...arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.add(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);
    }

    isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.has(name)) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          const wasConst = scope.constEnums.has(name);
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
        if (scope.lexical.has(name)) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
        return true;
      }

      return super.isRedeclaredInScope(...arguments);
    }

    checkLocalExport(id) {
      const topLevelScope = this.scopeStack[0];
      const {
        name
      } = id;

      if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
        super.checkLocalExport(id);
      }
    }

  }

  const PARAM = 0b0000,
        PARAM_YIELD = 0b0001,
        PARAM_AWAIT = 0b0010,
        PARAM_RETURN = 0b0100,
        PARAM_IN = 0b1000;
  class ProductionParameterHandler {
    constructor() {
      this.stacks = [];
    }

    enter(flags) {
      this.stacks.push(flags);
    }

    exit() {
      this.stacks.pop();
    }

    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }

    get hasAwait() {
      return (this.currentFlags() & PARAM_AWAIT) > 0;
    }

    get hasYield() {
      return (this.currentFlags() & PARAM_YIELD) > 0;
    }

    get hasReturn() {
      return (this.currentFlags() & PARAM_RETURN) > 0;
    }

    get hasIn() {
      return (this.currentFlags() & PARAM_IN) > 0;
    }

  }
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
  }

  function nonNull(x) {
    if (x == null) {
      throw new Error(`Unexpected ${x} value.`);
    }

    return x;
  }

  function assert$1(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  }

  const TSErrors = makeErrorTemplates({
    AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: "'declare' is not allowed in %0ters.",
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
    DuplicateModifier: "Duplicate modifier: '%0'.",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
    InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
  }, ErrorCodes.SyntaxError);

  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";

      case "boolean":
        return "TSBooleanKeyword";

      case "bigint":
        return "TSBigIntKeyword";

      case "never":
        return "TSNeverKeyword";

      case "number":
        return "TSNumberKeyword";

      case "object":
        return "TSObjectKeyword";

      case "string":
        return "TSStringKeyword";

      case "symbol":
        return "TSSymbolKeyword";

      case "undefined":
        return "TSUndefinedKeyword";

      case "unknown":
        return "TSUnknownKeyword";

      default:
        return undefined;
    }
  }

  function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  }

  var typescript$1 = (superClass => class extends superClass {
    getScopeHandler() {
      return TypeScriptScopeHandler;
    }

    tsIsIdentifier() {
      return this.match(types$1.name);
    }

    tsTokenCanFollowModifier() {
      return (this.match(types$1.bracketL) || this.match(types$1.braceL) || this.match(types$1.star) || this.match(types$1.ellipsis) || this.match(types$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
    }

    tsNextTokenCanFollowModifier() {
      this.next();
      return this.tsTokenCanFollowModifier();
    }

    tsParseModifier(allowedModifiers) {
      if (!this.match(types$1.name)) {
        return undefined;
      }

      const modifier = this.state.value;

      if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
        return modifier;
      }

      return undefined;
    }

    tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {
      const enforceOrder = (pos, modifier, before, after) => {
        if (modifier === before && modified[after]) {
          this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
        }
      };

      const incompatible = (pos, modifier, mod1, mod2) => {
        if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
          this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
        }
      };

      for (;;) {
        const startPos = this.state.start;
        const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));
        if (!modifier) break;

        if (tsIsAccessModifier(modifier)) {
          if (modified.accessibility) {
            this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
          } else {
            enforceOrder(startPos, modifier, modifier, "override");
            enforceOrder(startPos, modifier, modifier, "static");
            enforceOrder(startPos, modifier, modifier, "readonly");
            modified.accessibility = modifier;
          }
        } else {
          if (Object.hasOwnProperty.call(modified, modifier)) {
            this.raise(startPos, TSErrors.DuplicateModifier, modifier);
          } else {
            enforceOrder(startPos, modifier, "static", "readonly");
            enforceOrder(startPos, modifier, "static", "override");
            enforceOrder(startPos, modifier, "override", "readonly");
            enforceOrder(startPos, modifier, "abstract", "override");
            incompatible(startPos, modifier, "declare", "override");
            incompatible(startPos, modifier, "static", "abstract");
          }

          modified[modifier] = true;
        }

        if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
          this.raise(startPos, errorTemplate, modifier);
        }
      }
    }

    tsIsListTerminator(kind) {
      switch (kind) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(types$1.braceR);

        case "HeritageClauseElement":
          return this.match(types$1.braceL);

        case "TupleElementTypes":
          return this.match(types$1.bracketR);

        case "TypeParametersOrArguments":
          return this.isRelational(">");
      }

      throw new Error("Unreachable");
    }

    tsParseList(kind, parseElement) {
      const result = [];

      while (!this.tsIsListTerminator(kind)) {
        result.push(parseElement());
      }

      return result;
    }

    tsParseDelimitedList(kind, parseElement) {
      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
    }

    tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
      const result = [];

      for (;;) {
        if (this.tsIsListTerminator(kind)) {
          break;
        }

        const element = parseElement();

        if (element == null) {
          return undefined;
        }

        result.push(element);

        if (this.eat(types$1.comma)) {
          continue;
        }

        if (this.tsIsListTerminator(kind)) {
          break;
        }

        if (expectSuccess) {
          this.expect(types$1.comma);
        }

        return undefined;
      }

      return result;
    }

    tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
      if (!skipFirstToken) {
        if (bracket) {
          this.expect(types$1.bracketL);
        } else {
          this.expectRelational("<");
        }
      }

      const result = this.tsParseDelimitedList(kind, parseElement);

      if (bracket) {
        this.expect(types$1.bracketR);
      } else {
        this.expectRelational(">");
      }

      return result;
    }

    tsParseImportType() {
      const node = this.startNode();
      this.expect(types$1._import);
      this.expect(types$1.parenL);

      if (!this.match(types$1.string)) {
        this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
      }

      node.argument = this.parseExprAtom();
      this.expect(types$1.parenR);

      if (this.eat(types$1.dot)) {
        node.qualifier = this.tsParseEntityName(true);
      }

      if (this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }

      return this.finishNode(node, "TSImportType");
    }

    tsParseEntityName(allowReservedWords) {
      let entity = this.parseIdentifier();

      while (this.eat(types$1.dot)) {
        const node = this.startNodeAtNode(entity);
        node.left = entity;
        node.right = this.parseIdentifier(allowReservedWords);
        entity = this.finishNode(node, "TSQualifiedName");
      }

      return entity;
    }

    tsParseTypeReference() {
      const node = this.startNode();
      node.typeName = this.tsParseEntityName(false);

      if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }

      return this.finishNode(node, "TSTypeReference");
    }

    tsParseThisTypePredicate(lhs) {
      this.next();
      const node = this.startNodeAtNode(lhs);
      node.parameterName = lhs;
      node.typeAnnotation = this.tsParseTypeAnnotation(false);
      node.asserts = false;
      return this.finishNode(node, "TSTypePredicate");
    }

    tsParseThisTypeNode() {
      const node = this.startNode();
      this.next();
      return this.finishNode(node, "TSThisType");
    }

    tsParseTypeQuery() {
      const node = this.startNode();
      this.expect(types$1._typeof);

      if (this.match(types$1._import)) {
        node.exprName = this.tsParseImportType();
      } else {
        node.exprName = this.tsParseEntityName(true);
      }

      return this.finishNode(node, "TSTypeQuery");
    }

    tsParseTypeParameter() {
      const node = this.startNode();
      node.name = this.parseIdentifierName(node.start);
      node.constraint = this.tsEatThenParseType(types$1._extends);
      node.default = this.tsEatThenParseType(types$1.eq);
      return this.finishNode(node, "TSTypeParameter");
    }

    tsTryParseTypeParameters() {
      if (this.isRelational("<")) {
        return this.tsParseTypeParameters();
      }
    }

    tsParseTypeParameters() {
      const node = this.startNode();

      if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
        this.next();
      } else {
        this.unexpected();
      }

      node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);

      if (node.params.length === 0) {
        this.raise(node.start, TSErrors.EmptyTypeParameters);
      }

      return this.finishNode(node, "TSTypeParameterDeclaration");
    }

    tsTryNextParseConstantContext() {
      if (this.lookahead().type === types$1._const) {
        this.next();
        return this.tsParseTypeReference();
      }

      return null;
    }

    tsFillSignature(returnToken, signature) {
      const returnTokenRequired = returnToken === types$1.arrow;
      signature.typeParameters = this.tsTryParseTypeParameters();
      this.expect(types$1.parenL);
      signature.parameters = this.tsParseBindingListForSignature();

      if (returnTokenRequired) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      } else if (this.match(returnToken)) {
        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
      }
    }

    tsParseBindingListForSignature() {
      return this.parseBindingList(types$1.parenR, 41).map(pattern => {
        if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
          this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
        }

        return pattern;
      });
    }

    tsParseTypeMemberSemicolon() {
      if (!this.eat(types$1.comma) && !this.isLineTerminator()) {
        this.expect(types$1.semi);
      }
    }

    tsParseSignatureMember(kind, node) {
      this.tsFillSignature(types$1.colon, node);
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, kind);
    }

    tsIsUnambiguouslyIndexSignature() {
      this.next();
      return this.eat(types$1.name) && this.match(types$1.colon);
    }

    tsTryParseIndexSignature(node) {
      if (!(this.match(types$1.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
        return undefined;
      }

      this.expect(types$1.bracketL);
      const id = this.parseIdentifier();
      id.typeAnnotation = this.tsParseTypeAnnotation();
      this.resetEndLocation(id);
      this.expect(types$1.bracketR);
      node.parameters = [id];
      const type = this.tsTryParseTypeAnnotation();
      if (type) node.typeAnnotation = type;
      this.tsParseTypeMemberSemicolon();
      return this.finishNode(node, "TSIndexSignature");
    }

    tsParsePropertyOrMethodSignature(node, readonly) {
      if (this.eat(types$1.question)) node.optional = true;
      const nodeAny = node;

      if (this.match(types$1.parenL) || this.isRelational("<")) {
        if (readonly) {
          this.raise(node.start, TSErrors.ReadonlyForMethodSignature);
        }

        const method = nodeAny;

        if (method.kind && this.isRelational("<")) {
          this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
        }

        this.tsFillSignature(types$1.colon, method);
        this.tsParseTypeMemberSemicolon();

        if (method.kind === "get") {
          if (method.parameters.length > 0) {
            this.raise(this.state.pos, ErrorMessages.BadGetterArity);

            if (this.isThisParam(method.parameters[0])) {
              this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
            }
          }
        } else if (method.kind === "set") {
          if (method.parameters.length !== 1) {
            this.raise(this.state.pos, ErrorMessages.BadSetterArity);
          } else {
            const firstParameter = method.parameters[0];

            if (this.isThisParam(firstParameter)) {
              this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
            }

            if (firstParameter.type === "Identifier" && firstParameter.optional) {
              this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
            }

            if (firstParameter.type === "RestElement") {
              this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
            }
          }

          if (method.typeAnnotation) {
            this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
          }
        } else {
          method.kind = "method";
        }

        return this.finishNode(method, "TSMethodSignature");
      } else {
        const property = nodeAny;
        if (readonly) property.readonly = true;
        const type = this.tsTryParseTypeAnnotation();
        if (type) property.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(property, "TSPropertySignature");
      }
    }

    tsParseTypeMember() {
      const node = this.startNode();

      if (this.match(types$1.parenL) || this.isRelational("<")) {
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
      }

      if (this.match(types$1._new)) {
        const id = this.startNode();
        this.next();

        if (this.match(types$1.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
        } else {
          node.key = this.createIdentifier(id, "new");
          return this.tsParsePropertyOrMethodSignature(node, false);
        }
      }

      this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
      const idx = this.tsTryParseIndexSignature(node);

      if (idx) {
        return idx;
      }

      this.parsePropertyName(node, false);

      if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
        node.kind = node.key.name;
        this.parsePropertyName(node, false);
      }

      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
    }

    tsParseTypeLiteral() {
      const node = this.startNode();
      node.members = this.tsParseObjectTypeMembers();
      return this.finishNode(node, "TSTypeLiteral");
    }

    tsParseObjectTypeMembers() {
      this.expect(types$1.braceL);
      const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      this.expect(types$1.braceR);
      return members;
    }

    tsIsStartOfMappedType() {
      this.next();

      if (this.eat(types$1.plusMin)) {
        return this.isContextual("readonly");
      }

      if (this.isContextual("readonly")) {
        this.next();
      }

      if (!this.match(types$1.bracketL)) {
        return false;
      }

      this.next();

      if (!this.tsIsIdentifier()) {
        return false;
      }

      this.next();
      return this.match(types$1._in);
    }

    tsParseMappedTypeParameter() {
      const node = this.startNode();
      node.name = this.parseIdentifierName(node.start);
      node.constraint = this.tsExpectThenParseType(types$1._in);
      return this.finishNode(node, "TSTypeParameter");
    }

    tsParseMappedType() {
      const node = this.startNode();
      this.expect(types$1.braceL);

      if (this.match(types$1.plusMin)) {
        node.readonly = this.state.value;
        this.next();
        this.expectContextual("readonly");
      } else if (this.eatContextual("readonly")) {
        node.readonly = true;
      }

      this.expect(types$1.bracketL);
      node.typeParameter = this.tsParseMappedTypeParameter();
      node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
      this.expect(types$1.bracketR);

      if (this.match(types$1.plusMin)) {
        node.optional = this.state.value;
        this.next();
        this.expect(types$1.question);
      } else if (this.eat(types$1.question)) {
        node.optional = true;
      }

      node.typeAnnotation = this.tsTryParseType();
      this.semicolon();
      this.expect(types$1.braceR);
      return this.finishNode(node, "TSMappedType");
    }

    tsParseTupleType() {
      const node = this.startNode();
      node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
      let seenOptionalElement = false;
      let labeledElements = null;
      node.elementTypes.forEach(elementNode => {
        var _labeledElements;

        let {
          type
        } = elementNode;

        if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
          this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
        }

        seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";

        if (type === "TSRestType") {
          elementNode = elementNode.typeAnnotation;
          type = elementNode.type;
        }

        const isLabeled = type === "TSNamedTupleMember";
        labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;

        if (labeledElements !== isLabeled) {
          this.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
        }
      });
      return this.finishNode(node, "TSTupleType");
    }

    tsParseTupleElementType() {
      const {
        start: startPos,
        startLoc
      } = this.state;
      const rest = this.eat(types$1.ellipsis);
      let type = this.tsParseType();
      const optional = this.eat(types$1.question);
      const labeled = this.eat(types$1.colon);

      if (labeled) {
        const labeledNode = this.startNodeAtNode(type);
        labeledNode.optional = optional;

        if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
          labeledNode.label = type.typeName;
        } else {
          this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
          labeledNode.label = type;
        }

        labeledNode.elementType = this.tsParseType();
        type = this.finishNode(labeledNode, "TSNamedTupleMember");
      } else if (optional) {
        const optionalTypeNode = this.startNodeAtNode(type);
        optionalTypeNode.typeAnnotation = type;
        type = this.finishNode(optionalTypeNode, "TSOptionalType");
      }

      if (rest) {
        const restNode = this.startNodeAt(startPos, startLoc);
        restNode.typeAnnotation = type;
        type = this.finishNode(restNode, "TSRestType");
      }

      return type;
    }

    tsParseParenthesizedType() {
      const node = this.startNode();
      this.expect(types$1.parenL);
      node.typeAnnotation = this.tsParseType();
      this.expect(types$1.parenR);
      return this.finishNode(node, "TSParenthesizedType");
    }

    tsParseFunctionOrConstructorType(type, abstract) {
      const node = this.startNode();

      if (type === "TSConstructorType") {
        node.abstract = !!abstract;
        if (abstract) this.next();
        this.next();
      }

      this.tsFillSignature(types$1.arrow, node);
      return this.finishNode(node, type);
    }

    tsParseLiteralTypeNode() {
      const node = this.startNode();

      node.literal = (() => {
        switch (this.state.type) {
          case types$1.num:
          case types$1.bigint:
          case types$1.string:
          case types$1._true:
          case types$1._false:
            return this.parseExprAtom();

          default:
            throw this.unexpected();
        }
      })();

      return this.finishNode(node, "TSLiteralType");
    }

    tsParseTemplateLiteralType() {
      const node = this.startNode();
      node.literal = this.parseTemplate(false);
      return this.finishNode(node, "TSLiteralType");
    }

    parseTemplateSubstitution() {
      if (this.state.inType) return this.tsParseType();
      return super.parseTemplateSubstitution();
    }

    tsParseThisTypeOrThisTypePredicate() {
      const thisKeyword = this.tsParseThisTypeNode();

      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
        return this.tsParseThisTypePredicate(thisKeyword);
      } else {
        return thisKeyword;
      }
    }

    tsParseNonArrayType() {
      switch (this.state.type) {
        case types$1.name:
        case types$1._void:
        case types$1._null:
          {
            const type = this.match(types$1._void) ? "TSVoidKeyword" : this.match(types$1._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

            if (type !== undefined && this.lookaheadCharCode() !== 46) {
              const node = this.startNode();
              this.next();
              return this.finishNode(node, type);
            }

            return this.tsParseTypeReference();
          }

        case types$1.string:
        case types$1.num:
        case types$1.bigint:
        case types$1._true:
        case types$1._false:
          return this.tsParseLiteralTypeNode();

        case types$1.plusMin:
          if (this.state.value === "-") {
            const node = this.startNode();
            const nextToken = this.lookahead();

            if (nextToken.type !== types$1.num && nextToken.type !== types$1.bigint) {
              throw this.unexpected();
            }

            node.literal = this.parseMaybeUnary();
            return this.finishNode(node, "TSLiteralType");
          }

          break;

        case types$1._this:
          return this.tsParseThisTypeOrThisTypePredicate();

        case types$1._typeof:
          return this.tsParseTypeQuery();

        case types$1._import:
          return this.tsParseImportType();

        case types$1.braceL:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

        case types$1.bracketL:
          return this.tsParseTupleType();

        case types$1.parenL:
          return this.tsParseParenthesizedType();

        case types$1.backQuote:
          return this.tsParseTemplateLiteralType();
      }

      throw this.unexpected();
    }

    tsParseArrayTypeOrHigher() {
      let type = this.tsParseNonArrayType();

      while (!this.hasPrecedingLineBreak() && this.eat(types$1.bracketL)) {
        if (this.match(types$1.bracketR)) {
          const node = this.startNodeAtNode(type);
          node.elementType = type;
          this.expect(types$1.bracketR);
          type = this.finishNode(node, "TSArrayType");
        } else {
          const node = this.startNodeAtNode(type);
          node.objectType = type;
          node.indexType = this.tsParseType();
          this.expect(types$1.bracketR);
          type = this.finishNode(node, "TSIndexedAccessType");
        }
      }

      return type;
    }

    tsParseTypeOperator(operator) {
      const node = this.startNode();
      this.expectContextual(operator);
      node.operator = operator;
      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

      if (operator === "readonly") {
        this.tsCheckTypeAnnotationForReadOnly(node);
      }

      return this.finishNode(node, "TSTypeOperator");
    }

    tsCheckTypeAnnotationForReadOnly(node) {
      switch (node.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;

        default:
          this.raise(node.start, TSErrors.UnexpectedReadonly);
      }
    }

    tsParseInferType() {
      const node = this.startNode();
      this.expectContextual("infer");
      const typeParameter = this.startNode();
      typeParameter.name = this.parseIdentifierName(typeParameter.start);
      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
      return this.finishNode(node, "TSInferType");
    }

    tsParseTypeOperatorOrHigher() {
      const operator = ["keyof", "unique", "readonly"].find(kw => this.isContextual(kw));
      return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
    }

    tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
      const node = this.startNode();
      const hasLeadingOperator = this.eat(operator);
      const types = [];

      do {
        types.push(parseConstituentType());
      } while (this.eat(operator));

      if (types.length === 1 && !hasLeadingOperator) {
        return types[0];
      }

      node.types = types;
      return this.finishNode(node, kind);
    }

    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types$1.bitwiseAND);
    }

    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types$1.bitwiseOR);
    }

    tsIsStartOfFunctionType() {
      if (this.isRelational("<")) {
        return true;
      }

      return this.match(types$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }

    tsSkipParameterStart() {
      if (this.match(types$1.name) || this.match(types$1._this)) {
        this.next();
        return true;
      }

      if (this.match(types$1.braceL)) {
        let braceStackCounter = 1;
        this.next();

        while (braceStackCounter > 0) {
          if (this.match(types$1.braceL)) {
            ++braceStackCounter;
          } else if (this.match(types$1.braceR)) {
            --braceStackCounter;
          }

          this.next();
        }

        return true;
      }

      if (this.match(types$1.bracketL)) {
        let braceStackCounter = 1;
        this.next();

        while (braceStackCounter > 0) {
          if (this.match(types$1.bracketL)) {
            ++braceStackCounter;
          } else if (this.match(types$1.bracketR)) {
            --braceStackCounter;
          }

          this.next();
        }

        return true;
      }

      return false;
    }

    tsIsUnambiguouslyStartOfFunctionType() {
      this.next();

      if (this.match(types$1.parenR) || this.match(types$1.ellipsis)) {
        return true;
      }

      if (this.tsSkipParameterStart()) {
        if (this.match(types$1.colon) || this.match(types$1.comma) || this.match(types$1.question) || this.match(types$1.eq)) {
          return true;
        }

        if (this.match(types$1.parenR)) {
          this.next();

          if (this.match(types$1.arrow)) {
            return true;
          }
        }
      }

      return false;
    }

    tsParseTypeOrTypePredicateAnnotation(returnToken) {
      return this.tsInType(() => {
        const t = this.startNode();
        this.expect(returnToken);
        const node = this.startNode();
        const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));

        if (asserts && this.match(types$1._this)) {
          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();

          if (thisTypePredicate.type === "TSThisType") {
            node.parameterName = thisTypePredicate;
            node.asserts = true;
            node.typeAnnotation = null;
            thisTypePredicate = this.finishNode(node, "TSTypePredicate");
          } else {
            this.resetStartLocationFromNode(thisTypePredicate, node);
            thisTypePredicate.asserts = true;
          }

          t.typeAnnotation = thisTypePredicate;
          return this.finishNode(t, "TSTypeAnnotation");
        }

        const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));

        if (!typePredicateVariable) {
          if (!asserts) {
            return this.tsParseTypeAnnotation(false, t);
          }

          node.parameterName = this.parseIdentifier();
          node.asserts = asserts;
          node.typeAnnotation = null;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        }

        const type = this.tsParseTypeAnnotation(false);
        node.parameterName = typePredicateVariable;
        node.typeAnnotation = type;
        node.asserts = asserts;
        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
        return this.finishNode(t, "TSTypeAnnotation");
      });
    }

    tsTryParseTypeOrTypePredicateAnnotation() {
      return this.match(types$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types$1.colon) : undefined;
    }

    tsTryParseTypeAnnotation() {
      return this.match(types$1.colon) ? this.tsParseTypeAnnotation() : undefined;
    }

    tsTryParseType() {
      return this.tsEatThenParseType(types$1.colon);
    }

    tsParseTypePredicatePrefix() {
      const id = this.parseIdentifier();

      if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
        this.next();
        return id;
      }
    }

    tsParseTypePredicateAsserts() {
      if (!this.match(types$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
        return false;
      }

      const containsEsc = this.state.containsEsc;
      this.next();

      if (!this.match(types$1.name) && !this.match(types$1._this)) {
        return false;
      }

      if (containsEsc) {
        this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
      }

      return true;
    }

    tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
      this.tsInType(() => {
        if (eatColon) this.expect(types$1.colon);
        t.typeAnnotation = this.tsParseType();
      });
      return this.finishNode(t, "TSTypeAnnotation");
    }

    tsParseType() {
      assert$1(this.state.inType);
      const type = this.tsParseNonConditionalType();

      if (this.hasPrecedingLineBreak() || !this.eat(types$1._extends)) {
        return type;
      }

      const node = this.startNodeAtNode(type);
      node.checkType = type;
      node.extendsType = this.tsParseNonConditionalType();
      this.expect(types$1.question);
      node.trueType = this.tsParseType();
      this.expect(types$1.colon);
      node.falseType = this.tsParseType();
      return this.finishNode(node, "TSConditionalType");
    }

    isAbstractConstructorSignature() {
      return this.isContextual("abstract") && this.lookahead().type === types$1._new;
    }

    tsParseNonConditionalType() {
      if (this.tsIsStartOfFunctionType()) {
        return this.tsParseFunctionOrConstructorType("TSFunctionType");
      }

      if (this.match(types$1._new)) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType");
      } else if (this.isAbstractConstructorSignature()) {
        return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
      }

      return this.tsParseUnionTypeOrHigher();
    }

    tsParseTypeAssertion() {
      const node = this.startNode();

      const _const = this.tsTryNextParseConstantContext();

      node.typeAnnotation = _const || this.tsNextThenParseType();
      this.expectRelational(">");
      node.expression = this.parseMaybeUnary();
      return this.finishNode(node, "TSTypeAssertion");
    }

    tsParseHeritageClause(descriptor) {
      const originalStart = this.state.start;
      const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

      if (!delimitedList.length) {
        this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
      }

      return delimitedList;
    }

    tsParseExpressionWithTypeArguments() {
      const node = this.startNode();
      node.expression = this.tsParseEntityName(false);

      if (this.isRelational("<")) {
        node.typeParameters = this.tsParseTypeArguments();
      }

      return this.finishNode(node, "TSExpressionWithTypeArguments");
    }

    tsParseInterfaceDeclaration(node) {
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
      node.typeParameters = this.tsTryParseTypeParameters();

      if (this.eat(types$1._extends)) {
        node.extends = this.tsParseHeritageClause("extends");
      }

      const body = this.startNode();
      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
      node.body = this.finishNode(body, "TSInterfaceBody");
      return this.finishNode(node, "TSInterfaceDeclaration");
    }

    tsParseTypeAliasDeclaration(node) {
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
      node.typeParameters = this.tsTryParseTypeParameters();
      node.typeAnnotation = this.tsInType(() => {
        this.expect(types$1.eq);

        if (this.isContextual("intrinsic") && this.lookahead().type !== types$1.dot) {
          const node = this.startNode();
          this.next();
          return this.finishNode(node, "TSIntrinsicKeyword");
        }

        return this.tsParseType();
      });
      this.semicolon();
      return this.finishNode(node, "TSTypeAliasDeclaration");
    }

    tsInNoContext(cb) {
      const oldContext = this.state.context;
      this.state.context = [oldContext[0]];

      try {
        return cb();
      } finally {
        this.state.context = oldContext;
      }
    }

    tsInType(cb) {
      const oldInType = this.state.inType;
      this.state.inType = true;

      try {
        return cb();
      } finally {
        this.state.inType = oldInType;
      }
    }

    tsEatThenParseType(token) {
      return !this.match(token) ? undefined : this.tsNextThenParseType();
    }

    tsExpectThenParseType(token) {
      return this.tsDoThenParseType(() => this.expect(token));
    }

    tsNextThenParseType() {
      return this.tsDoThenParseType(() => this.next());
    }

    tsDoThenParseType(cb) {
      return this.tsInType(() => {
        cb();
        return this.tsParseType();
      });
    }

    tsParseEnumMember() {
      const node = this.startNode();
      node.id = this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);

      if (this.eat(types$1.eq)) {
        node.initializer = this.parseMaybeAssignAllowIn();
      }

      return this.finishNode(node, "TSEnumMember");
    }

    tsParseEnumDeclaration(node, isConst) {
      if (isConst) node.const = true;
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
      this.expect(types$1.braceL);
      node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
      this.expect(types$1.braceR);
      return this.finishNode(node, "TSEnumDeclaration");
    }

    tsParseModuleBlock() {
      const node = this.startNode();
      this.scope.enter(SCOPE_OTHER);
      this.expect(types$1.braceL);
      this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types$1.braceR);
      this.scope.exit();
      return this.finishNode(node, "TSModuleBlock");
    }

    tsParseModuleOrNamespaceDeclaration(node, nested = false) {
      node.id = this.parseIdentifier();

      if (!nested) {
        this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
      }

      if (this.eat(types$1.dot)) {
        const inner = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(inner, true);
        node.body = inner;
      } else {
        this.scope.enter(SCOPE_TS_MODULE);
        this.prodParam.enter(PARAM);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      }

      return this.finishNode(node, "TSModuleDeclaration");
    }

    tsParseAmbientExternalModuleDeclaration(node) {
      if (this.isContextual("global")) {
        node.global = true;
        node.id = this.parseIdentifier();
      } else if (this.match(types$1.string)) {
        node.id = this.parseExprAtom();
      } else {
        this.unexpected();
      }

      if (this.match(types$1.braceL)) {
        this.scope.enter(SCOPE_TS_MODULE);
        this.prodParam.enter(PARAM);
        node.body = this.tsParseModuleBlock();
        this.prodParam.exit();
        this.scope.exit();
      } else {
        this.semicolon();
      }

      return this.finishNode(node, "TSModuleDeclaration");
    }

    tsParseImportEqualsDeclaration(node, isExport) {
      node.isExport = isExport || false;
      node.id = this.parseIdentifier();
      this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
      this.expect(types$1.eq);
      const moduleReference = this.tsParseModuleReference();

      if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
        this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
      }

      node.moduleReference = moduleReference;
      this.semicolon();
      return this.finishNode(node, "TSImportEqualsDeclaration");
    }

    tsIsExternalModuleReference() {
      return this.isContextual("require") && this.lookaheadCharCode() === 40;
    }

    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
    }

    tsParseExternalModuleReference() {
      const node = this.startNode();
      this.expectContextual("require");
      this.expect(types$1.parenL);

      if (!this.match(types$1.string)) {
        throw this.unexpected();
      }

      node.expression = this.parseExprAtom();
      this.expect(types$1.parenR);
      return this.finishNode(node, "TSExternalModuleReference");
    }

    tsLookAhead(f) {
      const state = this.state.clone();
      const res = f();
      this.state = state;
      return res;
    }

    tsTryParseAndCatch(f) {
      const result = this.tryParse(abort => f() || abort());
      if (result.aborted || !result.node) return undefined;
      if (result.error) this.state = result.failState;
      return result.node;
    }

    tsTryParse(f) {
      const state = this.state.clone();
      const result = f();

      if (result !== undefined && result !== false) {
        return result;
      } else {
        this.state = state;
        return undefined;
      }
    }

    tsTryParseDeclare(nany) {
      if (this.isLineTerminator()) {
        return;
      }

      let starttype = this.state.type;
      let kind;

      if (this.isContextual("let")) {
        starttype = types$1._var;
        kind = "let";
      }

      return this.tsInAmbientContext(() => {
        switch (starttype) {
          case types$1._function:
            nany.declare = true;
            return this.parseFunctionStatement(nany, false, true);

          case types$1._class:
            nany.declare = true;
            return this.parseClass(nany, true, false);

          case types$1._const:
            if (this.match(types$1._const) && this.isLookaheadContextual("enum")) {
              this.expect(types$1._const);
              this.expectContextual("enum");
              return this.tsParseEnumDeclaration(nany, true);
            }

          case types$1._var:
            kind = kind || this.state.value;
            return this.parseVarStatement(nany, kind);

          case types$1.name:
            {
              const value = this.state.value;

              if (value === "global") {
                return this.tsParseAmbientExternalModuleDeclaration(nany);
              } else {
                return this.tsParseDeclaration(nany, value, true);
              }
            }
        }
      });
    }

    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.value, true);
    }

    tsParseExpressionStatement(node, expr) {
      switch (expr.name) {
        case "declare":
          {
            const declaration = this.tsTryParseDeclare(node);

            if (declaration) {
              declaration.declare = true;
              return declaration;
            }

            break;
          }

        case "global":
          if (this.match(types$1.braceL)) {
            this.scope.enter(SCOPE_TS_MODULE);
            this.prodParam.enter(PARAM);
            const mod = node;
            mod.global = true;
            mod.id = expr;
            mod.body = this.tsParseModuleBlock();
            this.scope.exit();
            this.prodParam.exit();
            return this.finishNode(mod, "TSModuleDeclaration");
          }

          break;

        default:
          return this.tsParseDeclaration(node, expr.name, false);
      }
    }

    tsParseDeclaration(node, value, next) {
      switch (value) {
        case "abstract":
          if (this.tsCheckLineTerminator(next) && (this.match(types$1._class) || this.match(types$1.name))) {
            return this.tsParseAbstractDeclaration(node);
          }

          break;

        case "enum":
          if (next || this.match(types$1.name)) {
            if (next) this.next();
            return this.tsParseEnumDeclaration(node, false);
          }

          break;

        case "interface":
          if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
            return this.tsParseInterfaceDeclaration(node);
          }

          break;

        case "module":
          if (this.tsCheckLineTerminator(next)) {
            if (this.match(types$1.string)) {
              return this.tsParseAmbientExternalModuleDeclaration(node);
            } else if (this.match(types$1.name)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
          }

          break;

        case "namespace":
          if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
            return this.tsParseModuleOrNamespaceDeclaration(node);
          }

          break;

        case "type":
          if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
            return this.tsParseTypeAliasDeclaration(node);
          }

          break;
      }
    }

    tsCheckLineTerminator(next) {
      if (next) {
        if (this.hasFollowingLineBreak()) return false;
        this.next();
        return true;
      }

      return !this.isLineTerminator();
    }

    tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
      if (!this.isRelational("<")) {
        return undefined;
      }

      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = true;
      const res = this.tsTryParseAndCatch(() => {
        const node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = this.tsParseTypeParameters();
        super.parseFunctionParams(node);
        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
        this.expect(types$1.arrow);
        return node;
      });
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;

      if (!res) {
        return undefined;
      }

      return this.parseArrowExpression(res, null, true);
    }

    tsParseTypeArguments() {
      const node = this.startNode();
      node.params = this.tsInType(() => this.tsInNoContext(() => {
        this.expectRelational("<");
        return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
      }));

      if (node.params.length === 0) {
        this.raise(node.start, TSErrors.EmptyTypeArguments);
      }

      this.expectRelational(">");
      return this.finishNode(node, "TSTypeParameterInstantiation");
    }

    tsIsDeclarationStart() {
      if (this.match(types$1.name)) {
        switch (this.state.value) {
          case "abstract":
          case "declare":
          case "enum":
          case "interface":
          case "module":
          case "namespace":
          case "type":
            return true;
        }
      }

      return false;
    }

    isExportDefaultSpecifier() {
      if (this.tsIsDeclarationStart()) return false;
      return super.isExportDefaultSpecifier();
    }

    parseAssignableListItem(allowModifiers, decorators) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let accessibility;
      let readonly = false;
      let override = false;

      if (allowModifiers !== undefined) {
        const modified = {};
        this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
        accessibility = modified.accessibility;
        override = modified.override;
        readonly = modified.readonly;

        if (allowModifiers === false && (accessibility || readonly || override)) {
          this.raise(startPos, TSErrors.UnexpectedParameterModifier);
        }
      }

      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (accessibility || readonly || override) {
        const pp = this.startNodeAt(startPos, startLoc);

        if (decorators.length) {
          pp.decorators = decorators;
        }

        if (accessibility) pp.accessibility = accessibility;
        if (readonly) pp.readonly = readonly;
        if (override) pp.override = override;

        if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
          this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
        }

        pp.parameter = elt;
        return this.finishNode(pp, "TSParameterProperty");
      }

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }

    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      if (this.match(types$1.colon)) {
        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
      }

      const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

      if (bodilessType && !this.match(types$1.braceL) && this.isLineTerminator()) {
        this.finishNode(node, bodilessType);
        return;
      }

      if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
        this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);

        if (node.declare) {
          super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          return;
        }
      }

      super.parseFunctionBodyAndFinish(node, type, isMethod);
    }

    registerFunctionStatementId(node) {
      if (!node.body && node.id) {
        this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
      } else {
        super.registerFunctionStatementId(...arguments);
      }
    }

    tsCheckForInvalidTypeCasts(items) {
      items.forEach(node => {
        if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
          this.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
        }
      });
    }

    toReferencedList(exprList, isInParens) {
      this.tsCheckForInvalidTypeCasts(exprList);
      return exprList;
    }

    parseArrayLike(...args) {
      const node = super.parseArrayLike(...args);

      if (node.type === "ArrayExpression") {
        this.tsCheckForInvalidTypeCasts(node.elements);
      }

      return node;
    }

    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!this.hasPrecedingLineBreak() && this.match(types$1.bang)) {
        this.state.exprAllowed = false;
        this.next();
        const nonNullExpression = this.startNodeAt(startPos, startLoc);
        nonNullExpression.expression = base;
        return this.finishNode(nonNullExpression, "TSNonNullExpression");
      }

      if (this.isRelational("<")) {
        const result = this.tsTryParseAndCatch(() => {
          if (!noCalls && this.atPossibleAsyncArrow(base)) {
            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

            if (asyncArrowFn) {
              return asyncArrowFn;
            }
          }

          const node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          const typeArguments = this.tsParseTypeArguments();

          if (typeArguments) {
            if (!noCalls && this.eat(types$1.parenL)) {
              node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
              this.tsCheckForInvalidTypeCasts(node.arguments);
              node.typeParameters = typeArguments;

              if (state.optionalChainMember) {
                node.optional = false;
              }

              return this.finishCallExpression(node, state.optionalChainMember);
            } else if (this.match(types$1.backQuote)) {
              const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
              result.typeParameters = typeArguments;
              return result;
            }
          }

          this.unexpected();
        });
        if (result) return result;
      }

      return super.parseSubscript(base, startPos, startLoc, noCalls, state);
    }

    parseNewArguments(node) {
      if (this.isRelational("<")) {
        const typeParameters = this.tsTryParseAndCatch(() => {
          const args = this.tsParseTypeArguments();
          if (!this.match(types$1.parenL)) this.unexpected();
          return args;
        });

        if (typeParameters) {
          node.typeParameters = typeParameters;
        }
      }

      super.parseNewArguments(node);
    }

    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      if (nonNull(types$1._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
        const node = this.startNodeAt(leftStartPos, leftStartLoc);
        node.expression = left;

        const _const = this.tsTryNextParseConstantContext();

        if (_const) {
          node.typeAnnotation = _const;
        } else {
          node.typeAnnotation = this.tsNextThenParseType();
        }

        this.finishNode(node, "TSAsExpression");
        this.reScan_lt_gt();
        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
      }

      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);
    }

    checkReservedWord(word, startLoc, checkKeywords, isBinding) {}

    checkDuplicateExports() {}

    parseImport(node) {
      node.importKind = "value";

      if (this.match(types$1.name) || this.match(types$1.star) || this.match(types$1.braceL)) {
        let ahead = this.lookahead();

        if (this.isContextual("type") && ahead.type !== types$1.comma && !(ahead.type === types$1.name && ahead.value === "from") && ahead.type !== types$1.eq) {
          node.importKind = "type";
          this.next();
          ahead = this.lookahead();
        }

        if (this.match(types$1.name) && ahead.type === types$1.eq) {
          return this.tsParseImportEqualsDeclaration(node);
        }
      }

      const importNode = super.parseImport(node);

      if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
        this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
      }

      return importNode;
    }

    parseExport(node) {
      if (this.match(types$1._import)) {
        this.next();

        if (this.isContextual("type") && this.lookaheadCharCode() !== 61) {
          node.importKind = "type";
          this.next();
        } else {
          node.importKind = "value";
        }

        return this.tsParseImportEqualsDeclaration(node, true);
      } else if (this.eat(types$1.eq)) {
        const assign = node;
        assign.expression = this.parseExpression();
        this.semicolon();
        return this.finishNode(assign, "TSExportAssignment");
      } else if (this.eatContextual("as")) {
        const decl = node;
        this.expectContextual("namespace");
        decl.id = this.parseIdentifier();
        this.semicolon();
        return this.finishNode(decl, "TSNamespaceExportDeclaration");
      } else {
        if (this.isContextual("type") && this.lookahead().type === types$1.braceL) {
          this.next();
          node.exportKind = "type";
        } else {
          node.exportKind = "value";
        }

        return super.parseExport(node);
      }
    }

    isAbstractClass() {
      return this.isContextual("abstract") && this.lookahead().type === types$1._class;
    }

    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        const cls = this.startNode();
        this.next();
        cls.abstract = true;
        this.parseClass(cls, true, true);
        return cls;
      }

      if (this.state.value === "interface") {
        const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
        if (result) return result;
      }

      return super.parseExportDefaultExpression();
    }

    parseStatementContent(context, topLevel) {
      if (this.state.type === types$1._const) {
        const ahead = this.lookahead();

        if (ahead.type === types$1.name && ahead.value === "enum") {
          const node = this.startNode();
          this.expect(types$1._const);
          this.expectContextual("enum");
          return this.tsParseEnumDeclaration(node, true);
        }
      }

      return super.parseStatementContent(context, topLevel);
    }

    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }

    tsHasSomeModifiers(member, modifiers) {
      return modifiers.some(modifier => {
        if (tsIsAccessModifier(modifier)) {
          return member.accessibility === modifier;
        }

        return !!member[modifier];
      });
    }

    parseClassMember(classBody, member, state) {
      const invalidModifersForStaticBlocks = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
      this.tsParseModifiers(member, invalidModifersForStaticBlocks.concat(["static"]));

      const callParseClassMemberWithIsStatic = () => {
        const isStatic = !!member.static;

        if (isStatic && this.eat(types$1.braceL)) {
          if (this.tsHasSomeModifiers(member, invalidModifersForStaticBlocks)) {
            this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);
          }

          this.parseClassStaticBlock(classBody, member);
        } else {
          this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
        }
      };

      if (member.declare) {
        this.tsInAmbientContext(callParseClassMemberWithIsStatic);
      } else {
        callParseClassMemberWithIsStatic();
      }
    }

    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const idx = this.tsTryParseIndexSignature(member);

      if (idx) {
        classBody.body.push(idx);

        if (member.abstract) {
          this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
        }

        if (member.accessibility) {
          this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
        }

        if (member.declare) {
          this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
        }

        if (member.override) {
          this.raise(member.start, TSErrors.IndexSignatureHasOverride);
        }

        return;
      }

      if (!this.state.inAbstractClass && member.abstract) {
        this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
      }

      if (member.override) {
        if (!state.hadSuperClass) {
          this.raise(member.start, TSErrors.OverrideNotInSubClass);
        }
      }

      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }

    parsePostMemberNameModifiers(methodOrProp) {
      const optional = this.eat(types$1.question);
      if (optional) methodOrProp.optional = true;

      if (methodOrProp.readonly && this.match(types$1.parenL)) {
        this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
      }

      if (methodOrProp.declare && this.match(types$1.parenL)) {
        this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
      }
    }

    parseExpressionStatement(node, expr) {
      const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
      return decl || super.parseExpressionStatement(node, expr);
    }

    shouldParseExportDeclaration() {
      if (this.tsIsDeclarationStart()) return true;
      return super.shouldParseExportDeclaration();
    }

    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (!this.state.maybeInArrowParameters || !this.match(types$1.question)) {
        return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);
      }

      const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));

      if (!result.node) {
        if (result.error) {
          super.setOptionalParametersError(refExpressionErrors, result.error);
        }

        return expr;
      }

      if (result.error) this.state = result.failState;
      return result.node;
    }

    parseParenItem(node, startPos, startLoc) {
      node = super.parseParenItem(node, startPos, startLoc);

      if (this.eat(types$1.question)) {
        node.optional = true;
        this.resetEndLocation(node);
      }

      if (this.match(types$1.colon)) {
        const typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
        return this.finishNode(typeCastNode, "TSTypeCastExpression");
      }

      return node;
    }

    parseExportDeclaration(node) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const isDeclare = this.eatContextual("declare");

      if (isDeclare && (this.isContextual("declare") || !this.shouldParseExportDeclaration())) {
        throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
      }

      let declaration;

      if (this.match(types$1.name)) {
        declaration = this.tsTryParseExportDeclaration();
      }

      if (!declaration) {
        declaration = super.parseExportDeclaration(node);
      }

      if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
        node.exportKind = "type";
      }

      if (declaration && isDeclare) {
        this.resetStartLocation(declaration, startPos, startLoc);
        declaration.declare = true;
      }

      return declaration;
    }

    parseClassId(node, isStatement, optionalId) {
      if ((!isStatement || optionalId) && this.isContextual("implements")) {
        return;
      }

      super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) node.typeParameters = typeParameters;
    }

    parseClassPropertyAnnotation(node) {
      if (!node.optional && this.eat(types$1.bang)) {
        node.definite = true;
      }

      const type = this.tsTryParseTypeAnnotation();
      if (type) node.typeAnnotation = type;
    }

    parseClassProperty(node) {
      this.parseClassPropertyAnnotation(node);

      if (this.state.isAmbientContext && this.match(types$1.eq)) {
        this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
      }

      return super.parseClassProperty(node);
    }

    parseClassPrivateProperty(node) {
      if (node.abstract) {
        this.raise(node.start, TSErrors.PrivateElementHasAbstract);
      }

      if (node.accessibility) {
        this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
      }

      this.parseClassPropertyAnnotation(node);
      return super.parseClassPrivateProperty(node);
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      const typeParameters = this.tsTryParseTypeParameters();

      if (typeParameters && isConstructor) {
        this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
      }

      if (method.declare && (method.kind === "get" || method.kind === "set")) {
        this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
      }

      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
    }

    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) method.typeParameters = typeParameters;
      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
    }

    parseClassSuper(node) {
      super.parseClassSuper(node);

      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.tsParseTypeArguments();
      }

      if (this.eatContextual("implements")) {
        node.implements = this.tsParseHeritageClause("implements");
      }
    }

    parseObjPropValue(prop, ...args) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) prop.typeParameters = typeParameters;
      super.parseObjPropValue(prop, ...args);
    }

    parseFunctionParams(node, allowModifiers) {
      const typeParameters = this.tsTryParseTypeParameters();
      if (typeParameters) node.typeParameters = typeParameters;
      super.parseFunctionParams(node, allowModifiers);
    }

    parseVarId(decl, kind) {
      super.parseVarId(decl, kind);

      if (decl.id.type === "Identifier" && this.eat(types$1.bang)) {
        decl.definite = true;
      }

      const type = this.tsTryParseTypeAnnotation();

      if (type) {
        decl.id.typeAnnotation = type;
        this.resetEndLocation(decl.id);
      }
    }

    parseAsyncArrowFromCallExpression(node, call) {
      if (this.match(types$1.colon)) {
        node.returnType = this.tsParseTypeAnnotation();
      }

      return super.parseAsyncArrowFromCallExpression(node, call);
    }

    parseMaybeAssign(...args) {
      var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;

      let state;
      let jsx;
      let typeCast;

      if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
        state = this.state.clone();
        jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);
        if (!jsx.error) return jsx.node;
        const {
          context
        } = this.state;

        if (context[context.length - 1] === types$2.j_oTag) {
          context.length -= 2;
        } else if (context[context.length - 1] === types$2.j_expr) {
          context.length -= 1;
        }
      }

      if (!((_jsx = jsx) != null && _jsx.error) && !this.isRelational("<")) {
        return super.parseMaybeAssign(...args);
      }

      let typeParameters;
      state = state || this.state.clone();
      const arrow = this.tryParse(abort => {
        var _expr$extra, _typeParameters;

        typeParameters = this.tsParseTypeParameters();
        const expr = super.parseMaybeAssign(...args);

        if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          abort();
        }

        if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
          this.resetStartLocationFromNode(expr, typeParameters);
        }

        expr.typeParameters = typeParameters;
        return expr;
      }, state);
      if (!arrow.error && !arrow.aborted) return arrow.node;

      if (!jsx) {
        assert$1(!this.hasPlugin("jsx"));
        typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);
        if (!typeCast.error) return typeCast.node;
      }

      if ((_jsx2 = jsx) != null && _jsx2.node) {
        this.state = jsx.failState;
        return jsx.node;
      }

      if (arrow.node) {
        this.state = arrow.failState;
        return arrow.node;
      }

      if ((_typeCast = typeCast) != null && _typeCast.node) {
        this.state = typeCast.failState;
        return typeCast.node;
      }

      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
      if (arrow.thrown) throw arrow.error;
      if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
      throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
    }

    parseMaybeUnary(refExpressionErrors) {
      if (!this.hasPlugin("jsx") && this.isRelational("<")) {
        return this.tsParseTypeAssertion();
      } else {
        return super.parseMaybeUnary(refExpressionErrors);
      }
    }

    parseArrow(node) {
      if (this.match(types$1.colon)) {
        const result = this.tryParse(abort => {
          const returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
          if (this.canInsertSemicolon() || !this.match(types$1.arrow)) abort();
          return returnType;
        });
        if (result.aborted) return;

        if (!result.thrown) {
          if (result.error) this.state = result.failState;
          node.returnType = result.node;
        }
      }

      return super.parseArrow(node);
    }

    parseAssignableListItemTypes(param) {
      if (this.eat(types$1.question)) {
        if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
          this.raise(param.start, TSErrors.PatternIsOptional);
        }

        param.optional = true;
      }

      const type = this.tsTryParseTypeAnnotation();
      if (type) param.typeAnnotation = type;
      this.resetEndLocation(param);
      return param;
    }

    toAssignable(node, isLHS = false) {
      switch (node.type) {
        case "TSTypeCastExpression":
          return super.toAssignable(this.typeCastToParameter(node), isLHS);

        case "TSParameterProperty":
          return super.toAssignable(node, isLHS);

        case "ParenthesizedExpression":
          return this.toAssignableParenthesizedExpression(node, isLHS);

        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          node.expression = this.toAssignable(node.expression, isLHS);
          return node;

        default:
          return super.toAssignable(node, isLHS);
      }
    }

    toAssignableParenthesizedExpression(node, isLHS) {
      switch (node.expression.type) {
        case "TSAsExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          node.expression = this.toAssignable(node.expression, isLHS);
          return node;

        default:
          return super.toAssignable(node, isLHS);
      }
    }

    checkLVal(expr, contextDescription, ...args) {
      var _expr$extra2;

      switch (expr.type) {
        case "TSTypeCastExpression":
          return;

        case "TSParameterProperty":
          this.checkLVal(expr.parameter, "parameter property", ...args);
          return;

        case "TSAsExpression":
        case "TSTypeAssertion":
          if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
            this.raise(expr.start, ErrorMessages.InvalidLhs, contextDescription);
            break;
          }

          this.checkLVal(expr.expression, "parenthesized expression", ...args);
          return;

        case "TSNonNullExpression":
          this.checkLVal(expr.expression, contextDescription, ...args);
          return;

        default:
          super.checkLVal(expr, contextDescription, ...args);
          return;
      }
    }

    parseBindingAtom() {
      switch (this.state.type) {
        case types$1._this:
          return this.parseIdentifier(true);

        default:
          return super.parseBindingAtom();
      }
    }

    parseMaybeDecoratorArguments(expr) {
      if (this.isRelational("<")) {
        const typeArguments = this.tsParseTypeArguments();

        if (this.match(types$1.parenL)) {
          const call = super.parseMaybeDecoratorArguments(expr);
          call.typeParameters = typeArguments;
          return call;
        }

        this.unexpected(this.state.start, types$1.parenL);
      }

      return super.parseMaybeDecoratorArguments(expr);
    }

    checkCommaAfterRest(close) {
      if (this.state.isAmbientContext && this.match(types$1.comma) && this.lookaheadCharCode() === close) {
        this.next();
      } else {
        super.checkCommaAfterRest(close);
      }
    }

    isClassMethod() {
      return this.isRelational("<") || super.isClassMethod();
    }

    isClassProperty() {
      return this.match(types$1.bang) || this.match(types$1.colon) || super.isClassProperty();
    }

    parseMaybeDefault(...args) {
      const node = super.parseMaybeDefault(...args);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
      }

      return node;
    }

    getTokenFromCode(code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types$1.relational, 1);
      } else {
        return super.getTokenFromCode(code);
      }
    }

    reScan_lt_gt() {
      if (this.match(types$1.relational)) {
        const code = this.input.charCodeAt(this.state.start);

        if (code === 60 || code === 62) {
          this.state.pos -= 1;
          this.readToken_lt_gt(code);
        }
      }
    }

    toAssignableList(exprList) {
      for (let i = 0; i < exprList.length; i++) {
        const expr = exprList[i];
        if (!expr) continue;

        switch (expr.type) {
          case "TSTypeCastExpression":
            exprList[i] = this.typeCastToParameter(expr);
            break;

          case "TSAsExpression":
          case "TSTypeAssertion":
            if (!this.state.maybeInArrowParameters) {
              exprList[i] = this.typeCastToParameter(expr);
            } else {
              this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
            }

            break;
        }
      }

      return super.toAssignableList(...arguments);
    }

    typeCastToParameter(node) {
      node.expression.typeAnnotation = node.typeAnnotation;
      this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
      return node.expression;
    }

    shouldParseArrow() {
      return this.match(types$1.colon) || super.shouldParseArrow();
    }

    shouldParseAsyncArrow() {
      return this.match(types$1.colon) || super.shouldParseAsyncArrow();
    }

    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }

    jsxParseOpeningElementAfterName(node) {
      if (this.isRelational("<")) {
        const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
        if (typeArguments) node.typeParameters = typeArguments;
      }

      return super.jsxParseOpeningElementAfterName(node);
    }

    getGetterSetterExpectedParamCount(method) {
      const baseCount = super.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const firstParam = params[0];
      const hasContextParam = firstParam && this.isThisParam(firstParam);
      return hasContextParam ? baseCount + 1 : baseCount;
    }

    parseCatchClauseParam() {
      const param = super.parseCatchClauseParam();
      const type = this.tsTryParseTypeAnnotation();

      if (type) {
        param.typeAnnotation = type;
        this.resetEndLocation(param);
      }

      return param;
    }

    tsInAmbientContext(cb) {
      const oldIsAmbientContext = this.state.isAmbientContext;
      this.state.isAmbientContext = true;

      try {
        return cb();
      } finally {
        this.state.isAmbientContext = oldIsAmbientContext;
      }
    }

    parseClass(node, ...args) {
      const oldInAbstractClass = this.state.inAbstractClass;
      this.state.inAbstractClass = !!node.abstract;

      try {
        return super.parseClass(node, ...args);
      } finally {
        this.state.inAbstractClass = oldInAbstractClass;
      }
    }

    tsParseAbstractDeclaration(node) {
      if (this.match(types$1._class)) {
        node.abstract = true;
        return this.parseClass(node, true, false);
      } else if (this.isContextual("interface")) {
        if (!this.hasFollowingLineBreak()) {
          node.abstract = true;
          this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
          this.next();
          return this.tsParseInterfaceDeclaration(node);
        }
      } else {
        this.unexpected(null, types$1._class);
      }
    }

    parseMethod(...args) {
      const method = super.parseMethod(...args);

      if (method.abstract) {
        const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;

        if (hasBody) {
          const {
            key
          } = method;
          this.raise(method.start, TSErrors.AbstractMethodHasImplementation, key.type === "Identifier" ? key.name : `[${this.input.slice(key.start, key.end)}]`);
        }
      }

      return method;
    }

    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }

    parse() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }

      return super.parse();
    }

    getExpression() {
      if (this.shouldParseAsAmbientContext()) {
        this.state.isAmbientContext = true;
      }

      return super.getExpression();
    }

  });

  types$1.placeholder = new TokenType("%%", {
    startsExpr: true
  });
  const PlaceHolderErrors = makeErrorTemplates({
    ClassNameIsRequired: "A class name is required."
  }, ErrorCodes.SyntaxError);
  var placeholders$1 = (superClass => class extends superClass {
    parsePlaceholder(expectedNode) {
      if (this.match(types$1.placeholder)) {
        const node = this.startNode();
        this.next();
        this.assertNoSpace("Unexpected space in placeholder.");
        node.name = super.parseIdentifier(true);
        this.assertNoSpace("Unexpected space in placeholder.");
        this.expect(types$1.placeholder);
        return this.finishPlaceholder(node, expectedNode);
      }
    }

    finishPlaceholder(node, expectedNode) {
      const isFinished = !!(node.expectedNode && node.type === "Placeholder");
      node.expectedNode = expectedNode;
      return isFinished ? node : this.finishNode(node, "Placeholder");
    }

    getTokenFromCode(code) {
      if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
        return this.finishOp(types$1.placeholder, 2);
      }

      return super.getTokenFromCode(...arguments);
    }

    parseExprAtom() {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
    }

    parseIdentifier() {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
    }

    checkReservedWord(word) {
      if (word !== undefined) super.checkReservedWord(...arguments);
    }

    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
    }

    checkLVal(expr) {
      if (expr.type !== "Placeholder") super.checkLVal(...arguments);
    }

    toAssignable(node) {
      if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
        node.expectedNode = "Pattern";
        return node;
      }

      return super.toAssignable(...arguments);
    }

    isLet(context) {
      if (super.isLet(context)) {
        return true;
      }

      if (!this.isContextual("let")) {
        return false;
      }

      if (context) return false;
      const nextToken = this.lookahead();

      if (nextToken.type === types$1.placeholder) {
        return true;
      }

      return false;
    }

    verifyBreakContinue(node) {
      if (node.label && node.label.type === "Placeholder") return;
      super.verifyBreakContinue(...arguments);
    }

    parseExpressionStatement(node, expr) {
      if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
        return super.parseExpressionStatement(...arguments);
      }

      if (this.match(types$1.colon)) {
        const stmt = node;
        stmt.label = this.finishPlaceholder(expr, "Identifier");
        this.next();
        stmt.body = this.parseStatement("label");
        return this.finishNode(stmt, "LabeledStatement");
      }

      this.semicolon();
      node.name = expr.name;
      return this.finishPlaceholder(node, "Statement");
    }

    parseBlock() {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
    }

    parseFunctionId() {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
    }

    parseClass(node, isStatement, optionalId) {
      const type = isStatement ? "ClassDeclaration" : "ClassExpression";
      this.next();
      this.takeDecorators(node);
      const oldStrict = this.state.strict;
      const placeholder = this.parsePlaceholder("Identifier");

      if (placeholder) {
        if (this.match(types$1._extends) || this.match(types$1.placeholder) || this.match(types$1.braceL)) {
          node.id = placeholder;
        } else if (optionalId || !isStatement) {
          node.id = null;
          node.body = this.finishPlaceholder(placeholder, "ClassBody");
          return this.finishNode(node, type);
        } else {
          this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
        }
      } else {
        this.parseClassId(node, isStatement, optionalId);
      }

      this.parseClassSuper(node);
      node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, type);
    }

    parseExport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseExport(...arguments);

      if (!this.isContextual("from") && !this.match(types$1.comma)) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.finishPlaceholder(placeholder, "Declaration");
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      this.expectPlugin("exportDefaultFrom");
      const specifier = this.startNode();
      specifier.exported = placeholder;
      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
      return super.parseExport(node);
    }

    isExportDefaultSpecifier() {
      if (this.match(types$1._default)) {
        const next = this.nextTokenStart();

        if (this.isUnparsedContextual(next, "from")) {
          if (this.input.startsWith(types$1.placeholder.label, this.nextTokenStartSince(next + 4))) {
            return true;
          }
        }
      }

      return super.isExportDefaultSpecifier();
    }

    maybeParseExportDefaultSpecifier(node) {
      if (node.specifiers && node.specifiers.length > 0) {
        return true;
      }

      return super.maybeParseExportDefaultSpecifier(...arguments);
    }

    checkExport(node) {
      const {
        specifiers
      } = node;

      if (specifiers != null && specifiers.length) {
        node.specifiers = specifiers.filter(node => node.exported.type === "Placeholder");
      }

      super.checkExport(node);
      node.specifiers = specifiers;
    }

    parseImport(node) {
      const placeholder = this.parsePlaceholder("Identifier");
      if (!placeholder) return super.parseImport(...arguments);
      node.specifiers = [];

      if (!this.isContextual("from") && !this.match(types$1.comma)) {
        node.source = this.finishPlaceholder(placeholder, "StringLiteral");
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }

      const specifier = this.startNodeAtNode(placeholder);
      specifier.local = placeholder;
      this.finishNode(specifier, "ImportDefaultSpecifier");
      node.specifiers.push(specifier);

      if (this.eat(types$1.comma)) {
        const hasStarImport = this.maybeParseStarImportSpecifier(node);
        if (!hasStarImport) this.parseNamedImportSpecifiers(node);
      }

      this.expectContextual("from");
      node.source = this.parseImportSource();
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }

    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
    }

  });

  var v8intrinsic = (superClass => class extends superClass {
    parseV8Intrinsic() {
      if (this.match(types$1.modulo)) {
        const v8IntrinsicStart = this.state.start;
        const node = this.startNode();
        this.eat(types$1.modulo);

        if (this.match(types$1.name)) {
          const name = this.parseIdentifierName(this.state.start);
          const identifier = this.createIdentifier(node, name);
          identifier.type = "V8IntrinsicIdentifier";

          if (this.match(types$1.parenL)) {
            return identifier;
          }
        }

        this.unexpected(v8IntrinsicStart);
      }
    }

    parseExprAtom() {
      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
    }

  });

  function hasPlugin(plugins, name) {
    return plugins.some(plugin => {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });
  }
  function getPluginOption(plugins, name, option) {
    const plugin = plugins.find(plugin => {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });

    if (plugin && Array.isArray(plugin)) {
      return plugin[1][option];
    }

    return null;
  }
  const PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
  const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }

      const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

      if (decoratorsBeforeExport == null) {
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
      } else if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }

    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }

    if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
      throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(", "));
    }

    if (hasPlugin(plugins, "moduleAttributes")) {
      {
        if (hasPlugin(plugins, "importAssertions")) {
          throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
        }

        const moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

        if (moduleAttributesVerionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
        }
      }
    }

    if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(", "));
    }

    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
      const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      error.missingPlugins = "doExpressions";
      throw error;
    }
  }
  const mixinPlugins = {
    estree,
    jsx: jsx$1,
    flow: flow$1,
    typescript: typescript$1,
    v8intrinsic,
    placeholders: placeholders$1
  };
  const mixinPluginNames = Object.keys(mixinPlugins);

  const defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false
  };
  function getOptions(opts) {
    const options = {};

    for (const key of Object.keys(defaultOptions)) {
      options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    }

    return options;
  }

  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  const VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100]);
  const forbiddenNumericSeparatorSiblings = {
    decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
    hex: [46, 88, 95, 120]
  };
  const allowedNumericSeparatorSiblings = {};
  allowedNumericSeparatorSiblings.bin = [48, 49];
  allowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];
  allowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];
  allowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
  class Token {
    constructor(state) {
      this.type = state.type;
      this.value = state.value;
      this.start = state.start;
      this.end = state.end;
      this.loc = new SourceLocation(state.startLoc, state.endLoc);
    }

  }
  class Tokenizer extends ParserError {
    constructor(options, input) {
      super();
      this.isLookahead = void 0;
      this.tokens = [];
      this.state = new State();
      this.state.init(options);
      this.input = input;
      this.length = input.length;
      this.isLookahead = false;
    }

    pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    }

    next() {
      this.checkKeywordEscapes();

      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    }

    eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    }

    match(type) {
      return this.state.type === type;
    }

    createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        lastTokEnd: state.end,
        context: [this.curContext()],
        inType: state.inType
      };
    }

    lookahead() {
      const old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      const curr = this.state;
      this.state = old;
      return curr;
    }

    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }

    nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      const skip = skipWhiteSpace.exec(this.input);
      return pos + skip[0].length;
    }

    lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    }

    codePointAtPos(pos) {
      let cp = this.input.charCodeAt(pos);

      if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
        const trail = this.input.charCodeAt(pos);

        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }

      return cp;
    }

    setStrict(strict) {
      this.state.strict = strict;

      if (strict) {
        this.state.strictErrors.forEach((message, pos) => this.raise(pos, message));
        this.state.strictErrors.clear();
      }
    }

    curContext() {
      return this.state.context[this.state.context.length - 1];
    }

    nextToken() {
      const curContext = this.curContext();
      if (!curContext.preserveSpace) this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead) this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types$1.eof);
        return;
      }

      if (curContext === types$2.template) {
        this.readTmplToken();
      } else {
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
    }

    pushComment(block, text, start, end, startLoc, endLoc) {
      const comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      if (this.options.tokens) this.pushToken(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }

    skipBlockComment() {
      let startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      const start = this.state.pos;
      const end = this.input.indexOf("*/", this.state.pos + 2);
      if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      let match;

      while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    }

    skipLineComment(startSkip) {
      const start = this.state.pos;
      let startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      let ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    }

    skipSpace() {
      loop: while (this.state.pos < this.length) {
        const ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }

        }
      }
    }

    finishToken(type, val) {
      this.state.end = this.state.pos;
      const prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;

      if (!this.isLookahead) {
        this.state.endLoc = this.state.curPosition();
        this.updateContext(prevType);
      }
    }

    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      const nextPos = this.state.pos + 1;
      const next = this.codePointAtPos(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
      }

      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");

        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
          throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
        }

        this.state.pos += 2;

        if (next === 123) {
          this.finishToken(types$1.braceHashL);
        } else {
          this.finishToken(types$1.bracketHashL);
        }
      } else if (isIdentifierStart$1(next)) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1());
      } else {
        this.finishOp(types$1.hash, 1);
      }
    }

    readToken_dot() {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types$1.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.dot);
      }
    }

    readToken_slash() {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.slashAssign, 2);
      } else {
        this.finishOp(types$1.slash, 1);
      }
    }

    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      let ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      const start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      const value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types$1.interpreterDirective, value);
      return true;
    }

    readToken_mult_modulo(code) {
      let type = code === 42 ? types$1.star : types$1.modulo;
      let width = 1;
      let next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types$1.exponent;
      }

      if (next === 61 && !this.state.inType) {
        width++;
        type = types$1.assign;
      }

      this.finishOp(type, width);
    }

    readToken_pipe_amp(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types$1.pipeline, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
          }

          this.state.pos += 2;
          this.finishToken(types$1.braceBarR);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
          }

          this.state.pos += 2;
          this.finishToken(types$1.bracketBarR);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    }

    readToken_caret() {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.bitwiseXOR, 1);
      }
    }

    readToken_plus_min(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types$1.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.plusMin, 1);
      }
    }

    readToken_lt_gt(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);
      let size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types$1.assign, size + 1);
          return;
        }

        this.finishOp(types$1.bitShift, size);
        return;
      }

      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types$1.relational, size);
    }

    readToken_eq_excl(code) {
      const next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types$1.arrow);
        return;
      }

      this.finishOp(code === 61 ? types$1.eq : types$1.bang, 1);
    }

    readToken_question() {
      const next = this.input.charCodeAt(this.state.pos + 1);
      const next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(types$1.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types$1.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.question);
      }
    }

    getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types$1.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types$1.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types$1.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types$1.comma);
          return;

        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
            }

            this.state.pos += 2;
            this.finishToken(types$1.bracketBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.bracketL);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types$1.bracketR);
          return;

        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
            }

            this.state.pos += 2;
            this.finishToken(types$1.braceBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.braceL);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types$1.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types$1.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types$1.backQuote);
          return;

        case 48:
          {
            const next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types$1.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types$1.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart$1(code)) {
            this.readWord(code);
            return;
          }

      }

      throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    }

    finishOp(type, size) {
      const str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    }

    readRegexp() {
      const start = this.state.start + 1;
      let escaped, inClass;
      let {
        pos
      } = this.state;

      for (;; ++pos) {
        if (pos >= this.length) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        const ch = this.input.charCodeAt(pos);

        if (isNewLine(ch)) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }

          escaped = ch === 92;
        }
      }

      const content = this.input.slice(start, pos);
      ++pos;
      let mods = "";

      while (pos < this.length) {
        const cp = this.codePointAtPos(pos);
        const char = String.fromCharCode(cp);

        if (VALID_REGEX_FLAGS.has(cp)) {
          if (mods.includes(char)) {
            this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar$1(cp) || cp === 92) {
          this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);
        } else {
          break;
        }

        ++pos;
        mods += char;
      }

      this.state.pos = pos;
      this.finishToken(types$1.regexp, {
        pattern: content,
        flags: mods
      });
    }

    readInt(radix, len, forceLen, allowNumSeparator = true) {
      const start = this.state.pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      let invalid = false;
      let total = 0;

      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = this.input.charCodeAt(this.state.pos);
        let val;

        if (code === 95) {
          const prev = this.input.charCodeAt(this.state.pos - 1);
          const next = this.input.charCodeAt(this.state.pos + 1);

          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          }

          if (!allowNumSeparator) {
            this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
          }

          ++this.state.pos;
          continue;
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    }

    readRadixNumber(radix) {
      const start = this.state.pos;
      let isBigInt = false;
      this.state.pos += 2;
      const val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      }

      const next = this.input.charCodeAt(this.state.pos);

      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(start, ErrorMessages.InvalidDecimal);
      }

      if (isIdentifierStart$1(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      if (isBigInt) {
        const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types$1.bigint, str);
        return;
      }

      this.finishToken(types$1.num, val);
    }

    readNumber(startsWithDot) {
      const start = this.state.pos;
      let isFloat = false;
      let isBigInt = false;
      let isDecimal = false;
      let hasExponent = false;
      let isOctal = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, ErrorMessages.InvalidNumber);
      }

      const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (hasLeadingZero) {
        const integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);

        if (!this.state.strict) {
          const underscorePos = integer.indexOf("_");

          if (underscorePos > 0) {
            this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
          }
        }

        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }

      let next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) {
          this.raise(start, ErrorMessages.InvalidOrMissingExponent);
        }

        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidBigIntLiteral);
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (next === 109) {
        this.expectPlugin("decimal", this.state.pos);

        if (hasExponent || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidDecimal);
        }

        ++this.state.pos;
        isDecimal = true;
      }

      if (isIdentifierStart$1(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

      if (isBigInt) {
        this.finishToken(types$1.bigint, str);
        return;
      }

      if (isDecimal) {
        this.finishToken(types$1.decimal, str);
        return;
      }

      const val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types$1.num, val);
    }

    readCodePoint(throwOnInvalid) {
      const ch = this.input.charCodeAt(this.state.pos);
      let code;

      if (ch === 123) {
        const codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code !== null && code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    }

    readString(quote) {
      let out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        const ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types$1.string, out);
    }

    readTmplToken() {
      let out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
        }

        const ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types$1.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types$1.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types$1.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types$1.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          const escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    }

    recordStrictModeErrors(pos, message) {
      if (this.state.strict && !this.state.strictErrors.has(pos)) {
        this.raise(pos, message);
      } else {
        this.state.strictErrors.set(pos, message);
      }
    }

    readEscapedChar(inTemplate) {
      const throwOnInvalid = !inTemplate;
      const ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            const code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            const code = this.readCodePoint(throwOnInvalid);
            return code === null ? null : String.fromCodePoint(code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\u000b";

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            return null;
          } else {
            this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
          }

        default:
          if (ch >= 48 && ch <= 55) {
            const codePos = this.state.pos - 1;
            const match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            const next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else {
                this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    }

    readHexChar(len, forceLen, throwOnInvalid) {
      const codePos = this.state.pos;
      const n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }

      return n;
    }

    readWord1(firstCode) {
      this.state.containsEsc = false;
      let word = "";
      const start = this.state.pos;
      let chunkStart = this.state.pos;

      if (firstCode !== undefined) {
        this.state.pos += firstCode <= 0xffff ? 1 : 2;
      }

      while (this.state.pos < this.length) {
        const ch = this.codePointAtPos(this.state.pos);

        if (isIdentifierChar$1(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          const escStart = this.state.pos;
          const identifierCheck = this.state.pos === start ? isIdentifierStart$1 : isIdentifierChar$1;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
            chunkStart = this.state.pos - 1;
            continue;
          }

          ++this.state.pos;
          const esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    }

    readWord(firstCode) {
      const word = this.readWord1(firstCode);
      const type = keywords$1.get(word) || types$1.name;
      this.finishToken(type, word);
    }

    checkKeywordEscapes() {
      const kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
      }
    }

    updateContext(prevType) {
      var _this$state$type$upda, _this$state$type;

      (_this$state$type$upda = (_this$state$type = this.state.type).updateContext) == null ? void 0 : _this$state$type$upda.call(_this$state$type, this.state.context);
    }

  }

  class ClassScope {
    constructor() {
      this.privateNames = new Set();
      this.loneAccessors = new Map();
      this.undefinedPrivateNames = new Map();
    }

  }
  class ClassScopeHandler {
    constructor(raise) {
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
    }

    current() {
      return this.stack[this.stack.length - 1];
    }

    enter() {
      this.stack.push(new ClassScope());
    }

    exit() {
      const oldClassScope = this.stack.pop();
      const current = this.current();

      for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {
        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    }

    declarePrivateName(name, elementType, pos) {
      const classScope = this.current();
      let redefined = classScope.privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        const accessor = redefined && classScope.loneAccessors.get(name);

        if (accessor) {
          const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) classScope.loneAccessors.delete(name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
      }

      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames.delete(name);
    }

    usePrivateName(name, pos) {
      let classScope;

      for (classScope of this.stack) {
        if (classScope.privateNames.has(name)) return;
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    }

  }

  const kExpression = 0,
        kMaybeArrowParameterDeclaration = 1,
        kMaybeAsyncArrowParameterDeclaration = 2,
        kParameterDeclaration = 3;

  class ExpressionScope {
    constructor(type = kExpression) {
      this.type = void 0;
      this.type = type;
    }

    canBeArrowParameterDeclaration() {
      return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    }

    isCertainlyParameterDeclaration() {
      return this.type === kParameterDeclaration;
    }

  }

  class ArrowHeadParsingScope extends ExpressionScope {
    constructor(type) {
      super(type);
      this.errors = new Map();
    }

    recordDeclarationError(pos, template) {
      this.errors.set(pos, template);
    }

    clearDeclarationError(pos) {
      this.errors.delete(pos);
    }

    iterateErrors(iterator) {
      this.errors.forEach(iterator);
    }

  }

  class ExpressionScopeHandler {
    constructor(raise) {
      this.stack = [new ExpressionScope()];
      this.raise = raise;
    }

    enter(scope) {
      this.stack.push(scope);
    }

    exit() {
      this.stack.pop();
    }

    recordParameterInitializerError(pos, template) {
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];

      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(pos, template);
        } else {
          return;
        }

        scope = stack[--i];
      }

      this.raise(pos, template);
    }

    recordParenthesizedIdentifierError(pos, template) {
      const {
        stack
      } = this;
      const scope = stack[stack.length - 1];

      if (scope.isCertainlyParameterDeclaration()) {
        this.raise(pos, template);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(pos, template);
      } else {
        return;
      }
    }

    recordAsyncArrowParametersError(pos, template) {
      const {
        stack
      } = this;
      let i = stack.length - 1;
      let scope = stack[i];

      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
          scope.recordDeclarationError(pos, template);
        }

        scope = stack[--i];
      }
    }

    validateAsPattern() {
      const {
        stack
      } = this;
      const currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors((template, pos) => {
        this.raise(pos, template);
        let i = stack.length - 2;
        let scope = stack[i];

        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(pos);
          scope = stack[--i];
        }
      });
    }

  }
  function newParameterDeclarationScope() {
    return new ExpressionScope(kParameterDeclaration);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }

  class UtilParser extends Tokenizer {
    addExtra(node, key, val) {
      if (!node) return;
      const extra = node.extra = node.extra || {};
      extra[key] = val;
    }

    isRelational(op) {
      return this.match(types$1.relational) && this.state.value === op;
    }

    expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types$1.relational);
      }
    }

    isContextual(name) {
      return this.match(types$1.name) && this.state.value === name && !this.state.containsEsc;
    }

    isUnparsedContextual(nameStart, name) {
      const nameEnd = nameStart + name.length;

      if (this.input.slice(nameStart, nameEnd) === name) {
        const nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar$1(nextCh) || (nextCh & 0xfc00) === 0xd800);
      }

      return false;
    }

    isLookaheadContextual(name) {
      const next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    }

    eatContextual(name) {
      return this.isContextual(name) && this.eat(types$1.name);
    }

    expectContextual(name, template) {
      if (!this.eatContextual(name)) this.unexpected(null, template);
    }

    canInsertSemicolon() {
      return this.match(types$1.eof) || this.match(types$1.braceR) || this.hasPrecedingLineBreak();
    }

    hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    hasFollowingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.end, this.nextTokenStart()));
    }

    isLineTerminator() {
      return this.eat(types$1.semi) || this.canInsertSemicolon();
    }

    semicolon(allowAsi = true) {
      if (allowAsi ? this.isLineTerminator() : this.eat(types$1.semi)) return;
      this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
    }

    expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    }

    assertNoSpace(message = "Unexpected space.") {
      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedSpace",
          template: message
        });
      }
    }

    unexpected(pos, messageOrType = {
      code: ErrorCodes.SyntaxError,
      reasonCode: "UnexpectedToken",
      template: "Unexpected token"
    }) {
      if (messageOrType instanceof TokenType) {
        messageOrType = {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedToken",
          template: `Unexpected token, expected "${messageOrType.label}"`
        };
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    }

    expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, `This experimental syntax requires enabling the parser plugin: '${name}'`);
      }

      return true;
    }

    expectOnePlugin(names, pos) {
      if (!names.some(n => this.hasPlugin(n))) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(", ")}'`);
      }
    }

    tryParse(fn, oldState = this.state.clone()) {
      const abortSignal = {
        node: null
      };

      try {
        const node = fn((node = null) => {
          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          const failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState
          };
        }

        return {
          node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        const failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error,
            thrown: true,
            aborted: false,
            failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState
          };
        }

        throw error;
      }
    }

    checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      const {
        shorthandAssign,
        doubleProto,
        optionalParameters
      } = refExpressionErrors;

      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0;
      }

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, ErrorMessages.DuplicateProto);
      }

      if (optionalParameters >= 0) {
        this.unexpected(optionalParameters);
      }
    }

    isLiteralPropertyName() {
      return this.match(types$1.name) || !!this.state.type.keyword || this.match(types$1.string) || this.match(types$1.num) || this.match(types$1.bigint) || this.match(types$1.decimal);
    }

    isPrivateName(node) {
      return node.type === "PrivateName";
    }

    getPrivateNameSV(node) {
      return node.id.name;
    }

    hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    }

    isOptionalChain(node) {
      return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
    }

    isObjectProperty(node) {
      return node.type === "ObjectProperty";
    }

    isObjectMethod(node) {
      return node.type === "ObjectMethod";
    }

    initializeScopes(inModule = this.options.sourceType === "module") {
      const oldLabels = this.state.labels;
      this.state.labels = [];
      const oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      const oldInModule = this.inModule;
      this.inModule = inModule;
      const oldScope = this.scope;
      const ScopeHandler = this.getScopeHandler();
      this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
      const oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      const oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this.raise.bind(this));
      const oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
      return () => {
        this.state.labels = oldLabels;
        this.exportedIdentifiers = oldExportedIdentifiers;
        this.inModule = oldInModule;
        this.scope = oldScope;
        this.prodParam = oldProdParam;
        this.classScope = oldClassScope;
        this.expressionScope = oldExpressionScope;
      };
    }

    enterInitialScopes() {
      let paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
    }

  }
  class ExpressionErrors {
    constructor() {
      this.shorthandAssign = -1;
      this.doubleProto = -1;
      this.optionalParameters = -1;
    }

  }

  class Node {
    constructor(parser, pos, loc) {
      this.type = void 0;
      this.start = void 0;
      this.end = void 0;
      this.loc = void 0;
      this.range = void 0;
      this.leadingComments = void 0;
      this.trailingComments = void 0;
      this.innerComments = void 0;
      this.extra = void 0;
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser != null && parser.options.ranges) this.range = [pos, 0];
      if (parser != null && parser.filename) this.loc.filename = parser.filename;
    }

    __clone() {
      const newNode = new Node();
      const keys = Object.keys(this);

      for (let i = 0, length = keys.length; i < length; i++) {
        const key = keys[i];

        if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
          newNode[key] = this[key];
        }
      }

      return newNode;
    }

  }

  class NodeUtils extends UtilParser {
    startNode() {
      return new Node(this, this.state.start, this.state.startLoc);
    }

    startNodeAt(pos, loc) {
      return new Node(this, pos, loc);
    }

    startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    }

    finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    }

    finishNodeAt(node, type, pos, loc) {

      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    }

    resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    }

    resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {
      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    }

    resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    }

  }

  const unwrapParenthesizedExpression = node => {
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  };

  class LValParser extends NodeUtils {
    toAssignable(node, isLHS = false) {
      var _node$extra, _node$extra3;

      let parenthesized = undefined;

      if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          } else if (parenthesized.type !== "MemberExpression") {
            this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          }
        } else {
          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
      }

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;

            const prop = node.properties[i];
            const isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

            if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }

          break;

        case "ObjectProperty":
          this.toAssignable(node.value, isLHS);
          break;

        case "SpreadElement":
          {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            const arg = node.argument;
            this.toAssignable(arg, isLHS);
            break;
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
          break;

        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
          }

          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;

        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }

      return node;
    }

    toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        const error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isLHS);
      }
    }

    toAssignableList(exprList, trailingCommaPos, isLHS) {
      let end = exprList.length;

      if (end) {
        const last = exprList[end - 1];

        if ((last == null ? void 0 : last.type) === "RestElement") {
          --end;
        } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
          last.type = "RestElement";
          let arg = last.argument;
          this.toAssignable(arg, isLHS);
          arg = unwrapParenthesizedExpression(arg);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (let i = 0; i < end; i++) {
        const elt = exprList[i];

        if (elt) {
          this.toAssignable(elt, isLHS);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    }

    toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    }

    toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (const expr of exprList) {
        if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    }

    parseSpread(refExpressionErrors, refNeedsArrowPos) {
      const node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    }

    parseRestBinding() {
      const node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    }

    parseBindingAtom() {
      switch (this.state.type) {
        case types$1.bracketL:
          {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$1.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types$1.braceL:
          return this.parseObjectLike(types$1.braceR, true);
      }

      return this.parseIdentifier();
    }

    parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      const elts = [];
      let first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
        }

        if (allowEmpty && this.match(types$1.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types$1.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          const decorators = [];

          if (this.match(types$1.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
          }

          while (this.match(types$1.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    }

    parseAssignableListItem(allowModifiers, decorators) {
      const left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    }

    parseAssignableListItemTypes(param) {
      return param;
    }

    parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;

      startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(types$1.eq)) return left;
      const node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    }

    checkLVal(expr, contextDescription, bindingType = BIND_NONE, checkClashes, disallowLetBinding, strictModeChanged = false) {
      switch (expr.type) {
        case "Identifier":
          {
            const {
              name
            } = expr;

            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord$1(name, this.inModule) : isStrictBindOnlyReservedWord$1(name))) {
              this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
            }

            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(expr.start, ErrorMessages.ParamDupe);
              } else {
                checkClashes.add(name);
              }
            }

            if (disallowLetBinding && name === "let") {
              this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
            }

            if (!(bindingType & BIND_NONE)) {
              this.scope.declareName(name, bindingType, expr.start);
            }

            break;
          }

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
          }

          break;

        case "ObjectPattern":
          for (let prop of expr.properties) {
            if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;
            this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
          }

          break;

        case "ArrayPattern":
          for (const elem of expr.elements) {
            if (elem) {
              this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
          break;

        case "RestElement":
          this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
          break;

        default:
          {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
          }
      }
    }

    checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
      }
    }

    checkCommaAfterRest(close) {
      if (this.match(types$1.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    }

    raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    }

    raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    }

  }

  class ExpressionParser extends LValParser {
    checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }

      const key = prop.key;
      const name = key.type === "Identifier" ? key.name : key.value;

      if (name === "__proto__") {
        if (isRecord) {
          this.raise(key.start, ErrorMessages.RecordNoProto);
          return;
        }

        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, ErrorMessages.DuplicateProto);
          }
        }

        protoRef.used = true;
      }
    }

    shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    }

    getExpression() {
      let paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      this.nextToken();
      const expr = this.parseExpression();

      if (!this.match(types$1.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;

      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }

      return expr;
    }

    parseExpression(disallowIn, refExpressionErrors) {
      if (disallowIn) {
        return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }

      return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
    }

    parseExpressionBase(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const expr = this.parseMaybeAssign(refExpressionErrors);

      if (this.match(types$1.comma)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types$1.comma)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    }

    parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }

    parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
    }

    setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$pos;

      refExpressionErrors.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;
    }

    parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          let left = this.parseYield();

          if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
          }

          return left;
        }
      }

      let ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      if (this.match(types$1.parenL) || this.match(types$1.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      let left = this.parseMaybeConditional(refExpressionErrors);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        const node = this.startNodeAt(startPos, startLoc);
        const operator = this.state.value;
        node.operator = operator;

        if (this.match(types$1.eq)) {
          node.left = this.toAssignable(left, true);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }

        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }

        this.checkLVal(left, "assignment expression");
        this.next();
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentExpression");
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    }

    parseMaybeConditional(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprOps(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
    }

    parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (this.eat(types$1.question)) {
        const node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    }

    parseExprOps(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseMaybeUnary(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1);
    }

    parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      let prec = this.state.type.binop;

      if (prec != null && (this.prodParam.hasIn || !this.match(types$1._in))) {
        if (prec > minPrec) {
          const op = this.state.type;

          if (op === types$1.pipeline) {
            this.expectPlugin("pipelineOperator");

            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          }

          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          const logical = op === types$1.logicalOR || op === types$1.logicalAND;
          const coalesce = op === types$1.nullishCoalescing;

          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }

          this.next();

          if (op === types$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types$1.name) && this.state.value === "await" && this.prodParam.hasAwait) {
              throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec);
          this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          const nextOp = this.state.type;

          if (coalesce && (nextOp === types$1.logicalOR || nextOp === types$1.logicalAND) || logical && nextOp === types$1.nullishCoalescing) {
            throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
          }

          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
      }

      return left;
    }

    parseExprOpRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;

      switch (op) {
        case types$1.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "smart":
              return this.withTopicPermittingContext(() => {
                return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => {
                return this.parseFSharpPipelineBody(prec);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    }

    parseExprOpBaseRightExpr(op, prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
    }

    checkExponentialAfterUnary(node) {
      if (this.match(types$1.exponent)) {
        this.raise(node.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
      }
    }

    parseMaybeUnary(refExpressionErrors, sawUnary) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const isAwait = this.isContextual("await");

      if (isAwait && this.isAwaitAllowed()) {
        this.next();
        const expr = this.parseAwait(startPos, startLoc);
        if (!sawUnary) this.checkExponentialAfterUnary(expr);
        return expr;
      }

      if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
        return this.parseModuleExpression();
      }

      const update = this.match(types$1.incDec);
      const node = this.startNode();

      if (this.state.type.prefix) {
        node.operator = this.state.value;
        node.prefix = true;

        if (this.match(types$1._throw)) {
          this.expectPlugin("throwExpressions");
        }

        const isDelete = this.match(types$1._delete);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);

        if (this.state.strict && isDelete) {
          const arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, ErrorMessages.StrictDelete);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(node.start, ErrorMessages.DeletePrivateField);
          }
        }

        if (!update) {
          if (!sawUnary) this.checkExponentialAfterUnary(node);
          return this.finishNode(node, "UnaryExpression");
        }
      }

      const expr = this.parseUpdate(node, update, refExpressionErrors);

      if (isAwait) {
        const startsExpr = this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types$1.modulo);

        if (startsExpr && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(startPos, this.hasPlugin("topLevelAwait") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);
          return this.parseAwait(startPos, startLoc);
        }
      }

      return expr;
    }

    parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        this.checkLVal(node.argument, "prefix operation");
        return this.finishNode(node, "UpdateExpression");
      }

      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        const node = this.startNodeAt(startPos, startLoc);
        node.operator = this.state.value;
        node.prefix = false;
        node.argument = expr;
        this.checkLVal(expr, "postfix operation");
        this.next();
        expr = this.finishNode(node, "UpdateExpression");
      }

      return expr;
    }

    parseExprSubscripts(refExpressionErrors) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      const potentialArrowAt = this.state.potentialArrowAt;
      const expr = this.parseExprAtom(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    }

    parseSubscripts(base, startPos, startLoc, noCalls) {
      const state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    }

    parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types$1.doubleColon)) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (this.match(types$1.backQuote)) {
        return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
      }

      let optional = false;

      if (this.match(types$1.questionDot)) {
        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        state.optionalChainMember = optional = true;
        this.next();
      }

      if (!noCalls && this.match(types$1.parenL)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
      } else if (optional || this.match(types$1.bracketL) || this.eat(types$1.dot)) {
        return this.parseMember(base, startPos, startLoc, state, optional);
      } else {
        state.stop = true;
        return base;
      }
    }

    parseMember(base, startPos, startLoc, state, optional) {
      const node = this.startNodeAt(startPos, startLoc);
      const computed = this.eat(types$1.bracketL);
      node.object = base;
      node.computed = computed;
      const privateName = !computed && this.match(types$1.privateName) && this.state.value;
      const property = computed ? this.parseExpression() : privateName ? this.parsePrivateName() : this.parseIdentifier(true);

      if (privateName !== false) {
        if (node.object.type === "Super") {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }

        this.classScope.usePrivateName(privateName, property.start);
      }

      node.property = property;

      if (computed) {
        this.expect(types$1.bracketR);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    }

    parseBind(base, startPos, startLoc, noCalls, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    }

    parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      let refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      let node = this.startNodeAt(startPos, startLoc);
      node.callee = base;

      if (state.maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors();
      }

      if (state.optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR);
      } else {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
      }

      this.finishCallExpression(node, state.optionalChainMember);

      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
      } else {
        if (state.maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }

        this.toReferencedArguments(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }

    toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    }

    parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      const node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);

      if (state.optionalChainMember) {
        this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    }

    atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    }

    finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          {
            if (!this.hasPlugin("moduleAttributes")) {
              this.expectPlugin("importAssertions");
            }
          }
        }

        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        } else {
          for (const arg of node.arguments) {
            if (arg.type === "SpreadElement") {
              this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
            }
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    }

    parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      const elts = [];
      let first = true;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    }

    shouldParseAsyncArrow() {
      return this.match(types$1.arrow) && !this.canInsertSemicolon();
    }

    parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types$1.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      return node;
    }

    parseNoCallExpr() {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    }

    parseExprAtom(refExpressionErrors) {
      let node;

      switch (this.state.type) {
        case types$1._super:
          return this.parseSuper();

        case types$1._import:
          node = this.startNode();
          this.next();

          if (this.match(types$1.dot)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(types$1.parenL)) {
            this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
          }

          return this.finishNode(node, "Import");

        case types$1._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types$1.name:
          {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            const containsEsc = this.state.containsEsc;
            const id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              if (this.match(types$1._function)) {
                this.next();
                return this.parseFunction(this.startNodeAtNode(id), undefined, true);
              } else if (this.match(types$1.name)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(id);
                } else {
                  return id;
                }
              } else if (this.match(types$1._do)) {
                return this.parseDo(true);
              }
            }

            if (canBeArrow && this.match(types$1.arrow) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }

            return id;
          }

        case types$1._do:
          {
            return this.parseDo(false);
          }

        case types$1.slash:
        case types$1.slashAssign:
          {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }

        case types$1.num:
          return this.parseNumericLiteral(this.state.value);

        case types$1.bigint:
          return this.parseBigIntLiteral(this.state.value);

        case types$1.decimal:
          return this.parseDecimalLiteral(this.state.value);

        case types$1.string:
          return this.parseStringLiteral(this.state.value);

        case types$1._null:
          return this.parseNullLiteral();

        case types$1._true:
          return this.parseBooleanLiteral(true);

        case types$1._false:
          return this.parseBooleanLiteral(false);

        case types$1.parenL:
          {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }

        case types$1.bracketBarL:
        case types$1.bracketHashL:
          {
            return this.parseArrayLike(this.state.type === types$1.bracketBarL ? types$1.bracketBarR : types$1.bracketR, false, true, refExpressionErrors);
          }

        case types$1.bracketL:
          {
            return this.parseArrayLike(types$1.bracketR, true, false, refExpressionErrors);
          }

        case types$1.braceBarL:
        case types$1.braceHashL:
          {
            return this.parseObjectLike(this.state.type === types$1.braceBarL ? types$1.braceBarR : types$1.braceR, false, true, refExpressionErrors);
          }

        case types$1.braceL:
          {
            return this.parseObjectLike(types$1.braceR, false, false, refExpressionErrors);
          }

        case types$1._function:
          return this.parseFunctionOrFunctionSent();

        case types$1.at:
          this.parseDecorators();

        case types$1._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types$1._new:
          return this.parseNewOrNewTarget();

        case types$1.backQuote:
          return this.parseTemplate(false);

        case types$1.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
            }
          }

        case types$1.privateName:
          {
            const start = this.state.start;
            const value = this.state.value;
            node = this.parsePrivateName();

            if (this.match(types$1._in)) {
              this.expectPlugin("privateIn");
              this.classScope.usePrivateName(value, node.start);
            } else if (this.hasPlugin("privateIn")) {
              this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, value);
            } else {
              throw this.unexpected(start);
            }

            return node;
          }

        case types$1.hash:
          {
            if (this.state.inPipeline) {
              node = this.startNode();

              if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);
              }

              this.next();

              if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);
              }

              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            }
          }

        case types$1.relational:
          {
            if (this.state.value === "<") {
              const lookaheadCh = this.input.codePointAt(this.nextTokenStart());

              if (isIdentifierStart$1(lookaheadCh) || lookaheadCh === 62) {
                  this.expectOnePlugin(["jsx", "flow", "typescript"]);
                }
            }
          }

        default:
          throw this.unexpected();
      }
    }

    parseAsyncArrowUnaryFunction(id) {
      const node = this.startNodeAtNode(id);
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      const params = [this.parseIdentifier()];
      this.prodParam.exit();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
      }

      this.expect(types$1.arrow);
      this.parseArrowExpression(node, params, true);
      return node;
    }

    parseDo(isAsync) {
      this.expectPlugin("doExpressions");

      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }

      const node = this.startNode();
      node.async = isAsync;
      this.next();
      const oldLabels = this.state.labels;
      this.state.labels = [];

      if (isAsync) {
        this.prodParam.enter(PARAM_AWAIT);
        node.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node.body = this.parseBlock();
      }

      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    }

    parseSuper() {
      const node = this.startNode();
      this.next();

      if (this.match(types$1.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.SuperNotAllowed);
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.UnexpectedSuper);
      }

      if (!this.match(types$1.parenL) && !this.match(types$1.bracketL) && !this.match(types$1.dot)) {
        this.raise(node.start, ErrorMessages.UnsupportedSuper);
      }

      return this.finishNode(node, "Super");
    }

    parseMaybePrivateName(isPrivateNameAllowed) {
      const isPrivate = this.match(types$1.privateName);

      if (isPrivate) {
        if (!isPrivateNameAllowed) {
          this.raise(this.state.start + 1, ErrorMessages.UnexpectedPrivateField);
        }

        return this.parsePrivateName();
      } else {
        return this.parseIdentifier(true);
      }
    }

    parsePrivateName() {
      const node = this.startNode();
      const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart));
      const name = this.state.value;
      this.next();
      node.id = this.createIdentifier(id, name);
      return this.finishNode(node, "PrivateName");
    }

    parseFunctionOrFunctionSent() {
      const node = this.startNode();
      this.next();

      if (this.prodParam.hasYield && this.match(types$1.dot)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    }

    parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      const containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
      }

      return this.finishNode(node, "MetaProperty");
    }

    parseImportMetaProperty(node) {
      const id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();

      if (this.isContextual("meta")) {
        if (!this.inModule) {
          this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
        }

        this.sawUnambiguousESM = true;
      }

      return this.parseMetaProperty(node, id, "meta");
    }

    parseLiteralAtNode(value, type, node) {
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    }

    parseLiteral(value, type) {
      const node = this.startNode();
      return this.parseLiteralAtNode(value, type, node);
    }

    parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    }

    parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    }

    parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    }

    parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    }

    parseRegExpLiteral(value) {
      const node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;
    }

    parseBooleanLiteral(value) {
      const node = this.startNode();
      node.value = value;
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    }

    parseNullLiteral() {
      const node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    }

    parseParenAndDistinguishExpression(canBeArrow) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      let val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      const innerStartPos = this.state.start;
      const innerStartLoc = this.state.startLoc;
      const exprList = [];
      const refExpressionErrors = new ExpressionErrors();
      let first = true;
      let spreadStart;
      let optionalCommaStart;

      while (!this.match(types$1.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);

          if (this.match(types$1.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types$1.ellipsis)) {
          const spreadNodeStartPos = this.state.start;
          const spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
      }

      const innerEndPos = this.state.lastTokEnd;
      const innerEndLoc = this.state.lastTokEndLoc;
      this.expect(types$1.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      this.expressionScope.exit();

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      const parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    }

    shouldParseArrow() {
      return !this.canInsertSemicolon();
    }

    parseArrow(node) {
      if (this.eat(types$1.arrow)) {
        return node;
      }
    }

    parseParenItem(node, startPos, startLoc) {
      return node;
    }

    parseNewOrNewTarget() {
      const node = this.startNode();
      this.next();

      if (this.match(types$1.dot)) {
        const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        const metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
        }

        return metaProp;
      }

      return this.parseNew(node);
    }

    parseNew(node) {
      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
      } else if (this.isOptionalChain(node.callee)) {
        this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
      } else if (this.eat(types$1.questionDot)) {
        this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    }

    parseNewArguments(node) {
      if (this.eat(types$1.parenL)) {
        const args = this.parseExprList(types$1.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    }

    parseTemplateElement(isTagged) {
      const elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types$1.backQuote);
      return this.finishNode(elem, "TemplateElement");
    }

    parseTemplate(isTagged) {
      const node = this.startNode();
      this.next();
      node.expressions = [];
      let curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseTemplateSubstitution());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    }

    parseTemplateSubstitution() {
      return this.parseExpression();
    }

    parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }

      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const propHash = Object.create(null);
      let first = true;
      const node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            break;
          }
        }

        const prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);

        if (!isPattern) {
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }

        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
        }

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      let type = "ObjectExpression";

      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }

      return this.finishNode(node, type);
    }

    maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types$1.bracketL) || this.match(types$1.star));
    }

    parsePropertyDefinition(isPattern, refExpressionErrors) {
      let decorators = [];

      if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
        }

        while (this.match(types$1.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      const prop = this.startNode();
      let isGenerator = false;
      let isAsync = false;
      let isAccessor = false;
      let startPos;
      let startLoc;

      if (this.match(types$1.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types$1.star);
      }

      const containsEsc = this.state.containsEsc;
      const key = this.parsePropertyName(prop, false);

      if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        const keyName = key.name;

        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          isGenerator = this.eat(types$1.star);
          this.parsePropertyName(prop, false);
        }

        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          prop.kind = keyName;

          if (this.match(types$1.star)) {
            isGenerator = true;
            this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
            this.next();
          }

          this.parsePropertyName(prop, false);
        }
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return prop;
    }

    getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    }

    getObjectOrClassMethodParams(method) {
      return method.params;
    }

    checkGetterSetterParams(method) {
      var _params;

      const paramCount = this.getGetterSetterExpectedParamCount(method);
      const params = this.getObjectOrClassMethodParams(method);
      const start = method.start;

      if (params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    }

    parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }

      if (isAsync || isGenerator || this.match(types$1.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    }

    parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;

      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, false);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types$1.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    }

    parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    }

    parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(types$1.bracketR);
      } else {
        const oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        const type = this.state.type;
        prop.key = type === types$1.num || type === types$1.string || type === types$1.bigint || type === types$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

        if (type !== types$1.privateName) {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    }

    initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    }

    parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      const allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return node;
    }

    parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }

      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      const node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    }

    parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      let flags = functionFlags(isAsync, false);

      if (!this.match(types$1.bracketL) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }

      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }

      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    }

    setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos, false);
    }

    parseFunctionBodyAndFinish(node, type, isMethod = false) {
      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    }

    parseFunctionBody(node, allowExpression, isMethod = false) {
      const isExpression = allowExpression && !this.match(types$1.braceL);
      this.expressionScope.enter(newExpressionScope());

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        const oldStrict = this.state.strict;
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, hasStrictModeDirective => {
          const nonSimple = !this.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            const errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;
            this.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }

          const strictModeChanged = !oldStrict && this.state.strict;
          this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

          if (this.state.strict && node.id) {
            this.checkLVal(node.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.expressionScope.exit();
        this.state.labels = oldLabels;
      }
    }

    isSimpleParamList(params) {
      for (let i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    }

    checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
      const checkClashes = new Set();

      for (const param of node.params) {
        this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);
      }
    }

    parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      const elts = [];
      let first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    }

    parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      let elt;

      if (this.match(types$1.comma)) {
        if (!allowEmpty) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
        }

        elt = null;
      } else if (this.match(types$1.ellipsis)) {
        const spreadNodeStartPos = this.state.start;
        const spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types$1.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
        }

        const node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      }

      return elt;
    }

    parseIdentifier(liberal) {
      const node = this.startNode();
      const name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    }

    createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    }

    parseIdentifierName(pos, liberal) {
      let name;
      const {
        start,
        type
      } = this.state;

      if (type === types$1.name) {
        name = this.state.value;
      } else if (type.keyword) {
        name = type.keyword;
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types$1.name;
      } else {
        this.checkReservedWord(name, start, !!type.keyword, false);
      }

      this.next();
      return name;
    }

    checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }

      if (!canBeReservedWord(word)) {
        return;
      }

      if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
          return;
        } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
          return;
        } else {
          this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
        }
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(startLoc, ErrorMessages.ArgumentsInClass);
          return;
        }
      }

      if (checkKeywords && isKeyword$1(word)) {
        this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
        return;
      }

      const reservedTest = !this.state.strict ? isReservedWord$1 : isBinding ? isStrictBindReservedWord$1 : isStrictReservedWord$1;

      if (reservedTest(word, this.inModule)) {
        this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
      }
    }

    isAwaitAllowed() {
      if (this.prodParam.hasAwait) return true;

      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }

      return false;
    }

    parseAwait(startPos, startLoc) {
      const node = this.startNodeAt(startPos, startLoc);
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);

      if (this.eat(types$1.star)) {
        this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }

      return this.finishNode(node, "AwaitExpression");
    }

    isAmbiguousAwait() {
      return this.hasPrecedingLineBreak() || this.match(types$1.plusMin) || this.match(types$1.parenL) || this.match(types$1.bracketL) || this.match(types$1.backQuote) || this.match(types$1.regexp) || this.match(types$1.slash) || this.hasPlugin("v8intrinsic") && this.match(types$1.modulo);
    }

    parseYield() {
      const node = this.startNode();
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
      this.next();
      let delegating = false;
      let argument = null;

      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(types$1.star);

        switch (this.state.type) {
          case types$1.semi:
          case types$1.eof:
          case types$1.braceR:
          case types$1.parenR:
          case types$1.bracketR:
          case types$1.braceBarR:
          case types$1.colon:
          case types$1.comma:
            if (!delegating) break;

          default:
            argument = this.parseMaybeAssign();
        }
      }

      node.delegate = delegating;
      node.argument = argument;
      return this.finishNode(node, "YieldExpression");
    }

    checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
        }
      }
    }

    parseSmartPipelineBody(childExpression, startPos, startLoc) {
      this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);
      return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);
    }

    checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {
      if (this.match(types$1.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      } else if (childExpression.type === "SequenceExpression") {
        this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
      }
    }

    parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {
      const bodyNode = this.startNodeAt(startPos, startLoc);
      const isSimpleReference = this.isSimpleReference(childExpression);

      if (isSimpleReference) {
        bodyNode.callee = childExpression;
      } else {
        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
          this.raise(startPos, ErrorMessages.PipelineTopicUnused);
        }

        bodyNode.expression = childExpression;
      }

      return this.finishNode(bodyNode, isSimpleReference ? "PipelineBareFunction" : "PipelineTopicExpression");
    }

    isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    }

    withTopicPermittingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }

    withTopicForbiddingContext(callback) {
      const outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    }

    withSoloAwaitPermittingContext(callback) {
      const outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    }

    allowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToSet = PARAM_IN & ~flags;

      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }

    disallowInAnd(callback) {
      const flags = this.prodParam.currentFlags();
      const prodParamToClear = PARAM_IN & flags;

      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    }

    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }

    primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }

    topicReferenceWasUsedInCurrentTopicContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }

    parseFSharpPipelineBody(prec) {
      const startPos = this.state.start;
      const startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    }

    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      const node = this.startNode();
      this.next();
      this.eat(types$1.braceL);
      const revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      const program = this.startNode();

      try {
        node.body = this.parseProgram(program, types$1.braceR, "module");
      } finally {
        revertScopes();
      }

      this.eat(types$1.braceR);
      return this.finishNode(node, "ModuleExpression");
    }

  }

  const loopLabel = {
    kind: "loop"
  },
        switchLabel = {
    kind: "switch"
  };
  const FUNC_NO_FLAGS = 0b000,
        FUNC_STATEMENT = 0b001,
        FUNC_HANGING_STATEMENT = 0b010,
        FUNC_NULLABLE_ID = 0b100;
  const loneSurrogate = /[\uD800-\uDFFF]/u;
  const keywordRelationalOperator = /in(?:stanceof)?/y;

  function babel7CompatTokens(tokens) {
    {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];

        if (token.type === types$1.privateName) {
          const {
            loc,
            start,
            value,
            end
          } = token;
          const hashEndPos = start + 1;
          const hashEndLoc = new Position(loc.start.line, loc.start.column + 1);
          tokens.splice(i, 1, new Token({
            type: types$1.hash,
            value: "#",
            start: start,
            end: hashEndPos,
            startLoc: loc.start,
            endLoc: hashEndLoc
          }), new Token({
            type: types$1.name,
            value: value,
            start: hashEndPos,
            end: end,
            startLoc: hashEndLoc,
            endLoc: loc.end
          }));
        }
      }
    }
    return tokens;
  }

  class StatementParser extends ExpressionParser {
    parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = babel7CompatTokens(this.tokens);
      return this.finishNode(file, "File");
    }

    parseProgram(program, end = types$1.eof, sourceType = this.options.sourceType) {
      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (const [name] of Array.from(this.scope.undefinedExports)) {
          const pos = this.scope.undefinedExports.get(name);
          this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
      }

      return this.finishNode(program, "Program");
    }

    stmtToDirective(stmt) {
      const expr = stmt.expression;
      const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      const directive = this.startNodeAt(stmt.start, stmt.loc.start);
      const raw = this.input.slice(expr.start, expr.end);
      const val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    }

    parseInterpreterDirective() {
      if (!this.match(types$1.interpreterDirective)) {
        return null;
      }

      const node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    }

    isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      return this.isLetKeyword(context);
    }

    isLetKeyword(context) {
      const next = this.nextTokenStart();
      const nextCh = this.codePointAtPos(next);

      if (nextCh === 92 || nextCh === 91) {
        return true;
      }

      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart$1(nextCh)) {
        keywordRelationalOperator.lastIndex = next;
        const matched = keywordRelationalOperator.exec(this.input);

        if (matched !== null) {
          const endCh = this.codePointAtPos(next + matched[0].length);

          if (!isIdentifierChar$1(endCh) && endCh !== 92) {
            return false;
          }
        }

        return true;
      }

      return false;
    }

    parseStatement(context, topLevel) {
      if (this.match(types$1.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    }

    parseStatementContent(context, topLevel) {
      let starttype = this.state.type;
      const node = this.startNode();
      let kind;

      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }

      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types$1._debugger:
          return this.parseDebuggerStatement(node);

        case types$1._do:
          return this.parseDoStatement(node);

        case types$1._for:
          return this.parseForStatement(node);

        case types$1._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictFunction);
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, ErrorMessages.SloppyFunction);
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types$1._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types$1._if:
          return this.parseIfStatement(node);

        case types$1._return:
          return this.parseReturnStatement(node);

        case types$1._switch:
          return this.parseSwitchStatement(node);

        case types$1._throw:
          return this.parseThrowStatement(node);

        case types$1._try:
          return this.parseTryStatement(node);

        case types$1._const:
        case types$1._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
          }

          return this.parseVarStatement(node, kind);

        case types$1._while:
          return this.parseWhileStatement(node);

        case types$1._with:
          return this.parseWithStatement(node);

        case types$1.braceL:
          return this.parseBlock();

        case types$1.semi:
          return this.parseEmptyStatement(node);

        case types$1._import:
          {
            const nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
          }

        case types$1._export:
          {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
            }

            this.next();
            let result;

            if (starttype === types$1._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      const maybeName = this.state.value;
      const expr = this.parseExpression();

      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    }

    assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(node.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
      }
    }

    takeDecorators(node) {
      const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    }

    canHaveLeadingDecorator() {
      return this.match(types$1._class);
    }

    parseDecorators(allowExport) {
      const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types$1.at)) {
        const decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types$1._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
      }
    }

    parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      const node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        const startPos = this.state.start;
        const startLoc = this.state.startLoc;
        let expr;

        if (this.eat(types$1.parenL)) {
          expr = this.parseExpression();
          this.expect(types$1.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types$1.dot)) {
            const node = this.startNodeAt(startPos, startLoc);
            node.object = expr;
            node.property = this.parseIdentifier(true);
            node.computed = false;
            expr = this.finishNode(node, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    }

    parseMaybeDecoratorArguments(expr) {
      if (this.eat(types$1.parenL)) {
        const node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    }

    parseBreakContinueStatement(node, keyword) {
      const isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    }

    verifyBreakContinue(node, keyword) {
      const isBreak = keyword === "break";
      let i;

      for (i = 0; i < this.state.labels.length; ++i) {
        const lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
      }
    }

    parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    }

    parseHeaderExpression() {
      this.expect(types$1.parenL);
      const val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    }

    parseDoStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("do"));
      this.state.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseHeaderExpression();
      this.eat(types$1.semi);
      return this.finishNode(node, "DoWhileStatement");
    }

    parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      let awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types$1.parenL);

      if (this.match(types$1.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      const startsWithLet = this.isContextual("let");
      const isLet = startsWithLet && this.isLetKeyword();

      if (this.match(types$1._var) || this.match(types$1._const) || isLet) {
        const init = this.startNode();
        const kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(init, true, kind);
        this.finishNode(init, "VariableDeclaration");

        if ((this.match(types$1._in) || this.isContextual("of")) && init.declarations.length === 1) {
          return this.parseForIn(node, init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, init);
      }

      const startsWithUnescapedName = this.match(types$1.name) && !this.state.containsEsc;
      const refExpressionErrors = new ExpressionErrors();
      const init = this.parseExpression(true, refExpressionErrors);
      const isForOf = this.isContextual("of");

      if (isForOf) {
        if (startsWithLet) {
          this.raise(init.start, ErrorMessages.ForOfLet);
        } else if (awaitAt === -1 && startsWithUnescapedName && init.type === "Identifier" && init.name === "async") {
          this.raise(init.start, ErrorMessages.ForOfAsync);
        }
      }

      if (isForOf || this.match(types$1._in)) {
        this.toAssignable(init, true);
        const description = isForOf ? "for-of statement" : "for-in statement";
        this.checkLVal(init, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    }

    parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    }

    parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    }

    parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, ErrorMessages.IllegalReturn);
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    }

    parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      const cases = node.cases = [];
      this.expect(types$1.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      let cur;

      for (let sawDefault; !this.match(types$1.braceR);) {
        if (this.match(types$1._case) || this.match(types$1._default)) {
          const isCase = this.match(types$1._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types$1.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    }

    parseThrowStatement(node) {
      this.next();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    }

    parseCatchClauseParam() {
      const param = this.parseBindingAtom();
      const simple = param.type === "Identifier";
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, "catch clause", BIND_LEXICAL);
      return param;
    }

    parseTryStatement(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types$1._catch)) {
        const clause = this.startNode();
        this.next();

        if (this.match(types$1.parenL)) {
          this.expect(types$1.parenL);
          clause.param = this.parseCatchClauseParam();
          this.expect(types$1.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, ErrorMessages.NoCatchOrFinally);
      }

      return this.finishNode(node, "TryStatement");
    }

    parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    }

    parseWhileStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("while"));
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    }

    parseWithStatement(node) {
      if (this.state.strict) {
        this.raise(this.state.start, ErrorMessages.StrictWith);
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("with"));
      return this.finishNode(node, "WithStatement");
    }

    parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    }

    parseLabeledStatement(node, maybeName, expr, context) {
      for (const label of this.state.labels) {
        if (label.name === maybeName) {
          this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
        }
      }

      const kind = this.state.type.isLoop ? "loop" : this.match(types$1._switch) ? "switch" : null;

      for (let i = this.state.labels.length - 1; i >= 0; i--) {
        const label = this.state.labels[i];

        if (label.statementStart === node.start) {
          label.statementStart = this.state.start;
          label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    }

    parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    }

    parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
      const node = this.startNode();

      if (allowDirectives) {
        this.state.strictErrors.clear();
      }

      this.expect(types$1.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types$1.braceR, afterBlockParse);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    }

    isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    }

    parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      const body = node.body = [];
      const directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    }

    parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      const oldStrict = this.state.strict;
      let hasStrictModeDirective = false;
      let parsedNonDirective = false;

      while (!this.match(end)) {
        const stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            const directive = this.stmtToDirective(stmt);
            directives.push(directive);

            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }

            continue;
          }

          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }

        body.push(stmt);
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    }

    parseFor(node, init) {
      node.init = init;
      this.semicolon(false);
      node.test = this.match(types$1.semi) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(types$1.parenR) ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    }

    parseForIn(node, init, awaitAt) {
      const isForIn = this.match(types$1._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node.await = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(types$1.parenR);
      node.body = this.withTopicForbiddingContext(() => this.parseStatement("for"));
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    }

    parseVar(node, isFor, kind) {
      const declarations = node.declarations = [];
      const isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        const decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types$1.eq)) {
          decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        } else {
          if (kind === "const" && !(this.match(types$1._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types$1._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) break;
      }

      return node;
    }

    parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== "var");
    }

    parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {
      const isStatement = statement & FUNC_STATEMENT;
      const isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types$1.star) && isHangingStatement) {
        this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
      }

      node.generator = this.eat(types$1.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node, false);
      this.withTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    }

    parseFunctionId(requireId) {
      return requireId || this.match(types$1.name) ? this.parseIdentifier() : null;
    }

    parseFunctionParams(node, allowModifiers) {
      this.expect(types$1.parenL);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(types$1.parenR, 41, false, allowModifiers);
      this.expressionScope.exit();
    }

    registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    }

    parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      const oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    }

    isClassProperty() {
      return this.match(types$1.eq) || this.match(types$1.semi) || this.match(types$1.braceR);
    }

    isClassMethod() {
      return this.match(types$1.parenL);
    }

    isNonstaticConstructor(method) {
      return !method.computed && !method.static && (method.key.name === "constructor" || method.key.value === "constructor");
    }

    parseClassBody(hadSuperClass, oldStrict) {
      this.classScope.enter();
      const state = {
        hadConstructor: false,
        hadSuperClass
      };
      let decorators = [];
      const classBody = this.startNode();
      classBody.body = [];
      this.expect(types$1.braceL);
      this.withTopicForbiddingContext(() => {
        while (!this.match(types$1.braceR)) {
          if (this.eat(types$1.semi)) {
            if (decorators.length > 0) {
              throw this.raise(this.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
            }

            continue;
          }

          if (this.match(types$1.at)) {
            decorators.push(this.parseDecorator());
            continue;
          }

          const member = this.startNode();

          if (decorators.length) {
            member.decorators = decorators;
            this.resetStartLocationFromNode(member, decorators[0]);
            decorators = [];
          }

          this.parseClassMember(classBody, member, state);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            this.raise(member.start, ErrorMessages.DecoratorConstructor);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();

      if (decorators.length) {
        throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      }

      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    }

    parseClassMemberFromModifier(classBody, member) {
      const key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        const method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method.static = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        const prop = member;
        prop.computed = false;
        prop.key = key;
        prop.static = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }

      return false;
    }

    parseClassMember(classBody, member, state) {
      const isStatic = this.isContextual("static");

      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        if (this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    }

    parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      const publicMethod = member;
      const privateMethod = member;
      const publicProp = member;
      const privateProp = member;
      const method = publicMethod;
      const publicMember = publicMethod;
      member.static = isStatic;

      if (this.eat(types$1.star)) {
        method.kind = "method";
        const isPrivateName = this.match(types$1.privateName);
        this.parseClassElementName(method);

        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      const containsEsc = this.state.containsEsc;
      const isPrivate = this.match(types$1.privateName);
      const key = this.parseClassElementName(member);
      const isSimple = key.type === "Identifier";
      const maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        const isConstructor = this.isNonstaticConstructor(publicMethod);
        let allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, ErrorMessages.DuplicateConstructor);
          }

          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(key.start, ErrorMessages.OverrideOnConstructor);
          }

          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
        const isGenerator = this.eat(types$1.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";
        const isPrivate = this.match(types$1.privateName);
        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types$1.star) && this.isLineTerminator())) {
        method.kind = key.name;
        const isPrivate = this.match(types$1.privateName);
        this.parseClassElementName(publicMethod);

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    }

    parseClassElementName(member) {
      const {
        type,
        value,
        start
      } = this.state;

      if ((type === types$1.name || type === types$1.string) && member.static && value === "prototype") {
        this.raise(start, ErrorMessages.StaticPrototype);
      }

      if (type === types$1.privateName && value === "constructor") {
        this.raise(start, ErrorMessages.ConstructorClassPrivateField);
      }

      return this.parsePropertyName(member, true);
    }

    parseClassStaticBlock(classBody, member) {
      var _member$decorators;

      this.expectPlugin("classStaticBlock", member.start);
      this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
      const oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(PARAM);
      const body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, types$1.braceR);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));

      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
      }
    }

    pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
      }

      classBody.body.push(this.parseClassProperty(prop));
    }

    pushClassPrivateProperty(classBody, prop) {
      const node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
    }

    pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    }

    pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      const kind = node.kind === "get" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);
    }

    parsePostMemberNameModifiers(methodOrProp) {}

    parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    }

    parseClassProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    }

    parseInitializer(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(PARAM);
      node.value = this.eat(types$1.eq) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    }

    parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {
      if (this.match(types$1.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, "class name", bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, ErrorMessages.MissingClassName);
        }
      }
    }

    parseClassSuper(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts() : null;
    }

    parseExport(node) {
      const hasDefault = this.maybeParseExportDefaultSpecifier(node);
      const parseAfterDefault = !hasDefault || this.eat(types$1.comma);
      const hasStar = parseAfterDefault && this.eatExportStar(node);
      const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types$1.comma));
      const isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types$1.braceL);
      }

      let hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types$1._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types$1.braceL);
    }

    eatExportStar(node) {
      return this.eat(types$1.star);
    }

    maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    }

    maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    }

    maybeParseExportNamedSpecifiers(node) {
      if (this.match(types$1.braceL)) {
        if (!node.specifiers) node.specifiers = [];
        node.specifiers.push(...this.parseExportSpecifiers());
        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    }

    maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    }

    isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      const next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    }

    parseExportDefaultExpression() {
      const expr = this.startNode();
      const isAsync = this.isAsyncFunction();

      if (this.match(types$1._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types$1._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1._const) || this.match(types$1._var) || this.isLet()) {
        throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
      } else {
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
    }

    parseExportDeclaration(node) {
      return this.parseStatement(null);
    }

    isExportDefaultSpecifier() {
      if (this.match(types$1.name)) {
        const value = this.state.value;

        if (value === "async" && !this.state.containsEsc || value === "let") {
          return false;
        }

        if ((value === "type" || value === "interface") && !this.state.containsEsc) {
          const l = this.lookahead();

          if (l.type === types$1.name && l.value !== "from" || l.type === types$1.braceL) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(types$1._default)) {
        return false;
      }

      const next = this.nextTokenStart();
      const hasFrom = this.isUnparsedContextual(next, "from");

      if (this.input.charCodeAt(next) === 44 || this.match(types$1.name) && hasFrom) {
        return true;
      }

      if (this.match(types$1._default) && hasFrom) {
        const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }

      return false;
    }

    parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        const assertions = this.maybeParseImportAssertions();

        if (assertions) {
          node.assertions = assertions;
        }
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    }

    shouldParseExportDeclaration() {
      if (this.match(types$1.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    }

    checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");

          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;

            const declaration = node.declaration;

            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          for (const specifier of node.specifiers) {
            const {
              exported
            } = specifier;
            const exportedName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportedName);

            if (!isFrom && specifier.local) {
              const {
                local
              } = specifier;

              if (local.type !== "Identifier") {
                this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
              } else {
                this.checkReservedWord(local.name, local.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            const id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (const declaration of node.declaration.declarations) {
              this.checkDeclaration(declaration.id);
            }
          }
        }
      }

      const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }
    }

    checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (const prop of node.properties) {
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (const elem of node.elements) {
          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    }

    checkDuplicateExports(node, name) {
      if (this.exportedIdentifiers.has(name)) {
        this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
      }

      this.exportedIdentifiers.add(name);
    }

    parseExportSpecifiers() {
      const nodes = [];
      let first = true;
      this.expect(types$1.braceL);

      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
          if (this.eat(types$1.braceR)) break;
        }

        const node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    }

    parseModuleExportName() {
      if (this.match(types$1.string)) {
        const result = this.parseStringLiteral(this.state.value);
        const surrogate = result.value.match(loneSurrogate);

        if (surrogate) {
          this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
        }

        return result;
      }

      return this.parseIdentifier(true);
    }

    parseImport(node) {
      node.specifiers = [];

      if (!this.match(types$1.string)) {
        const hasDefault = this.maybeParseDefaultImportSpecifier(node);
        const parseNext = !hasDefault || this.eat(types$1.comma);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      const assertions = this.maybeParseImportAssertions();

      if (assertions) {
        node.assertions = assertions;
      } else {
        const attributes = this.maybeParseModuleAttributes();

        if (attributes) {
          node.attributes = attributes;
        }
      }

      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    }

    parseImportSource() {
      if (!this.match(types$1.string)) this.unexpected();
      return this.parseExprAtom();
    }

    shouldParseDefaultImport(node) {
      return this.match(types$1.name);
    }

    parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    }

    parseAssertEntries() {
      const attrs = [];
      const attrNames = new Set();

      do {
        if (this.match(types$1.braceR)) {
          break;
        }

        const node = this.startNode();
        const keyName = this.state.value;

        if (attrNames.has(keyName)) {
          this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
        }

        attrNames.add(keyName);

        if (this.match(types$1.string)) {
          node.key = this.parseStringLiteral(keyName);
        } else {
          node.key = this.parseIdentifier(true);
        }

        this.expect(types$1.colon);

        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));

      return attrs;
    }

    maybeParseModuleAttributes() {
      if (this.match(types$1._with) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("moduleAttributes");
        this.next();
      } else {
        if (this.hasPlugin("moduleAttributes")) return [];
        return null;
      }

      const attrs = [];
      const attributes = new Set();

      do {
        const node = this.startNode();
        node.key = this.parseIdentifier(true);

        if (node.key.name !== "type") {
          this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
        }

        if (attributes.has(node.key.name)) {
          this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
        }

        attributes.add(node.key.name);
        this.expect(types$1.colon);

        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));

      return attrs;
    }

    maybeParseImportAssertions() {
      if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("importAssertions");
        this.next();
      } else {
        if (this.hasPlugin("importAssertions")) return [];
        return null;
      }

      this.eat(types$1.braceL);
      const attrs = this.parseAssertEntries();
      this.eat(types$1.braceR);
      return attrs;
    }

    maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    }

    maybeParseStarImportSpecifier(node) {
      if (this.match(types$1.star)) {
        const specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    }

    parseNamedImportSpecifiers(node) {
      let first = true;
      this.expect(types$1.braceL);

      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types$1.colon)) {
            throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
          }

          this.expect(types$1.comma);
          if (this.eat(types$1.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    }

    parseImportSpecifier(node) {
      const specifier = this.startNode();
      const importedIsString = this.match(types$1.string);
      specifier.imported = this.parseModuleExportName();

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        const {
          imported
        } = specifier;

        if (importedIsString) {
          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
        }

        this.checkReservedWord(imported.name, specifier.start, true, true);
        specifier.local = imported.__clone();
      }

      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    }

    isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    }

  }

  class Parser$1 extends StatementParser {
    constructor(options, input) {
      options = getOptions(options);
      super(options, input);
      this.options = options;
      this.initializeScopes();
      this.plugins = pluginsMap(this.options.plugins);
      this.filename = options.sourceFilename;
    }

    getScopeHandler() {
      return ScopeHandler;
    }

    parse() {
      this.enterInitialScopes();
      const file = this.startNode();
      const program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    }

  }

  function pluginsMap(plugins) {
    const pluginMap = new Map();

    for (const plugin of plugins) {
      const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }

    return pluginMap;
  }

  function parse$2(input, options) {
    var _options;

    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);

      try {
        options.sourceType = "module";
        const parser = getParser(options, input);
        const ast = parser.parse();

        if (parser.sawUnambiguousESM) {
          return ast;
        }

        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {}
        } else {
          ast.program.sourceType = "script";
        }

        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {}

        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }
  function parseExpression(input, options) {
    const parser = getParser(options, input);

    if (parser.options.strictMode) {
      parser.state.strict = true;
    }

    return parser.getExpression();
  }

  function getParser(options, input) {
    let cls = Parser$1;

    if (options != null && options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }

    return new cls(options, input);
  }

  const parserClassCache = {};

  function getParserClass(pluginsFromOptions) {
    const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));
    const key = pluginList.join("/");
    let cls = parserClassCache[key];

    if (!cls) {
      cls = Parser$1;

      for (const plugin of pluginList) {
        cls = mixinPlugins[plugin](cls);
      }

      parserClassCache[key] = cls;
    }

    return cls;
  }

  var parse_1 = lib$b.parse = parse$2;
  lib$b.parseExpression = parseExpression;
  lib$b.tokTypes = types$1;

  var global$1 = (typeof global$1 !== "undefined" ? global$1 :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform = 'browser';
  var browser$1 = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop$1() {}

  var on = noop$1;
  var addListener = noop$1;
  var once = noop$1;
  var off = noop$1;
  var removeListener = noop$1;
  var removeAllListeners = noop$1;
  var emit = noop$1;

  function binding$1(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var browser$1$1 = {
    nextTick: nextTick,
    title: title,
    browser: browser$1,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding$1,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   * IMPORTANT: all calls of this function must be prefixed with
   * \/\*#\_\_PURE\_\_\*\/
   * So that rollup can tree-shake them if necessary.
   */
  function makeMap(str, expectsLowerCase) {
      const map = Object.create(null);
      const list = str.split(',');
      for (let i = 0; i < list.length; i++) {
          map[list[i]] = true;
      }
      return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
  }

  /**
   * dev only flag -> name mapping
   */
  const PatchFlagNames = {
      [1 /* TEXT */]: `TEXT`,
      [2 /* CLASS */]: `CLASS`,
      [4 /* STYLE */]: `STYLE`,
      [8 /* PROPS */]: `PROPS`,
      [16 /* FULL_PROPS */]: `FULL_PROPS`,
      [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,
      [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,
      [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,
      [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,
      [512 /* NEED_PATCH */]: `NEED_PATCH`,
      [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,
      [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,
      [-1 /* HOISTED */]: `HOISTED`,
      [-2 /* BAIL */]: `BAIL`
  };
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:(.+)/;
  function parseStringStyle(cssText) {
      const ret = {};
      cssText.split(listDelimiterRE).forEach(item => {
          if (item) {
              const tmp = item.split(propertyDelimiterRE);
              tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
          }
      });
      return ret;
  }

  // These tag configs are shared between compiler-dom and runtime-dom, so they
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
  const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
      'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +
      'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
      'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +
      'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
      'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
      'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
      'option,output,progress,select,textarea,details,dialog,menu,' +
      'summary,template,blockquote,iframe,tfoot';
  // https://developer.mozilla.org/en-US/docs/Web/SVG/Element
  const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
      'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
      'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
      'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
      'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
      'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
      'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
      'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
      'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
      'text,textPath,title,tspan,unknown,use,view';
  const VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';
  const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
  const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);
  const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);
  const EMPTY_OBJ = (browser$1$1.env.NODE_ENV !== 'production')
      ? Object.freeze({})
      : {};
  (browser$1$1.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];
  const NOOP = () => { };
  /**
   * Always return false.
   */
  const NO = () => false;
  const extend$1 = Object.assign;
  const isArray$3 = Array.isArray;
  const isString$2 = (val) => typeof val === 'string';
  const isSymbol$1 = (val) => typeof val === 'symbol';
  const cacheStringFunction = (fn) => {
      const cache = Object.create(null);
      return ((str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
      });
  };
  const camelizeRE = /-(\w)/g;
  /**
   * @private
   */
  const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
  });
  const hyphenateRE = /\B([A-Z])/g;
  /**
   * @private
   */
  const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
  /**
   * @private
   */
  const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));

  function defaultOnError(error) {
      throw error;
  }
  function defaultOnWarn(msg) {
      (browser$1$1.env.NODE_ENV !== 'production') && console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = (browser$1$1.env.NODE_ENV !== 'production') || !true
          ? (messages || errorMessages)[code] + (additionalMessage || ``)
          : code;
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
  }
  const errorMessages = {
      // parse errors
      [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
      [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
      [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
      [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
      [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
      [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
      [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
      [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
      [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
      [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
      [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
      [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
      [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
      [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
      [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
      [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
      [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).',
      [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).',
      [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: "Attribute name cannot start with '='.",
      [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: "'<?' is allowed only in XML context.",
      [20 /* UNEXPECTED_NULL_CHARACTER */]: `Unexpected null cahracter.`,
      [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: "Illegal '/' in tags.",
      // Vue-specific parse errors
      [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',
      [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',
      [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',
      [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +
          'Note that dynamic directive argument cannot contain spaces.',
      // transform errors
      [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,
      [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,
      [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,
      [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,
      [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,
      [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,
      [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,
      [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,
      [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,
      [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +
          `When there are multiple named slots, all slots should use <template> ` +
          `syntax to avoid scope ambiguity.`,
      [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,
      [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +
          `default slot. These children will be ignored.`,
      [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,
      [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,
      [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,
      [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
      [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,
      [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,
      // generic errors
      [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
      [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,
      [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
      [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `"scopeId" option is only supported in module mode.`,
      // just to fullfill types
      [49 /* __EXTEND_POINT__ */]: ``
  };

  const FRAGMENT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `Fragment` : ``);
  const TELEPORT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `Teleport` : ``);
  const SUSPENSE = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `Suspense` : ``);
  const KEEP_ALIVE = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `KeepAlive` : ``);
  const BASE_TRANSITION = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `BaseTransition` : ``);
  const OPEN_BLOCK = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `openBlock` : ``);
  const CREATE_BLOCK = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `createBlock` : ``);
  const CREATE_VNODE = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `createVNode` : ``);
  const CREATE_COMMENT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `createCommentVNode` : ``);
  const CREATE_TEXT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `createTextVNode` : ``);
  const CREATE_STATIC = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `createStaticVNode` : ``);
  const RESOLVE_COMPONENT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `resolveComponent` : ``);
  const RESOLVE_DYNAMIC_COMPONENT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `resolveDynamicComponent` : ``);
  const RESOLVE_DIRECTIVE = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `resolveDirective` : ``);
  const RESOLVE_FILTER = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `resolveFilter` : ``);
  const WITH_DIRECTIVES = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `withDirectives` : ``);
  const RENDER_LIST = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `renderList` : ``);
  const RENDER_SLOT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `renderSlot` : ``);
  const CREATE_SLOTS = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `createSlots` : ``);
  const TO_DISPLAY_STRING = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `toDisplayString` : ``);
  const MERGE_PROPS = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `mergeProps` : ``);
  const TO_HANDLERS = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `toHandlers` : ``);
  const CAMELIZE = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `camelize` : ``);
  const CAPITALIZE = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `capitalize` : ``);
  const TO_HANDLER_KEY = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `toHandlerKey` : ``);
  const SET_BLOCK_TRACKING = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `setBlockTracking` : ``);
  const PUSH_SCOPE_ID = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `pushScopeId` : ``);
  const POP_SCOPE_ID = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `popScopeId` : ``);
  const WITH_SCOPE_ID = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `withScopeId` : ``);
  const WITH_CTX = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `withCtx` : ``);
  const UNREF = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `unref` : ``);
  const IS_REF = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `isRef` : ``);
  // Name mapping for runtime helpers that need to be imported from 'vue' in
  // generated code. Make sure these are correctly exported in the runtime!
  // Using `any` here because TS doesn't allow symbols as index type.
  const helperNameMap = {
      [FRAGMENT]: `Fragment`,
      [TELEPORT]: `Teleport`,
      [SUSPENSE]: `Suspense`,
      [KEEP_ALIVE]: `KeepAlive`,
      [BASE_TRANSITION]: `BaseTransition`,
      [OPEN_BLOCK]: `openBlock`,
      [CREATE_BLOCK]: `createBlock`,
      [CREATE_VNODE]: `createVNode`,
      [CREATE_COMMENT]: `createCommentVNode`,
      [CREATE_TEXT]: `createTextVNode`,
      [CREATE_STATIC]: `createStaticVNode`,
      [RESOLVE_COMPONENT]: `resolveComponent`,
      [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
      [RESOLVE_DIRECTIVE]: `resolveDirective`,
      [RESOLVE_FILTER]: `resolveFilter`,
      [WITH_DIRECTIVES]: `withDirectives`,
      [RENDER_LIST]: `renderList`,
      [RENDER_SLOT]: `renderSlot`,
      [CREATE_SLOTS]: `createSlots`,
      [TO_DISPLAY_STRING]: `toDisplayString`,
      [MERGE_PROPS]: `mergeProps`,
      [TO_HANDLERS]: `toHandlers`,
      [CAMELIZE]: `camelize`,
      [CAPITALIZE]: `capitalize`,
      [TO_HANDLER_KEY]: `toHandlerKey`,
      [SET_BLOCK_TRACKING]: `setBlockTracking`,
      [PUSH_SCOPE_ID]: `pushScopeId`,
      [POP_SCOPE_ID]: `popScopeId`,
      [WITH_SCOPE_ID]: `withScopeId`,
      [WITH_CTX]: `withCtx`,
      [UNREF]: `unref`,
      [IS_REF]: `isRef`
  };
  function registerRuntimeHelpers(helpers) {
      Object.getOwnPropertySymbols(helpers).forEach(s => {
          helperNameMap[s] = helpers[s];
      });
  }

  // AST Utilities ---------------------------------------------------------------
  // Some expressions, e.g. sequence and conditional expressions, are never
  // associated with template nodes, so their source locations are just a stub.
  // Container types like CompoundExpression also don't need a real location.
  const locStub = {
      source: '',
      start: { line: 1, column: 1, offset: 0 },
      end: { line: 1, column: 1, offset: 0 }
  };
  function createRoot(children, loc = locStub) {
      return {
          type: 0 /* ROOT */,
          children,
          helpers: [],
          components: [],
          directives: [],
          hoists: [],
          imports: [],
          cached: 0,
          temps: 0,
          codegenNode: undefined,
          loc
      };
  }
  function createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {
      if (context) {
          if (isBlock) {
              context.helper(OPEN_BLOCK);
              context.helper(CREATE_BLOCK);
          }
          else {
              context.helper(CREATE_VNODE);
          }
          if (directives) {
              context.helper(WITH_DIRECTIVES);
          }
      }
      return {
          type: 13 /* VNODE_CALL */,
          tag,
          props,
          children,
          patchFlag,
          dynamicProps,
          directives,
          isBlock,
          disableTracking,
          loc
      };
  }
  function createSimpleExpression(content, isStatic, loc = locStub, constType = 0 /* NOT_CONSTANT */) {
      return {
          type: 4 /* SIMPLE_EXPRESSION */,
          loc,
          content,
          isStatic,
          constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType
      };
  }
  function createCacheExpression(index, value, isVNode = false) {
      return {
          type: 20 /* JS_CACHE_EXPRESSION */,
          index,
          value,
          isVNode,
          loc: locStub
      };
  }

  const isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;
  const isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
  function isCoreComponent(tag) {
      if (isBuiltInType(tag, 'Teleport')) {
          return TELEPORT;
      }
      else if (isBuiltInType(tag, 'Suspense')) {
          return SUSPENSE;
      }
      else if (isBuiltInType(tag, 'KeepAlive')) {
          return KEEP_ALIVE;
      }
      else if (isBuiltInType(tag, 'BaseTransition')) {
          return BASE_TRANSITION;
      }
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(extend$1({}, pos), source, numberOfCharacters);
  }
  // advance by mutation without cloning (for performance reasons), since this
  // gets called a lot in the parser
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++;
              lastNewLinePos = i;
          }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column =
          lastNewLinePos === -1
              ? pos.column + numberOfCharacters
              : numberOfCharacters - lastNewLinePos;
      return pos;
  }
  function isBindKey(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function isSlotOutlet(node) {
      return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
  }

  const deprecationData = {
      ["COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */]: {
          message: `Platform-native elements with "is" prop will no longer be ` +
              `treated as components in Vue 3 unless the "is" value is explicitly ` +
              `prefixed with "vue:".`,
          link: `https://v3.vuejs.org/guide/migration/custom-elements-interop.html`
      },
      ["COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */]: {
          message: key => `.sync modifier for v-bind has been removed. Use v-model with ` +
              `argument instead. \`v-bind:${key}.sync\` should be changed to ` +
              `\`v-model:${key}\`.`,
          link: `https://v3.vuejs.org/guide/migration/v-model.html`
      },
      ["COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */]: {
          message: `.prop modifier for v-bind has been removed and no longer necessary. ` +
              `Vue 3 will automatically set a binding as DOM property when appropriate.`
      },
      ["COMPILER_V_BIND_OBJECT_ORDER" /* COMPILER_V_BIND_OBJECT_ORDER */]: {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript ` +
              `object spread: it will now overwrite an existing non-mergeable attribute ` +
              `that appears before v-bind in the case of conflict. ` +
              `To retain 2.x behavior, move v-bind to make it the first attribute. ` +
              `You can also suppress this warning if the usage is intended.`,
          link: `https://v3.vuejs.org/guide/migration/v-bind.html`
      },
      ["COMPILER_V_ON_NATIVE" /* COMPILER_V_ON_NATIVE */]: {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html`
      },
      ["COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */]: {
          message: `v-if / v-for precedence when used on the same element has changed ` +
              `in Vue 3: v-if now takes higher precedence and will no longer have ` +
              `access to v-for scope variables. It is best to avoid the ambiguity ` +
              `with <template> tags or use a computed property that filters v-for ` +
              `data source.`,
          link: `https://v3.vuejs.org/guide/migration/v-if-v-for.html`
      },
      ["COMPILER_V_FOR_REF" /* COMPILER_V_FOR_REF */]: {
          message: `Ref usage on v-for no longer creates array ref values in Vue 3. ` +
              `Consider using function refs or refactor to avoid ref usage altogether.`,
          link: `https://v3.vuejs.org/guide/migration/array-refs.html`
      },
      ["COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */]: {
          message: `<template> with no special directives will render as a native template ` +
              `element instead of its inner content in Vue 3.`
      },
      ["COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */]: {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3.vuejs.org/guide/migration/inline-template-attribute.html`
      },
      ["COMPILER_FILTER" /* COMPILER_FILTERS */]: {
          message: `filters have been removed in Vue 3. ` +
              `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
              `Use method calls or computed properties instead.`,
          link: `https://v3.vuejs.org/guide/migration/filters.html`
      }
  };
  function getCompatValue(key, context) {
      const config = context.options
          ? context.options.compatConfig
          : context.compatConfig;
      const value = config && config[key];
      if (key === 'MODE') {
          return value || 3; // compiler defaults to v3 behavior
      }
      else {
          return value;
      }
  }
  function isCompatEnabled(key, context) {
      const mode = getCompatValue('MODE', context);
      const value = getCompatValue(key, context);
      // in v3 mode, only enable if explicitly set to true
      // otherwise enable for any non-false value
      return mode === 3 ? value === true : value !== false;
  }
  function checkCompatEnabled(key, context, loc, ...args) {
      const enabled = isCompatEnabled(key, context);
      if ((browser$1$1.env.NODE_ENV !== 'production') && enabled) {
          warnDeprecation(key, context, loc, ...args);
      }
      return enabled;
  }
  function warnDeprecation(key, context, loc, ...args) {
      const val = getCompatValue(key, context);
      if (val === 'suppress-warning') {
          return;
      }
      const { message, link } = deprecationData[key];
      const msg = `(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`;
      const err = new SyntaxError(msg);
      err.code = key;
      if (loc)
          err.loc = loc;
      context.onWarn(err);
  }

  // The default decoder only provides escapes for characters reserved as part of
  // the template syntax, and is only used if the custom renderer did not provide
  // a platform-specific decoder.
  const decodeRE = /&(gt|lt|amp|apos|quot);/g;
  const decodeMap = {
      gt: '>',
      lt: '<',
      amp: '&',
      apos: "'",
      quot: '"'
  };
  const defaultParserOptions = {
      delimiters: [`{{`, `}}`],
      getNamespace: () => 0 /* HTML */,
      getTextMode: () => 0 /* DATA */,
      isVoidTag: NO,
      isPreTag: NO,
      isCustomElement: NO,
      decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
      onError: defaultOnError,
      onWarn: defaultOnWarn,
      comments: false
  };
  function baseParse(content, options = {}) {
      const context = createParserContext(content, options);
      const start = getCursor(context);
      return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));
  }
  function createParserContext(content, rawOptions) {
      const options = extend$1({}, defaultParserOptions);
      for (const key in rawOptions) {
          // @ts-ignore
          options[key] = rawOptions[key] || defaultParserOptions[key];
      }
      return {
          options,
          column: 1,
          line: 1,
          offset: 0,
          originalSource: content,
          source: content,
          inPre: false,
          inVPre: false,
          onWarn: options.onWarn
      };
  }
  function parseChildren(context, mode, ancestors) {
      const parent = last(ancestors);
      const ns = parent ? parent.ns : 0 /* HTML */;
      const nodes = [];
      while (!isEnd(context, mode, ancestors)) {
          const s = context.source;
          let node = undefined;
          if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {
              if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {
                  // '{{'
                  node = parseInterpolation(context, mode);
              }
              else if (mode === 0 /* DATA */ && s[0] === '<') {
                  // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
                  if (s.length === 1) {
                      emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);
                  }
                  else if (s[1] === '!') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
                      if (startsWith(s, '<!--')) {
                          node = parseComment(context);
                      }
                      else if (startsWith(s, '<!DOCTYPE')) {
                          // Ignore DOCTYPE by a limitation.
                          node = parseBogusComment(context);
                      }
                      else if (startsWith(s, '<![CDATA[')) {
                          if (ns !== 0 /* HTML */) {
                              node = parseCDATA(context, ancestors);
                          }
                          else {
                              emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);
                              node = parseBogusComment(context);
                          }
                      }
                      else {
                          emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (s[1] === '/') {
                      // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
                      if (s.length === 2) {
                          emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);
                      }
                      else if (s[2] === '>') {
                          emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);
                          advanceBy(context, 3);
                          continue;
                      }
                      else if (/[a-z]/i.test(s[2])) {
                          emitError(context, 23 /* X_INVALID_END_TAG */);
                          parseTag(context, 1 /* End */, parent);
                          continue;
                      }
                      else {
                          emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);
                          node = parseBogusComment(context);
                      }
                  }
                  else if (/[a-z]/i.test(s[1])) {
                      node = parseElement(context, ancestors);
                      // 2.x <template> with no directive compat
                      if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context) &&
                          node &&
                          node.tag === 'template' &&
                          !node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
                              isSpecialTemplateDirective(p.name))) {
                          (browser$1$1.env.NODE_ENV !== 'production') &&
                              warnDeprecation("COMPILER_NATIVE_TEMPLATE" /* COMPILER_NATIVE_TEMPLATE */, context, node.loc);
                          node = node.children;
                      }
                  }
                  else if (s[1] === '?') {
                      emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);
                      node = parseBogusComment(context);
                  }
                  else {
                      emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);
                  }
              }
          }
          if (!node) {
              node = parseText(context, mode);
          }
          if (isArray$3(node)) {
              for (let i = 0; i < node.length; i++) {
                  pushNode(nodes, node[i]);
              }
          }
          else {
              pushNode(nodes, node);
          }
      }
      // Whitespace handling strategy like v2
      let removedWhitespace = false;
      if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {
          const preserve = context.options.whitespace === 'preserve';
          for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (!context.inPre && node.type === 2 /* TEXT */) {
                  if (!/[^\t\r\n\f ]/.test(node.content)) {
                      const prev = nodes[i - 1];
                      const next = nodes[i + 1];
                      // Remove if:
                      // - the whitespace is the first or last node, or:
                      // - (condense mode) the whitespace is adjacent to a comment, or:
                      // - (condense mode) the whitespace is between two elements AND contains newline
                      if (!prev ||
                          !next ||
                          (!preserve &&
                              (prev.type === 3 /* COMMENT */ ||
                                  next.type === 3 /* COMMENT */ ||
                                  (prev.type === 1 /* ELEMENT */ &&
                                      next.type === 1 /* ELEMENT */ &&
                                      /[\r\n]/.test(node.content))))) {
                          removedWhitespace = true;
                          nodes[i] = null;
                      }
                      else {
                          // Otherwise, the whitespace is condensed into a single space
                          node.content = ' ';
                      }
                  }
                  else if (!preserve) {
                      // in condense mode, consecutive whitespaces in text are condensed
                      // down to a single space.
                      node.content = node.content.replace(/[\t\r\n\f ]+/g, ' ');
                  }
              }
              // also remove comment nodes in prod by default
              if (!(browser$1$1.env.NODE_ENV !== 'production') &&
                  node.type === 3 /* COMMENT */ &&
                  !context.options.comments) {
                  removedWhitespace = true;
                  nodes[i] = null;
              }
          }
          if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
              // remove leading newline per html spec
              // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
              const first = nodes[0];
              if (first && first.type === 2 /* TEXT */) {
                  first.content = first.content.replace(/^\r?\n/, '');
              }
          }
      }
      return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
      if (node.type === 2 /* TEXT */) {
          const prev = last(nodes);
          // Merge if both this and the previous node are text and those are
          // consecutive. This happens for cases like "a < b".
          if (prev &&
              prev.type === 2 /* TEXT */ &&
              prev.loc.end.offset === node.loc.start.offset) {
              prev.content += node.content;
              prev.loc.end = node.loc.end;
              prev.loc.source += node.loc.source;
              return;
          }
      }
      nodes.push(node);
  }
  function parseCDATA(context, ancestors) {
      advanceBy(context, 9);
      const nodes = parseChildren(context, 3 /* CDATA */, ancestors);
      if (context.source.length === 0) {
          emitError(context, 6 /* EOF_IN_CDATA */);
      }
      else {
          advanceBy(context, 3);
      }
      return nodes;
  }
  function parseComment(context) {
      const start = getCursor(context);
      let content;
      // Regular comment.
      const match = /--(\!)?>/.exec(context.source);
      if (!match) {
          content = context.source.slice(4);
          advanceBy(context, context.source.length);
          emitError(context, 7 /* EOF_IN_COMMENT */);
      }
      else {
          if (match.index <= 3) {
              emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);
          }
          if (match[1]) {
              emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);
          }
          content = context.source.slice(4, match.index);
          // Advancing with reporting nested comments.
          const s = context.source.slice(0, match.index);
          let prevIndex = 1, nestedIndex = 0;
          while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {
              advanceBy(context, nestedIndex - prevIndex + 1);
              if (nestedIndex + 4 < s.length) {
                  emitError(context, 16 /* NESTED_COMMENT */);
              }
              prevIndex = nestedIndex + 1;
          }
          advanceBy(context, match.index + match[0].length - prevIndex + 1);
      }
      return {
          type: 3 /* COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseBogusComment(context) {
      const start = getCursor(context);
      const contentStart = context.source[1] === '?' ? 1 : 2;
      let content;
      const closeIndex = context.source.indexOf('>');
      if (closeIndex === -1) {
          content = context.source.slice(contentStart);
          advanceBy(context, context.source.length);
      }
      else {
          content = context.source.slice(contentStart, closeIndex);
          advanceBy(context, closeIndex + 1);
      }
      return {
          type: 3 /* COMMENT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseElement(context, ancestors) {
      // Start tag.
      const wasInPre = context.inPre;
      const wasInVPre = context.inVPre;
      const parent = last(ancestors);
      const element = parseTag(context, 0 /* Start */, parent);
      const isPreBoundary = context.inPre && !wasInPre;
      const isVPreBoundary = context.inVPre && !wasInVPre;
      if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
          // #4030 self-closing <pre> tag
          if (context.options.isPreTag(element.tag)) {
              context.inPre = false;
          }
          return element;
      }
      // Children.
      ancestors.push(element);
      const mode = context.options.getTextMode(element, parent);
      const children = parseChildren(context, mode, ancestors);
      ancestors.pop();
      // 2.x inline-template compat
      {
          const inlineTemplateProp = element.props.find(p => p.type === 6 /* ATTRIBUTE */ && p.name === 'inline-template');
          if (inlineTemplateProp &&
              checkCompatEnabled("COMPILER_INLINE_TEMPLATE" /* COMPILER_INLINE_TEMPLATE */, context, inlineTemplateProp.loc)) {
              const loc = getSelection(context, element.loc.end);
              inlineTemplateProp.value = {
                  type: 2 /* TEXT */,
                  content: loc.source,
                  loc
              };
          }
      }
      element.children = children;
      // End tag.
      if (startsWithEndTagOpen(context.source, element.tag)) {
          parseTag(context, 1 /* End */, parent);
      }
      else {
          emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);
          if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {
              const first = children[0];
              if (first && startsWith(first.loc.source, '<!--')) {
                  emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);
              }
          }
      }
      element.loc = getSelection(context, element.loc.start);
      if (isPreBoundary) {
          context.inPre = false;
      }
      if (isVPreBoundary) {
          context.inVPre = false;
      }
      return element;
  }
  const isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);
  function parseTag(context, type, parent) {
      // Tag open.
      const start = getCursor(context);
      const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      const tag = match[1];
      const ns = context.options.getNamespace(tag, parent);
      advanceBy(context, match[0].length);
      advanceSpaces(context);
      // save current state in case we need to re-parse attributes with v-pre
      const cursor = getCursor(context);
      const currentSource = context.source;
      // check <pre> tag
      const isPreTag = context.options.isPreTag(tag);
      if (isPreTag) {
          context.inPre = true;
      }
      // Attributes.
      let props = parseAttributes(context, type);
      // check v-pre
      if (type === 0 /* Start */ &&
          !context.inVPre &&
          props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {
          context.inVPre = true;
          // reset context
          extend$1(context, cursor);
          context.source = currentSource;
          // re-parse attrs and filter out v-pre itself
          props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');
      }
      // Tag close.
      let isSelfClosing = false;
      if (context.source.length === 0) {
          emitError(context, 9 /* EOF_IN_TAG */);
      }
      else {
          isSelfClosing = startsWith(context.source, '/>');
          if (type === 1 /* End */ && isSelfClosing) {
              emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);
          }
          advanceBy(context, isSelfClosing ? 2 : 1);
      }
      if (type === 1 /* End */) {
          return;
      }
      // 2.x deprecation checks
      if ((browser$1$1.env.NODE_ENV !== 'production') &&
          isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context)) {
          let hasIf = false;
          let hasFor = false;
          for (let i = 0; i < props.length; i++) {
              const p = props[i];
              if (p.type === 7 /* DIRECTIVE */) {
                  if (p.name === 'if') {
                      hasIf = true;
                  }
                  else if (p.name === 'for') {
                      hasFor = true;
                  }
              }
              if (hasIf && hasFor) {
                  warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE" /* COMPILER_V_IF_V_FOR_PRECEDENCE */, context, getSelection(context, start));
              }
          }
      }
      let tagType = 0 /* ELEMENT */;
      if (!context.inVPre) {
          if (tag === 'slot') {
              tagType = 2 /* SLOT */;
          }
          else if (tag === 'template') {
              if (props.some(p => p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name))) {
                  tagType = 3 /* TEMPLATE */;
              }
          }
          else if (isComponent(tag, props, context)) {
              tagType = 1 /* COMPONENT */;
          }
      }
      return {
          type: 1 /* ELEMENT */,
          ns,
          tag,
          tagType,
          props,
          isSelfClosing,
          children: [],
          loc: getSelection(context, start),
          codegenNode: undefined // to be created during transform phase
      };
  }
  function isComponent(tag, props, context) {
      const options = context.options;
      if (options.isCustomElement(tag)) {
          return false;
      }
      if (tag === 'component' ||
          /^[A-Z]/.test(tag) ||
          isCoreComponent(tag) ||
          (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||
          (options.isNativeTag && !options.isNativeTag(tag))) {
          return true;
      }
      // at this point the tag should be a native tag, but check for potential "is"
      // casting
      for (let i = 0; i < props.length; i++) {
          const p = props[i];
          if (p.type === 6 /* ATTRIBUTE */) {
              if (p.name === 'is' && p.value) {
                  if (p.value.content.startsWith('vue:')) {
                      return true;
                  }
                  else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                      return true;
                  }
              }
          }
          else {
              // directive
              // v-is (TODO Deprecate)
              if (p.name === 'is') {
                  return true;
              }
              else if (
              // :is on plain element - only treat as component in compat mode
              p.name === 'bind' &&
                  isBindKey(p.arg, 'is') &&
                  true &&
                  checkCompatEnabled("COMPILER_IS_ON_ELEMENT" /* COMPILER_IS_ON_ELEMENT */, context, p.loc)) {
                  return true;
              }
          }
      }
  }
  function parseAttributes(context, type) {
      const props = [];
      const attributeNames = new Set();
      while (context.source.length > 0 &&
          !startsWith(context.source, '>') &&
          !startsWith(context.source, '/>')) {
          if (startsWith(context.source, '/')) {
              emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);
              advanceBy(context, 1);
              advanceSpaces(context);
              continue;
          }
          if (type === 1 /* End */) {
              emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);
          }
          const attr = parseAttribute(context, attributeNames);
          if (type === 0 /* Start */) {
              props.push(attr);
          }
          if (/^[^\t\r\n\f />]/.test(context.source)) {
              emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);
          }
          advanceSpaces(context);
      }
      return props;
  }
  function parseAttribute(context, nameSet) {
      // Name.
      const start = getCursor(context);
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
      const name = match[0];
      if (nameSet.has(name)) {
          emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);
      }
      nameSet.add(name);
      if (name[0] === '=') {
          emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);
      }
      {
          const pattern = /["'<]/g;
          let m;
          while ((m = pattern.exec(name))) {
              emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);
          }
      }
      advanceBy(context, name.length);
      // Value
      let value = undefined;
      if (/^[\t\r\n\f ]*=/.test(context.source)) {
          advanceSpaces(context);
          advanceBy(context, 1);
          advanceSpaces(context);
          value = parseAttributeValue(context);
          if (!value) {
              emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);
          }
      }
      const loc = getSelection(context, start);
      if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {
          const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
          let dirName = match[1] ||
              (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');
          let arg;
          if (match[2]) {
              const isSlot = dirName === 'slot';
              const startOffset = name.lastIndexOf(match[2]);
              const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));
              let content = match[2];
              let isStatic = true;
              if (content.startsWith('[')) {
                  isStatic = false;
                  if (!content.endsWith(']')) {
                      emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);
                  }
                  content = content.substr(1, content.length - 2);
              }
              else if (isSlot) {
                  // #1241 special case for v-slot: vuetify relies extensively on slot
                  // names containing dots. v-slot doesn't have any modifiers and Vue 2.x
                  // supports such usage so we are keeping it consistent with 2.x.
                  content += match[3] || '';
              }
              arg = {
                  type: 4 /* SIMPLE_EXPRESSION */,
                  content,
                  isStatic,
                  constType: isStatic
                      ? 3 /* CAN_STRINGIFY */
                      : 0 /* NOT_CONSTANT */,
                  loc
              };
          }
          if (value && value.isQuoted) {
              const valueLoc = value.loc;
              valueLoc.start.offset++;
              valueLoc.start.column++;
              valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);
              valueLoc.source = valueLoc.source.slice(1, -1);
          }
          const modifiers = match[3] ? match[3].substr(1).split('.') : [];
          // 2.x compat v-bind:foo.sync -> v-model:foo
          if (dirName === 'bind' && arg) {
              if (modifiers.includes('sync') &&
                  checkCompatEnabled("COMPILER_V_BIND_SYNC" /* COMPILER_V_BIND_SYNC */, context, loc, arg.loc.source)) {
                  dirName = 'model';
                  modifiers.splice(modifiers.indexOf('sync'), 1);
              }
              if ((browser$1$1.env.NODE_ENV !== 'production') && modifiers.includes('prop')) {
                  checkCompatEnabled("COMPILER_V_BIND_PROP" /* COMPILER_V_BIND_PROP */, context, loc);
              }
          }
          return {
              type: 7 /* DIRECTIVE */,
              name: dirName,
              exp: value && {
                  type: 4 /* SIMPLE_EXPRESSION */,
                  content: value.content,
                  isStatic: false,
                  // Treat as non-constant by default. This can be potentially set to
                  // other values by `transformExpression` to make it eligible for hoisting.
                  constType: 0 /* NOT_CONSTANT */,
                  loc: value.loc
              },
              arg,
              modifiers,
              loc
          };
      }
      return {
          type: 6 /* ATTRIBUTE */,
          name,
          value: value && {
              type: 2 /* TEXT */,
              content: value.content,
              loc: value.loc
          },
          loc
      };
  }
  function parseAttributeValue(context) {
      const start = getCursor(context);
      let content;
      const quote = context.source[0];
      const isQuoted = quote === `"` || quote === `'`;
      if (isQuoted) {
          // Quoted value.
          advanceBy(context, 1);
          const endIndex = context.source.indexOf(quote);
          if (endIndex === -1) {
              content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
          }
          else {
              content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
              advanceBy(context, 1);
          }
      }
      else {
          // Unquoted
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          if (!match) {
              return undefined;
          }
          const unexpectedChars = /["'<=`]/g;
          let m;
          while ((m = unexpectedChars.exec(match[0]))) {
              emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
          }
          content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
      }
      return { content, isQuoted, loc: getSelection(context, start) };
  }
  function parseInterpolation(context, mode) {
      const [open, close] = context.options.delimiters;
      const closeIndex = context.source.indexOf(close, open.length);
      if (closeIndex === -1) {
          emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
          return undefined;
      }
      const start = getCursor(context);
      advanceBy(context, open.length);
      const innerStart = getCursor(context);
      const innerEnd = getCursor(context);
      const rawContentLength = closeIndex - open.length;
      const rawContent = context.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context, rawContentLength, mode);
      const content = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content);
      if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context, close.length);
      return {
          type: 5 /* INTERPOLATION */,
          content: {
              type: 4 /* SIMPLE_EXPRESSION */,
              isStatic: false,
              // Set `isConstant` to false by default and will decide in transformExpression
              constType: 0 /* NOT_CONSTANT */,
              content,
              loc: getSelection(context, innerStart, innerEnd)
          },
          loc: getSelection(context, start)
      };
  }
  function parseText(context, mode) {
      const endTokens = ['<', context.options.delimiters[0]];
      if (mode === 3 /* CDATA */) {
          endTokens.push(']]>');
      }
      let endIndex = context.source.length;
      for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1);
          if (index !== -1 && endIndex > index) {
              endIndex = index;
          }
      }
      const start = getCursor(context);
      const content = parseTextData(context, endIndex, mode);
      return {
          type: 2 /* TEXT */,
          content,
          loc: getSelection(context, start)
      };
  }
  /**
   * Get text data with a given length from the current location.
   * This translates HTML entities in the text data.
   */
  function parseTextData(context, length, mode) {
      const rawText = context.source.slice(0, length);
      advanceBy(context, length);
      if (mode === 2 /* RAWTEXT */ ||
          mode === 3 /* CDATA */ ||
          rawText.indexOf('&') === -1) {
          return rawText;
      }
      else {
          // DATA or RCDATA containing "&"". Entity decoding required.
          return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
      }
  }
  function getCursor(context) {
      const { column, line, offset } = context;
      return { column, line, offset };
  }
  function getSelection(context, start, end) {
      end = end || getCursor(context);
      return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
      };
  }
  function last(xs) {
      return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
      return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
      const { source } = context;
      advancePositionWithMutation(context, source, numberOfCharacters);
      context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      if (match) {
          advanceBy(context, match[0].length);
      }
  }
  function getNewPosition(context, start, numberOfCharacters) {
      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context, code, offset, loc = getCursor(context)) {
      if (offset) {
          loc.offset += offset;
          loc.column += offset;
      }
      context.options.onError(createCompilerError(code, {
          start: loc,
          end: loc,
          source: ''
      }));
  }
  function isEnd(context, mode, ancestors) {
      const s = context.source;
      switch (mode) {
          case 0 /* DATA */:
              if (startsWith(s, '</')) {
                  // TODO: probably bad performance
                  for (let i = ancestors.length - 1; i >= 0; --i) {
                      if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                          return true;
                      }
                  }
              }
              break;
          case 1 /* RCDATA */:
          case 2 /* RAWTEXT */: {
              const parent = last(ancestors);
              if (parent && startsWithEndTagOpen(s, parent.tag)) {
                  return true;
              }
              break;
          }
          case 3 /* CDATA */:
              if (startsWith(s, ']]>')) {
                  return true;
              }
              break;
      }
      return !s;
  }
  function startsWithEndTagOpen(source, tag) {
      return (startsWith(source, '</') &&
          source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
          /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
  }

  function hoistStatic(root, context) {
      walk(root, context, 
      // Root node is unfortunately non-hoistable due to potential parent
      // fallthrough attributes.
      isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
      const { children } = root;
      return (children.length === 1 &&
          child.type === 1 /* ELEMENT */ &&
          !isSlotOutlet(child));
  }
  function walk(node, context, doNotHoistNode = false) {
      let hasHoistedNode = false;
      // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces
      // static bindings with expressions. These expressions are guaranteed to be
      // constant so they are still eligible for hoisting, but they are only
      // available at runtime and therefore cannot be evaluated ahead of time.
      // This is only a concern for pre-stringification (via transformHoist by
      // @vue/compiler-dom), but doing it here allows us to perform only one full
      // walk of the AST and allow `stringifyStatic` to stop walking as soon as its
      // stringficiation threshold is met.
      let canStringify = true;
      const { children } = node;
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          // only plain elements & text calls are eligible for hoisting.
          if (child.type === 1 /* ELEMENT */ &&
              child.tagType === 0 /* ELEMENT */) {
              const constantType = doNotHoistNode
                  ? 0 /* NOT_CONSTANT */
                  : getConstantType(child, context);
              if (constantType > 0 /* NOT_CONSTANT */) {
                  if (constantType < 3 /* CAN_STRINGIFY */) {
                      canStringify = false;
                  }
                  if (constantType >= 2 /* CAN_HOIST */) {
                      child.codegenNode.patchFlag =
                          -1 /* HOISTED */ + ((browser$1$1.env.NODE_ENV !== 'production') ? ` /* HOISTED */` : ``);
                      child.codegenNode = context.hoist(child.codegenNode);
                      hasHoistedNode = true;
                      continue;
                  }
              }
              else {
                  // node may contain dynamic children, but its props may be eligible for
                  // hoisting.
                  const codegenNode = child.codegenNode;
                  if (codegenNode.type === 13 /* VNODE_CALL */) {
                      const flag = getPatchFlag(codegenNode);
                      if ((!flag ||
                          flag === 512 /* NEED_PATCH */ ||
                          flag === 1 /* TEXT */) &&
                          getGeneratedPropsConstantType(child, context) >=
                              2 /* CAN_HOIST */) {
                          const props = getNodeProps(child);
                          if (props) {
                              codegenNode.props = context.hoist(props);
                          }
                      }
                  }
              }
          }
          else if (child.type === 12 /* TEXT_CALL */) {
              const contentType = getConstantType(child.content, context);
              if (contentType > 0) {
                  if (contentType < 3 /* CAN_STRINGIFY */) {
                      canStringify = false;
                  }
                  if (contentType >= 2 /* CAN_HOIST */) {
                      child.codegenNode = context.hoist(child.codegenNode);
                      hasHoistedNode = true;
                  }
              }
          }
          // walk further
          if (child.type === 1 /* ELEMENT */) {
              const isComponent = child.tagType === 1 /* COMPONENT */;
              if (isComponent) {
                  context.scopes.vSlot++;
              }
              walk(child, context);
              if (isComponent) {
                  context.scopes.vSlot--;
              }
          }
          else if (child.type === 11 /* FOR */) {
              // Do not hoist v-for single child because it has to be a block
              walk(child, context, child.children.length === 1);
          }
          else if (child.type === 9 /* IF */) {
              for (let i = 0; i < child.branches.length; i++) {
                  // Do not hoist v-if single child because it has to be a block
                  walk(child.branches[i], context, child.branches[i].children.length === 1);
              }
          }
      }
      if (canStringify && hasHoistedNode && context.transformHoist) {
          context.transformHoist(children, context, node);
      }
  }
  function getConstantType(node, context) {
      const { constantCache } = context;
      switch (node.type) {
          case 1 /* ELEMENT */:
              if (node.tagType !== 0 /* ELEMENT */) {
                  return 0 /* NOT_CONSTANT */;
              }
              const cached = constantCache.get(node);
              if (cached !== undefined) {
                  return cached;
              }
              const codegenNode = node.codegenNode;
              if (codegenNode.type !== 13 /* VNODE_CALL */) {
                  return 0 /* NOT_CONSTANT */;
              }
              const flag = getPatchFlag(codegenNode);
              if (!flag) {
                  let returnType = 3 /* CAN_STRINGIFY */;
                  // Element itself has no patch flag. However we still need to check:
                  // 1. Even for a node with no patch flag, it is possible for it to contain
                  // non-hoistable expressions that refers to scope variables, e.g. compiler
                  // injected keys or cached event handlers. Therefore we need to always
                  // check the codegenNode's props to be sure.
                  const generatedPropsType = getGeneratedPropsConstantType(node, context);
                  if (generatedPropsType === 0 /* NOT_CONSTANT */) {
                      constantCache.set(node, 0 /* NOT_CONSTANT */);
                      return 0 /* NOT_CONSTANT */;
                  }
                  if (generatedPropsType < returnType) {
                      returnType = generatedPropsType;
                  }
                  // 2. its children.
                  for (let i = 0; i < node.children.length; i++) {
                      const childType = getConstantType(node.children[i], context);
                      if (childType === 0 /* NOT_CONSTANT */) {
                          constantCache.set(node, 0 /* NOT_CONSTANT */);
                          return 0 /* NOT_CONSTANT */;
                      }
                      if (childType < returnType) {
                          returnType = childType;
                      }
                  }
                  // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
                  // type, check if any of the props can cause the type to be lowered
                  // we can skip can_patch because it's guaranteed by the absence of a
                  // patchFlag.
                  if (returnType > 1 /* CAN_SKIP_PATCH */) {
                      for (let i = 0; i < node.props.length; i++) {
                          const p = node.props[i];
                          if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {
                              const expType = getConstantType(p.exp, context);
                              if (expType === 0 /* NOT_CONSTANT */) {
                                  constantCache.set(node, 0 /* NOT_CONSTANT */);
                                  return 0 /* NOT_CONSTANT */;
                              }
                              if (expType < returnType) {
                                  returnType = expType;
                              }
                          }
                      }
                  }
                  // only svg/foreignObject could be block here, however if they are
                  // static then they don't need to be blocks since there will be no
                  // nested updates.
                  if (codegenNode.isBlock) {
                      context.removeHelper(OPEN_BLOCK);
                      context.removeHelper(CREATE_BLOCK);
                      codegenNode.isBlock = false;
                      context.helper(CREATE_VNODE);
                  }
                  constantCache.set(node, returnType);
                  return returnType;
              }
              else {
                  constantCache.set(node, 0 /* NOT_CONSTANT */);
                  return 0 /* NOT_CONSTANT */;
              }
          case 2 /* TEXT */:
          case 3 /* COMMENT */:
              return 3 /* CAN_STRINGIFY */;
          case 9 /* IF */:
          case 11 /* FOR */:
          case 10 /* IF_BRANCH */:
              return 0 /* NOT_CONSTANT */;
          case 5 /* INTERPOLATION */:
          case 12 /* TEXT_CALL */:
              return getConstantType(node.content, context);
          case 4 /* SIMPLE_EXPRESSION */:
              return node.constType;
          case 8 /* COMPOUND_EXPRESSION */:
              let returnType = 3 /* CAN_STRINGIFY */;
              for (let i = 0; i < node.children.length; i++) {
                  const child = node.children[i];
                  if (isString$2(child) || isSymbol$1(child)) {
                      continue;
                  }
                  const childType = getConstantType(child, context);
                  if (childType === 0 /* NOT_CONSTANT */) {
                      return 0 /* NOT_CONSTANT */;
                  }
                  else if (childType < returnType) {
                      returnType = childType;
                  }
              }
              return returnType;
          default:
              if ((browser$1$1.env.NODE_ENV !== 'production')) ;
              return 0 /* NOT_CONSTANT */;
      }
  }
  function getGeneratedPropsConstantType(node, context) {
      let returnType = 3 /* CAN_STRINGIFY */;
      const props = getNodeProps(node);
      if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {
          const { properties } = props;
          for (let i = 0; i < properties.length; i++) {
              const { key, value } = properties[i];
              const keyType = getConstantType(key, context);
              if (keyType === 0 /* NOT_CONSTANT */) {
                  return keyType;
              }
              if (keyType < returnType) {
                  returnType = keyType;
              }
              if (value.type !== 4 /* SIMPLE_EXPRESSION */) {
                  return 0 /* NOT_CONSTANT */;
              }
              const valueType = getConstantType(value, context);
              if (valueType === 0 /* NOT_CONSTANT */) {
                  return valueType;
              }
              if (valueType < returnType) {
                  returnType = valueType;
              }
          }
      }
      return returnType;
  }
  function getNodeProps(node) {
      const codegenNode = node.codegenNode;
      if (codegenNode.type === 13 /* VNODE_CALL */) {
          return codegenNode.props;
      }
  }
  function getPatchFlag(node) {
      const flag = node.patchFlag;
      return flag ? parseInt(flag, 10) : undefined;
  }

  function createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
      const nameMatch = filename.replace(/\?.*$/, '').match(/([^/\\]+)\.\w+$/);
      const context = {
          // options
          selfName: nameMatch && capitalize(camelize(nameMatch[1])),
          prefixIdentifiers,
          hoistStatic,
          cacheHandlers,
          nodeTransforms,
          directiveTransforms,
          transformHoist,
          isBuiltInComponent,
          isCustomElement,
          expressionPlugins,
          scopeId,
          slotted,
          ssr,
          ssrCssVars,
          bindingMetadata,
          inline,
          isTS,
          onError,
          onWarn,
          compatConfig,
          // state
          root,
          helpers: new Map(),
          components: new Set(),
          directives: new Set(),
          hoists: [],
          imports: [],
          constantCache: new Map(),
          temps: 0,
          cached: 0,
          identifiers: Object.create(null),
          scopes: {
              vFor: 0,
              vSlot: 0,
              vPre: 0,
              vOnce: 0
          },
          parent: null,
          currentNode: root,
          childIndex: 0,
          // methods
          helper(name) {
              const count = context.helpers.get(name) || 0;
              context.helpers.set(name, count + 1);
              return name;
          },
          removeHelper(name) {
              const count = context.helpers.get(name);
              if (count) {
                  const currentCount = count - 1;
                  if (!currentCount) {
                      context.helpers.delete(name);
                  }
                  else {
                      context.helpers.set(name, currentCount);
                  }
              }
          },
          helperString(name) {
              return `_${helperNameMap[context.helper(name)]}`;
          },
          replaceNode(node) {
              /* istanbul ignore if */
              if ((browser$1$1.env.NODE_ENV !== 'production')) {
                  if (!context.currentNode) {
                      throw new Error(`Node being replaced is already removed.`);
                  }
                  if (!context.parent) {
                      throw new Error(`Cannot replace root node.`);
                  }
              }
              context.parent.children[context.childIndex] = context.currentNode = node;
          },
          removeNode(node) {
              if ((browser$1$1.env.NODE_ENV !== 'production') && !context.parent) {
                  throw new Error(`Cannot remove root node.`);
              }
              const list = context.parent.children;
              const removalIndex = node
                  ? list.indexOf(node)
                  : context.currentNode
                      ? context.childIndex
                      : -1;
              /* istanbul ignore if */
              if ((browser$1$1.env.NODE_ENV !== 'production') && removalIndex < 0) {
                  throw new Error(`node being removed is not a child of current parent`);
              }
              if (!node || node === context.currentNode) {
                  // current node removed
                  context.currentNode = null;
                  context.onNodeRemoved();
              }
              else {
                  // sibling node removed
                  if (context.childIndex > removalIndex) {
                      context.childIndex--;
                      context.onNodeRemoved();
                  }
              }
              context.parent.children.splice(removalIndex, 1);
          },
          onNodeRemoved: () => { },
          addIdentifiers(exp) {
          },
          removeIdentifiers(exp) {
          },
          hoist(exp) {
              context.hoists.push(exp);
              const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);
              identifier.hoisted = exp;
              return identifier;
          },
          cache(exp, isVNode = false) {
              return createCacheExpression(++context.cached, exp, isVNode);
          }
      };
      {
          context.filters = new Set();
      }
      return context;
  }
  function transform$1(root, options) {
      const context = createTransformContext(root, options);
      traverseNode(root, context);
      if (options.hoistStatic) {
          hoistStatic(root, context);
      }
      if (!options.ssr) {
          createRootCodegen(root, context);
      }
      // finalize meta information
      root.helpers = [...context.helpers.keys()];
      root.components = [...context.components];
      root.directives = [...context.directives];
      root.imports = context.imports;
      root.hoists = context.hoists;
      root.temps = context.temps;
      root.cached = context.cached;
      {
          root.filters = [...context.filters];
      }
  }
  function createRootCodegen(root, context) {
      const { helper, removeHelper } = context;
      const { children } = root;
      if (children.length === 1) {
          const child = children[0];
          // if the single child is an element, turn it into a block.
          if (isSingleElementRoot(root, child) && child.codegenNode) {
              // single element root is never hoisted so codegenNode will never be
              // SimpleExpressionNode
              const codegenNode = child.codegenNode;
              if (codegenNode.type === 13 /* VNODE_CALL */) {
                  if (!codegenNode.isBlock) {
                      removeHelper(CREATE_VNODE);
                      codegenNode.isBlock = true;
                      helper(OPEN_BLOCK);
                      helper(CREATE_BLOCK);
                  }
              }
              root.codegenNode = codegenNode;
          }
          else {
              // - single <slot/>, IfNode, ForNode: already blocks.
              // - single text node: always patched.
              // root codegen falls through via genNode()
              root.codegenNode = child;
          }
      }
      else if (children.length > 1) {
          // root has multiple nodes - return a fragment block.
          let patchFlag = 64 /* STABLE_FRAGMENT */;
          let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];
          // check if the fragment actually contains a single valid child with
          // the rest being comments
          if ((browser$1$1.env.NODE_ENV !== 'production') &&
              children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {
              patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;
              patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;
          }
          root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + ((browser$1$1.env.NODE_ENV !== 'production') ? ` /* ${patchFlagText} */` : ``), undefined, undefined, true);
      }
      else ;
  }
  function traverseChildren(parent, context) {
      let i = 0;
      const nodeRemoved = () => {
          i--;
      };
      for (; i < parent.children.length; i++) {
          const child = parent.children[i];
          if (isString$2(child))
              continue;
          context.parent = parent;
          context.childIndex = i;
          context.onNodeRemoved = nodeRemoved;
          traverseNode(child, context);
      }
  }
  function traverseNode(node, context) {
      context.currentNode = node;
      // apply transform plugins
      const { nodeTransforms } = context;
      const exitFns = [];
      for (let i = 0; i < nodeTransforms.length; i++) {
          const onExit = nodeTransforms[i](node, context);
          if (onExit) {
              if (isArray$3(onExit)) {
                  exitFns.push(...onExit);
              }
              else {
                  exitFns.push(onExit);
              }
          }
          if (!context.currentNode) {
              // node was removed
              return;
          }
          else {
              // node may have been replaced
              node = context.currentNode;
          }
      }
      switch (node.type) {
          case 3 /* COMMENT */:
              if (!context.ssr) {
                  // inject import for the Comment symbol, which is needed for creating
                  // comment nodes with `createVNode`
                  context.helper(CREATE_COMMENT);
              }
              break;
          case 5 /* INTERPOLATION */:
              // no need to traverse, but we need to inject toString helper
              if (!context.ssr) {
                  context.helper(TO_DISPLAY_STRING);
              }
              break;
          // for container types, further traverse downwards
          case 9 /* IF */:
              for (let i = 0; i < node.branches.length; i++) {
                  traverseNode(node.branches[i], context);
              }
              break;
          case 10 /* IF_BRANCH */:
          case 11 /* FOR */:
          case 1 /* ELEMENT */:
          case 0 /* ROOT */:
              traverseChildren(node, context);
              break;
      }
      // exit transforms
      context.currentNode = node;
      let i = exitFns.length;
      while (i--) {
          exitFns[i]();
      }
  }

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  new RegExp('\\b' +
      ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
          'super,throw,while,yield,delete,export,import,return,switch,default,' +
          'extends,finally,continue,debugger,function,arguments,typeof,void')
          .split(',')
          .join('\\b|\\b') +
      '\\b');

  (browser$1$1.env.NODE_ENV !== 'production')
      ? Object.freeze({})
      : {};
  (browser$1$1.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];

  const V_MODEL_RADIO = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vModelRadio` : ``);
  const V_MODEL_CHECKBOX = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vModelCheckbox` : ``);
  const V_MODEL_TEXT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vModelText` : ``);
  const V_MODEL_SELECT = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vModelSelect` : ``);
  const V_MODEL_DYNAMIC = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vModelDynamic` : ``);
  const V_ON_WITH_MODIFIERS = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vOnModifiersGuard` : ``);
  const V_ON_WITH_KEYS = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vOnKeysGuard` : ``);
  const V_SHOW = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `vShow` : ``);
  const TRANSITION = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `Transition` : ``);
  const TRANSITION_GROUP = Symbol((browser$1$1.env.NODE_ENV !== 'production') ? `TransitionGroup` : ``);
  registerRuntimeHelpers({
      [V_MODEL_RADIO]: `vModelRadio`,
      [V_MODEL_CHECKBOX]: `vModelCheckbox`,
      [V_MODEL_TEXT]: `vModelText`,
      [V_MODEL_SELECT]: `vModelSelect`,
      [V_MODEL_DYNAMIC]: `vModelDynamic`,
      [V_ON_WITH_MODIFIERS]: `withModifiers`,
      [V_ON_WITH_KEYS]: `withKeys`,
      [V_SHOW]: `vShow`,
      [TRANSITION]: `Transition`,
      [TRANSITION_GROUP]: `TransitionGroup`
  });

  /* eslint-disable no-restricted-globals */
  let decoder;
  function decodeHtmlBrowser(raw, asAttr = false) {
      if (!decoder) {
          decoder = document.createElement('div');
      }
      if (asAttr) {
          decoder.innerHTML = `<div foo="${raw.replace(/"/g, '&quot;')}">`;
          return decoder.children[0].getAttribute('foo');
      }
      else {
          decoder.innerHTML = raw;
          return decoder.textContent;
      }
  }

  const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
  const parserOptions = {
      isVoidTag,
      isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: tag => tag === 'pre',
      decodeEntities: decodeHtmlBrowser ,
      isBuiltInComponent: (tag) => {
          if (isBuiltInType(tag, `Transition`)) {
              return TRANSITION;
          }
          else if (isBuiltInType(tag, `TransitionGroup`)) {
              return TRANSITION_GROUP;
          }
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
      getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0 /* HTML */;
          if (parent && ns === 2 /* MATH_ML */) {
              if (parent.tag === 'annotation-xml') {
                  if (tag === 'svg') {
                      return 1 /* SVG */;
                  }
                  if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                      a.name === 'encoding' &&
                      a.value != null &&
                      (a.value.content === 'text/html' ||
                          a.value.content === 'application/xhtml+xml'))) {
                      ns = 0 /* HTML */;
                  }
              }
              else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                  tag !== 'mglyph' &&
                  tag !== 'malignmark') {
                  ns = 0 /* HTML */;
              }
          }
          else if (parent && ns === 1 /* SVG */) {
              if (parent.tag === 'foreignObject' ||
                  parent.tag === 'desc' ||
                  parent.tag === 'title') {
                  ns = 0 /* HTML */;
              }
          }
          if (ns === 0 /* HTML */) {
              if (tag === 'svg') {
                  return 1 /* SVG */;
              }
              if (tag === 'math') {
                  return 2 /* MATH_ML */;
              }
          }
          return ns;
      },
      // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
      getTextMode({ tag, ns }) {
          if (ns === 0 /* HTML */) {
              if (tag === 'textarea' || tag === 'title') {
                  return 1 /* RCDATA */;
              }
              if (isRawTextContainer(tag)) {
                  return 2 /* RAWTEXT */;
              }
          }
          return 0 /* DATA */;
      }
  };

  // Parse inline CSS strings for static style attributes into an object.
  // This is a NodeTransform since it works on the static `style` attribute and
  // converts it into a dynamic equivalent:
  // style="color: red" -> :style='{ "color": "red" }'
  // It is then processed by `transformElement` and included in the generated
  // props.
  const transformStyle = node => {
      if (node.type === 1 /* ELEMENT */) {
          node.props.forEach((p, i) => {
              if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                  // replace p with an expression node
                  node.props[i] = {
                      type: 7 /* DIRECTIVE */,
                      name: `bind`,
                      arg: createSimpleExpression(`style`, true, p.loc),
                      exp: parseInlineCSS(p.value.content, p.loc),
                      modifiers: [],
                      loc: p.loc
                  };
              }
          });
      }
  };
  const parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
  };

  function createDOMCompilerError(code, loc) {
      return createCompilerError(code, loc, (browser$1$1.env.NODE_ENV !== 'production') || !true ? DOMErrorMessages : undefined);
  }
  const DOMErrorMessages = {
      [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
      [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
      [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
      [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
      [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
      [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
      [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
      [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };

  const warnTransitionChildren = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          node.tagType === 1 /* COMPONENT */) {
          const component = context.isBuiltInComponent(node.tag);
          if (component === TRANSITION) {
              return () => {
                  if (node.children.length && hasMultipleChildren(node)) {
                      context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
              };
          }
      }
  };
  function hasMultipleChildren(node) {
      // #1352 filter out potential comment nodes.
      const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));
      const child = children[0];
      return (children.length !== 1 ||
          child.type === 11 /* FOR */ ||
          (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
  }

  [
      transformStyle,
      ...((browser$1$1.env.NODE_ENV !== 'production') ? [warnTransitionChildren] : [])
  ];
  function parse$1(template, options = {}) {
      return baseParse(template, extend$1({}, parserOptions, options));
  }

  var Parser = /*#__PURE__*/function () {
    function Parser(props) {
      _classCallCheck(this, Parser);

      this.content = props.content;
      this.type = props.type;
      var script = this.content;

      if (this.type === 'vue') {
        console.error('NOT SOPPORT TYPE');
        this.vueTemplateNode = this._parserVue();
        var scriptNode = this.vueTemplateNode.children.find(function (node) {
          return node.tag === 'script';
        });

        if (scriptNode) {
          script = scriptNode.children[0].content;
        } else {
          console.warn('TODO warn script-node null');
        }
      }

      this.ast = this._parser(script);
    }

    _createClass(Parser, [{
      key: "_parserVue",
      value: function _parserVue() {
        var ast = parse$1(this.content);
        return ast;
      }
    }, {
      key: "_parser",
      value: function _parser(script) {
        var Plugins = {
          js: [],
          vue: [],
          jsx: ['jsx'],
          ts: ['typescript'],
          tsx: ['jsx', 'typescript']
        };
        return parse_1(script, {
          plugins: Plugins[this.type],
          sourceType: 'module'
        });
      }
    }]);

    return Parser;
  }();

  var parser = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': Parser
  });

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var lodash = {exports: {}};

  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  (function (module, exports) {
  (function() {

    /** Used as a safe reference for `undefined` in pre-ES5 environments. */
    var undefined$1;

    /** Used as the semantic version number. */
    var VERSION = '4.17.21';

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /** Error message constants. */
    var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
        FUNC_ERROR_TEXT = 'Expected a function',
        INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /** Used as the internal argument placeholder. */
    var PLACEHOLDER = '__lodash_placeholder__';

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /** Used to compose bitmasks for function metadata. */
    var WRAP_BIND_FLAG = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;

    /** Used as default options for `_.truncate`. */
    var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...';

    /** Used to detect hot functions by number of calls within a span of milliseconds. */
    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /** Used to indicate the type of lazy iteratees. */
    var LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e+308,
        NAN = 0 / 0;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /** Used to associate wrap methods with their bit flags. */
    var wrapFlags = [
      ['ary', WRAP_ARY_FLAG],
      ['bind', WRAP_BIND_FLAG],
      ['bindKey', WRAP_BIND_KEY_FLAG],
      ['curry', WRAP_CURRY_FLAG],
      ['curryRight', WRAP_CURRY_RIGHT_FLAG],
      ['flip', WRAP_FLIP_FLAG],
      ['partial', WRAP_PARTIAL_FLAG],
      ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
      ['rearg', WRAP_REARG_FLAG]
    ];

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        domExcTag = '[object DOMException]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]',
        weakSetTag = '[object WeakSet]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to match empty string literals in compiled template source. */
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

    /** Used to match HTML entities and HTML characters. */
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reUnescapedHtml = /[&<>"']/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

    /** Used to match template delimiters. */
    var reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /** Used to match wrap detail comments. */
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Used to validate the `validate` option in `_.template` variable.
     *
     * Forbids characters which could potentially change the meaning of the function argument definition:
     * - "()," (modification of function parameters)
     * - "=" (default value)
     * - "[]{}" (destructuring of function parameters)
     * - "/" (beginning of a comment)
     * - whitespace
     */
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Used to match
     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
     */
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to ensure capturing order of template delimiters. */
    var reNoMatch = /($^)/;

    /** Used to match unescaped characters in compiled string literals. */
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]",
        rsAstral = '[' + rsAstralRange + ']',
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos, 'g');

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo, 'g');

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /** Used to assign default `context` object properties. */
    var contextProps = [
      'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
      'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
      'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
      'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
      '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
    ];

    /** Used to make template sourceURLs easier to identify. */
    var templateCounter = -1;

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] =
    cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
    cloneableTags[boolTag] = cloneableTags[dateTag] =
    cloneableTags[float32Tag] = cloneableTags[float64Tag] =
    cloneableTags[int8Tag] = cloneableTags[int16Tag] =
    cloneableTags[int32Tag] = cloneableTags[mapTag] =
    cloneableTags[numberTag] = cloneableTags[objectTag] =
    cloneableTags[regexpTag] = cloneableTags[setTag] =
    cloneableTags[stringTag] = cloneableTags[symbolTag] =
    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] =
    cloneableTags[weakMapTag] = false;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /** Used to map characters to HTML entities. */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to map HTML entities to characters. */
    var htmlUnescapes = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"',
      '&#39;': "'"
    };

    /** Used to escape characters for inclusion in compiled string literals. */
    var stringEscapes = {
      '\\': '\\',
      "'": "'",
      '\n': 'n',
      '\r': 'r',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    /** Built-in method references without a dependency on `root`. */
    var freeParseFloat = parseFloat,
        freeParseInt = parseInt;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
        nodeIsDate = nodeUtil && nodeUtil.isDate,
        nodeIsMap = nodeUtil && nodeUtil.isMap,
        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
        nodeIsSet = nodeUtil && nodeUtil.isSet,
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /*--------------------------------------------------------------------------*/

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    /**
     * A specialized version of `baseAggregator` for arrays.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }

    /**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */
    function arrayIncludesWith(array, value, comparator) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the last element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    var asciiSize = baseProperty('length');

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
      return string.split('');
    }

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    /**
     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
     * without support for iteratee shorthands, which iterates over `collection`
     * using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

      while ((fromRight ? index-- : ++index < length)) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOf(array, value, fromIndex) {
      return value === value
        ? strictIndexOf(array, value, fromIndex)
        : baseFindIndex(array, baseIsNaN, fromIndex);
    }

    /**
     * This function is like `baseIndexOf` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */
    function baseIsNaN(value) {
      return value !== value;
    }

    /**
     * The base implementation of `_.mean` and `_.meanBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the mean.
     */
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? (baseSum(array, iteratee) / length) : NAN;
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initAccum
          ? (initAccum = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define the
     * sort order of `array` and replaces criteria objects with their corresponding
     * values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    /**
     * The base implementation of `_.sum` and `_.sumBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */
    function baseSum(array, iteratee) {
      var result,
          index = -1,
          length = array.length;

      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : (result + current);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the key-value pairs.
     */
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    /**
     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the first unmatched string symbol.
     */
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1,
          length = strSymbols.length;

      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the last unmatched string symbol.
     */
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;

      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
      return index;
    }

    /**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */
    function countHolders(array, placeholder) {
      var length = array.length,
          result = 0;

      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = basePropertyOf(deburredLetters);

    /**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    var escapeHtmlChar = basePropertyOf(htmlEscapes);

    /**
     * Used by `_.template` to escape characters for inclusion in compiled string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeStringChar(chr) {
      return '\\' + stringEscapes[chr];
    }

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    /**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */
    function iteratorToArray(iterator) {
      var data,
          result = [];

      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */
    function replaceHolders(array, placeholder) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    /**
     * Converts `set` to its value-value pairs.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the value-value pairs.
     */
    function setToPairs(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }

    /**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1,
          length = array.length;

      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * A specialized version of `_.lastIndexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }

    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      return hasUnicode(string)
        ? unicodeSize(string)
        : asciiSize(string);
    }

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return hasUnicode(string)
        ? unicodeToArray(string)
        : asciiToArray(string);
    }

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /**
     * Used by `_.unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} chr The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

    /**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Create a new pristine `lodash` function using the `context` object.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Util
     * @param {Object} [context=root] The context object.
     * @returns {Function} Returns a new `lodash` function.
     * @example
     *
     * _.mixin({ 'foo': _.constant('foo') });
     *
     * var lodash = _.runInContext();
     * lodash.mixin({ 'bar': lodash.constant('bar') });
     *
     * _.isFunction(_.foo);
     * // => true
     * _.isFunction(_.bar);
     * // => false
     *
     * lodash.isFunction(lodash.foo);
     * // => false
     * lodash.isFunction(lodash.bar);
     * // => true
     *
     * // Create a suped-up `defer` in Node.js.
     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
     */
    var runInContext = (function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

      /** Built-in constructor references. */
      var Array = context.Array,
          Date = context.Date,
          Error = context.Error,
          Function = context.Function,
          Math = context.Math,
          Object = context.Object,
          RegExp = context.RegExp,
          String = context.String,
          TypeError = context.TypeError;

      /** Used for built-in method references. */
      var arrayProto = Array.prototype,
          funcProto = Function.prototype,
          objectProto = Object.prototype;

      /** Used to detect overreaching core-js shims. */
      var coreJsData = context['__core-js_shared__'];

      /** Used to resolve the decompiled source of functions. */
      var funcToString = funcProto.toString;

      /** Used to check objects for own properties. */
      var hasOwnProperty = objectProto.hasOwnProperty;

      /** Used to generate unique IDs. */
      var idCounter = 0;

      /** Used to detect methods masquerading as native. */
      var maskSrcKey = (function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? ('Symbol(src)_1.' + uid) : '';
      }());

      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */
      var nativeObjectToString = objectProto.toString;

      /** Used to infer the `Object` constructor. */
      var objectCtorString = funcToString.call(Object);

      /** Used to restore the original `_` reference in `_.noConflict`. */
      var oldDash = root._;

      /** Used to detect if a method is native. */
      var reIsNative = RegExp('^' +
        funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
      );

      /** Built-in value references. */
      var Buffer = moduleExports ? context.Buffer : undefined$1,
          Symbol = context.Symbol,
          Uint8Array = context.Uint8Array,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
          getPrototype = overArg(Object.getPrototypeOf, Object),
          objectCreate = Object.create,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          splice = arrayProto.splice,
          spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
          symIterator = Symbol ? Symbol.iterator : undefined$1,
          symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

      var defineProperty = (function() {
        try {
          var func = getNative(Object, 'defineProperty');
          func({}, '', {});
          return func;
        } catch (e) {}
      }());

      /** Mocked built-ins. */
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
          ctxNow = Date && Date.now !== root.Date.now && Date.now,
          ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

      /* Built-in method references for those with the same name as other `lodash` methods. */
      var nativeCeil = Math.ceil,
          nativeFloor = Math.floor,
          nativeGetSymbols = Object.getOwnPropertySymbols,
          nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
          nativeIsFinite = context.isFinite,
          nativeJoin = arrayProto.join,
          nativeKeys = overArg(Object.keys, Object),
          nativeMax = Math.max,
          nativeMin = Math.min,
          nativeNow = Date.now,
          nativeParseInt = context.parseInt,
          nativeRandom = Math.random,
          nativeReverse = arrayProto.reverse;

      /* Built-in method references that are verified to be native. */
      var DataView = getNative(context, 'DataView'),
          Map = getNative(context, 'Map'),
          Promise = getNative(context, 'Promise'),
          Set = getNative(context, 'Set'),
          WeakMap = getNative(context, 'WeakMap'),
          nativeCreate = getNative(Object, 'create');

      /** Used to store function metadata. */
      var metaMap = WeakMap && new WeakMap;

      /** Used to lookup unminified function names. */
      var realNames = {};

      /** Used to detect maps, sets, and weakmaps. */
      var dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map),
          promiseCtorString = toSource(Promise),
          setCtorString = toSource(Set),
          weakMapCtorString = toSource(WeakMap);

      /** Used to convert symbols to primitives and strings. */
      var symbolProto = Symbol ? Symbol.prototype : undefined$1,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
          symbolToString = symbolProto ? symbolProto.toString : undefined$1;

      /*------------------------------------------------------------------------*/

      /**
       * Creates a `lodash` object which wraps `value` to enable implicit method
       * chain sequences. Methods that operate on and return arrays, collections,
       * and functions can be chained together. Methods that retrieve a single value
       * or may return a primitive value will automatically end the chain sequence
       * and return the unwrapped value. Otherwise, the value must be unwrapped
       * with `_#value`.
       *
       * Explicit chain sequences, which must be unwrapped with `_#value`, may be
       * enabled using `_.chain`.
       *
       * The execution of chained methods is lazy, that is, it's deferred until
       * `_#value` is implicitly or explicitly called.
       *
       * Lazy evaluation allows several methods to support shortcut fusion.
       * Shortcut fusion is an optimization to merge iteratee calls; this avoids
       * the creation of intermediate arrays and can greatly reduce the number of
       * iteratee executions. Sections of a chain sequence qualify for shortcut
       * fusion if the section is applied to an array and iteratees accept only
       * one argument. The heuristic for whether a section qualifies for shortcut
       * fusion is subject to change.
       *
       * Chaining is supported in custom builds as long as the `_#value` method is
       * directly or indirectly included in the build.
       *
       * In addition to lodash methods, wrappers have `Array` and `String` methods.
       *
       * The wrapper `Array` methods are:
       * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
       *
       * The wrapper `String` methods are:
       * `replace` and `split`
       *
       * The wrapper methods that support shortcut fusion are:
       * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
       * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
       * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
       *
       * The chainable wrapper methods are:
       * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
       * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
       * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
       * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
       * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
       * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
       * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
       * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
       * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
       * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
       * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
       * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
       * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
       * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
       * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
       * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
       * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
       * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
       * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
       * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
       * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
       * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
       * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
       * `zipObject`, `zipObjectDeep`, and `zipWith`
       *
       * The wrapper methods that are **not** chainable by default are:
       * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
       * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
       * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
       * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
       * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
       * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
       * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
       * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
       * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
       * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
       * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
       * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
       * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
       * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
       * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
       * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
       * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
       * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
       * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
       * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
       * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
       * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
       * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
       * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
       * `upperFirst`, `value`, and `words`
       *
       * @name _
       * @constructor
       * @category Seq
       * @param {*} value The value to wrap in a `lodash` instance.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2, 3]);
       *
       * // Returns an unwrapped value.
       * wrapped.reduce(_.add);
       * // => 6
       *
       * // Returns a wrapped value.
       * var squares = wrapped.map(square);
       *
       * _.isArray(squares);
       * // => false
       *
       * _.isArray(squares.value());
       * // => true
       */
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, '__wrapped__')) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }

      /**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} proto The object to inherit from.
       * @returns {Object} Returns the new object.
       */
      var baseCreate = (function() {
        function object() {}
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object;
          object.prototype = undefined$1;
          return result;
        };
      }());

      /**
       * The function whose prototype chain sequence wrappers inherit from.
       *
       * @private
       */
      function baseLodash() {
        // No operation performed.
      }

      /**
       * The base constructor for creating `lodash` wrapper objects.
       *
       * @private
       * @param {*} value The value to wrap.
       * @param {boolean} [chainAll] Enable explicit method chain sequences.
       */
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }

      /**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB) as well as ES2015 template strings. Change the
       * following template settings to use alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type {Object}
       */
      lodash.templateSettings = {

        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'escape': reEscape,

        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'evaluate': reEvaluate,

        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'interpolate': reInterpolate,

        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        'variable': '',

        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        'imports': {

          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          '_': lodash
        }
      };

      // Ensure wrappers are instances of `baseLodash`.
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;

      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;

      /*------------------------------------------------------------------------*/

      /**
       * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
       *
       * @private
       * @constructor
       * @param {*} value The value to wrap.
       */
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }

      /**
       * Creates a clone of the lazy wrapper object.
       *
       * @private
       * @name clone
       * @memberOf LazyWrapper
       * @returns {Object} Returns the cloned `LazyWrapper` object.
       */
      function lazyClone() {
        var result = new LazyWrapper(this.__wrapped__);
        result.__actions__ = copyArray(this.__actions__);
        result.__dir__ = this.__dir__;
        result.__filtered__ = this.__filtered__;
        result.__iteratees__ = copyArray(this.__iteratees__);
        result.__takeCount__ = this.__takeCount__;
        result.__views__ = copyArray(this.__views__);
        return result;
      }

      /**
       * Reverses the direction of lazy iteration.
       *
       * @private
       * @name reverse
       * @memberOf LazyWrapper
       * @returns {Object} Returns the new reversed `LazyWrapper` object.
       */
      function lazyReverse() {
        if (this.__filtered__) {
          var result = new LazyWrapper(this);
          result.__dir__ = -1;
          result.__filtered__ = true;
        } else {
          result = this.clone();
          result.__dir__ *= -1;
        }
        return result;
      }

      /**
       * Extracts the unwrapped value from its lazy wrapper.
       *
       * @private
       * @name value
       * @memberOf LazyWrapper
       * @returns {*} Returns the unwrapped value.
       */
      function lazyValue() {
        var array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = getView(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : (start - 1),
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__);

        if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result = [];

        outer:
        while (length-- && resIndex < takeCount) {
          index += dir;

          var iterIndex = -1,
              value = array[index];

          while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex],
                iteratee = data.iteratee,
                type = data.type,
                computed = iteratee(value);

            if (type == LAZY_MAP_FLAG) {
              value = computed;
            } else if (!computed) {
              if (type == LAZY_FILTER_FLAG) {
                continue outer;
              } else {
                break outer;
              }
            }
          }
          result[resIndex++] = value;
        }
        return result;
      }

      // Ensure `LazyWrapper` is an instance of `baseLodash`.
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;

      /*------------------------------------------------------------------------*/

      /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function Hash(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      /**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }

      /**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }

      /**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? undefined$1 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
      }

      /**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
      }

      /**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
        return this;
      }

      // Add methods to `Hash`.
      Hash.prototype.clear = hashClear;
      Hash.prototype['delete'] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;

      /*------------------------------------------------------------------------*/

      /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function ListCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      /**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }

      /**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function listCacheDelete(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }

      /**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function listCacheGet(key) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        return index < 0 ? undefined$1 : data[index][1];
      }

      /**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }

      /**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */
      function listCacheSet(key, value) {
        var data = this.__data__,
            index = assocIndexOf(data, key);

        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }

      // Add methods to `ListCache`.
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype['delete'] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;

      /*------------------------------------------------------------------------*/

      /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function MapCache(entries) {
        var index = -1,
            length = entries == null ? 0 : entries.length;

        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }

      /**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          'hash': new Hash,
          'map': new (Map || ListCache),
          'string': new Hash
        };
      }

      /**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
      }

      /**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }

      /**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }

      /**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */
      function mapCacheSet(key, value) {
        var data = getMapData(this, key),
            size = data.size;

        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }

      // Add methods to `MapCache`.
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype['delete'] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;

      /*------------------------------------------------------------------------*/

      /**
       *
       * Creates an array cache object to store unique values.
       *
       * @private
       * @constructor
       * @param {Array} [values] The values to cache.
       */
      function SetCache(values) {
        var index = -1,
            length = values == null ? 0 : values.length;

        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values[index]);
        }
      }

      /**
       * Adds `value` to the array cache.
       *
       * @private
       * @name add
       * @memberOf SetCache
       * @alias push
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache instance.
       */
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }

      /**
       * Checks if `value` is in the array cache.
       *
       * @private
       * @name has
       * @memberOf SetCache
       * @param {*} value The value to search for.
       * @returns {number} Returns `true` if `value` is found, else `false`.
       */
      function setCacheHas(value) {
        return this.__data__.has(value);
      }

      // Add methods to `SetCache`.
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;

      /*------------------------------------------------------------------------*/

      /**
       * Creates a stack cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }

      /**
       * Removes all key-value entries from the stack.
       *
       * @private
       * @name clear
       * @memberOf Stack
       */
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }

      /**
       * Removes `key` and its value from the stack.
       *
       * @private
       * @name delete
       * @memberOf Stack
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */
      function stackDelete(key) {
        var data = this.__data__,
            result = data['delete'](key);

        this.size = data.size;
        return result;
      }

      /**
       * Gets the stack value for `key`.
       *
       * @private
       * @name get
       * @memberOf Stack
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */
      function stackGet(key) {
        return this.__data__.get(key);
      }

      /**
       * Checks if a stack value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Stack
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function stackHas(key) {
        return this.__data__.has(key);
      }

      /**
       * Sets the stack `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Stack
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the stack cache instance.
       */
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }

      // Add methods to `Stack`.
      Stack.prototype.clear = stackClear;
      Stack.prototype['delete'] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;

      /*------------------------------------------------------------------------*/

      /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;

        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) &&
              !(skipIndexes && (
                 // Safari 9 has enumerable `arguments.length` in strict mode.
                 key == 'length' ||
                 // Node.js 0.10 has enumerable non-index properties on buffers.
                 (isBuff && (key == 'offset' || key == 'parent')) ||
                 // PhantomJS 2 has enumerable non-index properties on typed arrays.
                 (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                 // Skip index properties.
                 isIndex(key, length)
              ))) {
            result.push(key);
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.sample` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @returns {*} Returns the random element.
       */
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }

      /**
       * A specialized version of `_.sampleSize` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }

      /**
       * A specialized version of `_.shuffle` for arrays.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }

      /**
       * This function is like `assignValue` except that it doesn't assign
       * `undefined` values.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */
      function assignMergeValue(object, key, value) {
        if ((value !== undefined$1 && !eq(object[key], value)) ||
            (value === undefined$1 && !(key in object))) {
          baseAssignValue(object, key, value);
        }
      }

      /**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
            (value === undefined$1 && !(key in object))) {
          baseAssignValue(object, key, value);
        }
      }

      /**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }

      /**
       * Aggregates elements of `collection` on `accumulator` with keys transformed
       * by `iteratee` and values set by `setter`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach(collection, function(value, key, collection) {
          setter(accumulator, value, iteratee(value), collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.assign` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }

      /**
       * The base implementation of `_.assignIn` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }

      /**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */
      function baseAssignValue(object, key, value) {
        if (key == '__proto__' && defineProperty) {
          defineProperty(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
          });
        } else {
          object[key] = value;
        }
      }

      /**
       * The base implementation of `_.at` without support for individual paths.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {string[]} paths The property paths to pick.
       * @returns {Array} Returns the picked elements.
       */
      function baseAt(object, paths) {
        var index = -1,
            length = paths.length,
            result = Array(length),
            skip = object == null;

        while (++index < length) {
          result[index] = skip ? undefined$1 : get(object, paths[index]);
        }
        return result;
      }

      /**
       * The base implementation of `_.clamp` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       */
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }

      /**
       * The base implementation of `_.clone` and `_.cloneDeep` which tracks
       * traversed objects.
       *
       * @private
       * @param {*} value The value to clone.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Deep clone
       *  2 - Flatten inherited properties
       *  4 - Clone symbols
       * @param {Function} [customizer] The function to customize cloning.
       * @param {string} [key] The key of `value`.
       * @param {Object} [object] The parent object of `value`.
       * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
       * @returns {*} Returns the cloned value.
       */
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result,
            isDeep = bitmask & CLONE_DEEP_FLAG,
            isFlat = bitmask & CLONE_FLAT_FLAG,
            isFull = bitmask & CLONE_SYMBOLS_FLAG;

        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== undefined$1) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag;

          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
            result = (isFlat || isFunc) ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat
                ? copySymbolsIn(value, baseAssignIn(result, value))
                : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        // Check for circular references and return its corresponding clone.
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);

        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key) {
            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
        }

        var keysFunc = isFull
          ? (isFlat ? getAllKeysIn : getAllKeys)
          : (isFlat ? keysIn : keys);

        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key) {
          if (props) {
            key = subValue;
            subValue = value[key];
          }
          // Recursively populate clone (susceptible to call stack limits).
          assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
        return result;
      }

      /**
       * The base implementation of `_.conforms` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       */
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }

      /**
       * The base implementation of `_.conformsTo` which accepts `props` to check.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       */
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (length--) {
          var key = props[length],
              predicate = source[key],
              value = object[key];

          if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }

      /**
       * The base implementation of `_.delay` and `_.defer` which accepts `args`
       * to provide to `func`.
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {Array} args The arguments to provide to `func`.
       * @returns {number|Object} Returns the timer id or timeout object.
       */
      function baseDelay(func, wait, args) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return setTimeout(function() { func.apply(undefined$1, args); }, wait);
      }

      /**
       * The base implementation of methods like `_.difference` without support
       * for excluding multiple arrays or iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       */
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            isCommon = true,
            length = array.length,
            result = [],
            valuesLength = values.length;

        if (!length) {
          return result;
        }
        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee));
        }
        if (comparator) {
          includes = arrayIncludesWith;
          isCommon = false;
        }
        else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values = new SetCache(values);
        }
        outer:
        while (++index < length) {
          var value = array[index],
              computed = iteratee == null ? value : iteratee(value);

          value = (comparator || value !== 0) ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          }
          else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.forEach` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */
      var baseEach = createBaseEach(baseForOwn);

      /**
       * The base implementation of `_.forEachRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */
      var baseEachRight = createBaseEach(baseForOwnRight, true);

      /**
       * The base implementation of `_.every` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`
       */
      function baseEvery(collection, predicate) {
        var result = true;
        baseEach(collection, function(value, index, collection) {
          result = !!predicate(value, index, collection);
          return result;
        });
        return result;
      }

      /**
       * The base implementation of methods like `_.max` and `_.min` which accepts a
       * `comparator` to determine the extremum value.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The iteratee invoked per iteration.
       * @param {Function} comparator The comparator used to compare values.
       * @returns {*} Returns the extremum value.
       */
      function baseExtremum(array, iteratee, comparator) {
        var index = -1,
            length = array.length;

        while (++index < length) {
          var value = array[index],
              current = iteratee(value);

          if (current != null && (computed === undefined$1
                ? (current === current && !isSymbol(current))
                : comparator(current, computed)
              )) {
            var computed = current,
                result = value;
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.fill` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       */
      function baseFill(array, value, start, end) {
        var length = array.length;

        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : (length + start);
        }
        end = (end === undefined$1 || end > length) ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }

      /**
       * The base implementation of `_.filter` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection) {
          if (predicate(value, index, collection)) {
            result.push(value);
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1,
            length = array.length;

        predicate || (predicate = isFlattenable);
        result || (result = []);

        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              // Recursively flatten arrays (susceptible to call stack limits).
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }

      /**
       * The base implementation of `baseForOwn` which iterates over `object`
       * properties returned by `keysFunc` and invokes `iteratee` for each property.
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */
      var baseFor = createBaseFor();

      /**
       * This function is like `baseFor` except that it iterates over properties
       * in the opposite order.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */
      var baseForRight = createBaseFor(true);

      /**
       * The base implementation of `_.forOwn` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }

      /**
       * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */
      function baseForOwnRight(object, iteratee) {
        return object && baseForRight(object, iteratee, keys);
      }

      /**
       * The base implementation of `_.functions` which creates an array of
       * `object` function property names filtered from `props`.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Array} props The property names to filter.
       * @returns {Array} Returns the function names.
       */
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }

      /**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */
      function baseGet(object, path) {
        path = castPath(path, object);

        var index = 0,
            length = path.length;

        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return (index && index == length) ? object : undefined$1;
      }

      /**
       * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
       * `keysFunc` and `symbolsFunc` to get the enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @param {Function} symbolsFunc The function to get the symbols of `object`.
       * @returns {Array} Returns the array of property names and symbols.
       */
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }

      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return (symToStringTag && symToStringTag in Object(value))
          ? getRawTag(value)
          : objectToString(value);
      }

      /**
       * The base implementation of `_.gt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       */
      function baseGt(value, other) {
        return value > other;
      }

      /**
       * The base implementation of `_.has` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }

      /**
       * The base implementation of `_.hasIn` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }

      /**
       * The base implementation of `_.inRange` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to check.
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       */
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }

      /**
       * The base implementation of methods like `_.intersection`, without support
       * for iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of shared values.
       */
      function baseIntersection(arrays, iteratee, comparator) {
        var includes = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array(othLength),
            maxLength = Infinity,
            result = [];

        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee) {
            array = arrayMap(array, baseUnary(iteratee));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
            ? new SetCache(othIndex && array)
            : undefined$1;
        }
        array = arrays[0];

        var index = -1,
            seen = caches[0];

        outer:
        while (++index < length && result.length < maxLength) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;

          value = (comparator || value !== 0) ? value : 0;
          if (!(seen
                ? cacheHas(seen, computed)
                : includes(result, computed, comparator)
              )) {
            othIndex = othLength;
            while (--othIndex) {
              var cache = caches[othIndex];
              if (!(cache
                    ? cacheHas(cache, computed)
                    : includes(arrays[othIndex], computed, comparator))
                  ) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.invert` and `_.invertBy` which inverts
       * `object` with values transformed by `iteratee` and set by `setter`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform values.
       * @param {Object} accumulator The initial inverted object.
       * @returns {Function} Returns `accumulator`.
       */
      function baseInverter(object, setter, iteratee, accumulator) {
        baseForOwn(object, function(value, key, object) {
          setter(accumulator, iteratee(value), key, object);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.invoke` without support for individual
       * method arguments.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {Array} args The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       */
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }

      /**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }

      /**
       * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       */
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }

      /**
       * The base implementation of `_.isDate` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       */
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }

      /**
       * The base implementation of `_.isEqual` which supports partial comparisons
       * and tracks traversed objects.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Unordered comparison
       *  2 - Partial comparison
       * @param {Function} [customizer] The function to customize comparisons.
       * @param {Object} [stack] Tracks traversed `value` and `other` objects.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       */
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }

      /**
       * A specialized version of `baseIsEqual` for arrays and objects which performs
       * deep comparisons and tracks traversed objects enabling objects with circular
       * references to be compared.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} [stack] Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other);

        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;

        var objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;

        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return (objIsArr || isTypedArray(object))
            ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
            : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;

            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }

      /**
       * The base implementation of `_.isMap` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       */
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }

      /**
       * The base implementation of `_.isMatch` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Array} matchData The property names, values, and compare flags to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       */
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length,
            length = index,
            noCustomizer = !customizer;

        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if ((noCustomizer && data[2])
                ? data[1] !== object[data[0]]
                : !(data[0] in object)
              ) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0],
              objValue = object[key],
              srcValue = data[1];

          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined$1
                  ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                  : result
                )) {
              return false;
            }
          }
        }
        return true;
      }

      /**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }

      /**
       * The base implementation of `_.isRegExp` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       */
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }

      /**
       * The base implementation of `_.isSet` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       */
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }

      /**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */
      function baseIsTypedArray(value) {
        return isObjectLike(value) &&
          isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }

      /**
       * The base implementation of `_.iteratee`.
       *
       * @private
       * @param {*} [value=_.identity] The value to convert to an iteratee.
       * @returns {Function} Returns the iteratee.
       */
      function baseIteratee(value) {
        // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
        // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
        if (typeof value == 'function') {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == 'object') {
          return isArray(value)
            ? baseMatchesProperty(value[0], value[1])
            : baseMatches(value);
        }
        return property(value);
      }

      /**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object),
            result = [];

        for (var key in object) {
          if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.lt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       */
      function baseLt(value, other) {
        return value < other;
      }

      /**
       * The base implementation of `_.map` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function baseMap(collection, iteratee) {
        var index = -1,
            result = isArrayLike(collection) ? Array(collection.length) : [];

        baseEach(collection, function(value, key, collection) {
          result[++index] = iteratee(value, key, collection);
        });
        return result;
      }

      /**
       * The base implementation of `_.matches` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       */
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }

      /**
       * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
       *
       * @private
       * @param {string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return (objValue === undefined$1 && objValue === srcValue)
            ? hasIn(object, path)
            : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }

      /**
       * The base implementation of `_.merge` without support for multiple sources.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} [customizer] The function to customize merged values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          }
          else {
            var newValue = customizer
              ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
              : undefined$1;

            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }

      /**
       * A specialized version of `baseMerge` for arrays and objects which performs
       * deep merges and tracks traversed objects enabling objects with circular
       * references to be merged.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {string} key The key of the value to merge.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} mergeFunc The function to merge values.
       * @param {Function} [customizer] The function to customize assigned values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue);

        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer
          ? customizer(objValue, srcValue, (key + ''), object, source, stack)
          : undefined$1;

        var isCommon = newValue === undefined$1;

        if (isCommon) {
          var isArr = isArray(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);

          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            }
            else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            }
            else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            }
            else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            }
            else {
              newValue = [];
            }
          }
          else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            }
            else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          }
          else {
            isCommon = false;
          }
        }
        if (isCommon) {
          // Recursively merge objects and arrays (susceptible to call stack limits).
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack['delete'](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }

      /**
       * The base implementation of `_.nth` which doesn't coerce arguments.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {number} n The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       */
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }

      /**
       * The base implementation of `_.orderBy` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
       * @param {string[]} orders The sort orders of `iteratees`.
       * @returns {Array} Returns the new sorted array.
       */
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee) {
            if (isArray(iteratee)) {
              return function(value) {
                return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
              }
            }
            return iteratee;
          });
        } else {
          iteratees = [identity];
        }

        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

        var result = baseMap(collection, function(value, key, collection) {
          var criteria = arrayMap(iteratees, function(iteratee) {
            return iteratee(value);
          });
          return { 'criteria': criteria, 'index': ++index, 'value': value };
        });

        return baseSortBy(result, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }

      /**
       * The base implementation of `_.pick` without support for individual
       * property identifiers.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @returns {Object} Returns the new object.
       */
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }

      /**
       * The base implementation of  `_.pickBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @param {Function} predicate The function invoked per property.
       * @returns {Object} Returns the new object.
       */
      function basePickBy(object, paths, predicate) {
        var index = -1,
            length = paths.length,
            result = {};

        while (++index < length) {
          var path = paths[index],
              value = baseGet(object, path);

          if (predicate(value, path)) {
            baseSet(result, castPath(path, object), value);
          }
        }
        return result;
      }

      /**
       * A specialized version of `baseProperty` which supports deep paths.
       *
       * @private
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }

      /**
       * The base implementation of `_.pullAllBy` without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       */
      function basePullAll(array, values, iteratee, comparator) {
        var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
            index = -1,
            length = values.length,
            seen = array;

        if (array === values) {
          values = copyArray(values);
        }
        if (iteratee) {
          seen = arrayMap(array, baseUnary(iteratee));
        }
        while (++index < length) {
          var fromIndex = 0,
              value = values[index],
              computed = iteratee ? iteratee(value) : value;

          while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }

      /**
       * The base implementation of `_.pullAt` without support for individual
       * indexes or capturing the removed elements.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {number[]} indexes The indexes of elements to remove.
       * @returns {Array} Returns `array`.
       */
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0,
            lastIndex = length - 1;

        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }

      /**
       * The base implementation of `_.random` without support for returning
       * floating-point numbers.
       *
       * @private
       * @param {number} lower The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the random number.
       */
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }

      /**
       * The base implementation of `_.range` and `_.rangeRight` which doesn't
       * coerce arguments.
       *
       * @private
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @param {number} step The value to increment or decrement by.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the range of numbers.
       */
      function baseRange(start, end, step, fromRight) {
        var index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result = Array(length);

        while (length--) {
          result[fromRight ? length : ++index] = start;
          start += step;
        }
        return result;
      }

      /**
       * The base implementation of `_.repeat` which doesn't coerce arguments.
       *
       * @private
       * @param {string} string The string to repeat.
       * @param {number} n The number of times to repeat the string.
       * @returns {string} Returns the repeated string.
       */
      function baseRepeat(string, n) {
        var result = '';
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result;
        }
        // Leverage the exponentiation by squaring algorithm for a faster repeat.
        // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
        do {
          if (n % 2) {
            result += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);

        return result;
      }

      /**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + '');
      }

      /**
       * The base implementation of `_.sample`.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       */
      function baseSample(collection) {
        return arraySample(values(collection));
      }

      /**
       * The base implementation of `_.sampleSize` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }

      /**
       * The base implementation of `_.set`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);

        var index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;

        while (nested != null && ++index < length) {
          var key = toKey(path[index]),
              newValue = value;

          if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
            return object;
          }

          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject(objValue)
                ? objValue
                : (isIndex(path[index + 1]) ? [] : {});
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }

      /**
       * The base implementation of `setData` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };

      /**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': constant(string),
          'writable': true
        });
      };

      /**
       * The base implementation of `_.shuffle`.
       *
       * @private
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }

      /**
       * The base implementation of `_.slice` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */
      function baseSlice(array, start, end) {
        var index = -1,
            length = array.length;

        if (start < 0) {
          start = -start > length ? 0 : (length + start);
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : ((end - start) >>> 0);
        start >>>= 0;

        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }

      /**
       * The base implementation of `_.some` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function baseSome(collection, predicate) {
        var result;

        baseEach(collection, function(value, index, collection) {
          result = predicate(value, index, collection);
          return !result;
        });
        return !!result;
      }

      /**
       * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
       * performs a binary search of `array` to determine the index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */
      function baseSortedIndex(array, value, retHighest) {
        var low = 0,
            high = array == null ? low : array.length;

        if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = (low + high) >>> 1,
                computed = array[mid];

            if (computed !== null && !isSymbol(computed) &&
                (retHighest ? (computed <= value) : (computed < value))) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }

      /**
       * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
       * which invokes `iteratee` for `value` and each element of `array` to compute
       * their sort ranking. The iteratee is invoked with one argument; (value).
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} iteratee The iteratee invoked per element.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */
      function baseSortedIndexBy(array, value, iteratee, retHighest) {
        var low = 0,
            high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }

        value = iteratee(value);
        var valIsNaN = value !== value,
            valIsNull = value === null,
            valIsSymbol = isSymbol(value),
            valIsUndefined = value === undefined$1;

        while (low < high) {
          var mid = nativeFloor((low + high) / 2),
              computed = iteratee(array[mid]),
              othIsDefined = computed !== undefined$1,
              othIsNull = computed === null,
              othIsReflexive = computed === computed,
              othIsSymbol = isSymbol(computed);

          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? (computed <= value) : (computed < value);
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }

      /**
       * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */
      function baseSortedUniq(array, iteratee) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;

          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.toNumber` which doesn't ensure correct
       * conversions of binary, hexadecimal, or octal string values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       */
      function baseToNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }

      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
          return value;
        }
        if (isArray(value)) {
          // Recursively convert values (susceptible to call stack limits).
          return arrayMap(value, baseToString) + '';
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : '';
        }
        var result = (value + '');
        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
      }

      /**
       * The base implementation of `_.uniqBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */
      function baseUniq(array, iteratee, comparator) {
        var index = -1,
            includes = arrayIncludes,
            length = array.length,
            isCommon = true,
            result = [],
            seen = result;

        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        }
        else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache;
        }
        else {
          seen = iteratee ? [] : result;
        }
        outer:
        while (++index < length) {
          var value = array[index],
              computed = iteratee ? iteratee(value) : value;

          value = (comparator || value !== 0) ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          }
          else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.unset`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The property path to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       */
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }

      /**
       * The base implementation of `_.update`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to update.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }

      /**
       * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
       * without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the slice of `array`.
       */
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length,
            index = fromRight ? length : -1;

        while ((fromRight ? index-- : ++index < length) &&
          predicate(array[index], index, array)) {}

        return isDrop
          ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
          : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
      }

      /**
       * The base implementation of `wrapperValue` which returns the result of
       * performing a sequence of actions on the unwrapped `value`, where each
       * successive action is supplied the return value of the previous.
       *
       * @private
       * @param {*} value The unwrapped value.
       * @param {Array} actions Actions to perform to resolve the unwrapped value.
       * @returns {*} Returns the resolved value.
       */
      function baseWrapperValue(value, actions) {
        var result = value;
        if (result instanceof LazyWrapper) {
          result = result.value();
        }
        return arrayReduce(actions, function(result, action) {
          return action.func.apply(action.thisArg, arrayPush([result], action.args));
        }, result);
      }

      /**
       * The base implementation of methods like `_.xor`, without support for
       * iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of values.
       */
      function baseXor(arrays, iteratee, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1,
            result = Array(length);

        while (++index < length) {
          var array = arrays[index],
              othIndex = -1;

          while (++othIndex < length) {
            if (othIndex != index) {
              result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result, 1), iteratee, comparator);
      }

      /**
       * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
       *
       * @private
       * @param {Array} props The property identifiers.
       * @param {Array} values The property values.
       * @param {Function} assignFunc The function to assign values.
       * @returns {Object} Returns the new object.
       */
      function baseZipObject(props, values, assignFunc) {
        var index = -1,
            length = props.length,
            valsLength = values.length,
            result = {};

        while (++index < length) {
          var value = index < valsLength ? values[index] : undefined$1;
          assignFunc(result, props[index], value);
        }
        return result;
      }

      /**
       * Casts `value` to an empty array if it's not an array like object.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Array|Object} Returns the cast array-like object.
       */
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }

      /**
       * Casts `value` to `identity` if it's not a function.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Function} Returns cast function.
       */
      function castFunction(value) {
        return typeof value == 'function' ? value : identity;
      }

      /**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }

      /**
       * A `baseRest` alias which can be replaced with `identity` by module
       * replacement plugins.
       *
       * @private
       * @type {Function}
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */
      var castRest = baseRest;

      /**
       * Casts `array` to a slice if it's needed.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {number} start The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the cast slice.
       */
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return (!start && end >= length) ? array : baseSlice(array, start, end);
      }

      /**
       * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
       *
       * @private
       * @param {number|Object} id The timer id or timeout object of the timer to clear.
       */
      var clearTimeout = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };

      /**
       * Creates a clone of  `buffer`.
       *
       * @private
       * @param {Buffer} buffer The buffer to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Buffer} Returns the cloned buffer.
       */
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length,
            result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

        buffer.copy(result);
        return result;
      }

      /**
       * Creates a clone of `arrayBuffer`.
       *
       * @private
       * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
      }

      /**
       * Creates a clone of `dataView`.
       *
       * @private
       * @param {Object} dataView The data view to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned data view.
       */
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }

      /**
       * Creates a clone of `regexp`.
       *
       * @private
       * @param {Object} regexp The regexp to clone.
       * @returns {Object} Returns the cloned regexp.
       */
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }

      /**
       * Creates a clone of the `symbol` object.
       *
       * @private
       * @param {Object} symbol The symbol object to clone.
       * @returns {Object} Returns the cloned symbol object.
       */
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }

      /**
       * Creates a clone of `typedArray`.
       *
       * @private
       * @param {Object} typedArray The typed array to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned typed array.
       */
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }

      /**
       * Compares values to sort them in ascending order.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol(value);

          var othIsDefined = other !== undefined$1,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol(other);

          if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
              (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
              (valIsNull && othIsDefined && othIsReflexive) ||
              (!valIsDefined && othIsReflexive) ||
              !valIsReflexive) {
            return 1;
          }
          if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
              (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
              (othIsNull && valIsDefined && valIsReflexive) ||
              (!othIsDefined && valIsReflexive) ||
              !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }

      /**
       * Used by `_.orderBy` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
       * specify an order of "desc" for descending or "asc" for ascending sort order
       * of corresponding values.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]|string[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */
      function compareMultiple(object, other, orders) {
        var index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;

        while (++index < length) {
          var result = compareAscending(objCriteria[index], othCriteria[index]);
          if (result) {
            if (index >= ordersLength) {
              return result;
            }
            var order = orders[index];
            return result * (order == 'desc' ? -1 : 1);
          }
        }
        // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
        // that causes it, under certain circumstances, to provide the same value for
        // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
        // for more details.
        //
        // This also ensures a stable sort in V8 and other engines.
        // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
        return object.index - other.index;
      }

      /**
       * Creates an array that is the composition of partially applied arguments,
       * placeholders, and provided arguments into a single array of arguments.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to prepend to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(leftLength + rangeLength),
            isUncurried = !isCurried;

        while (++leftIndex < leftLength) {
          result[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result[leftIndex++] = args[argsIndex++];
        }
        return result;
      }

      /**
       * This function is like `composeArgs` except that the arguments composition
       * is tailored for `_.partialRight`.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to append to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(rangeLength + rightLength),
            isUncurried = !isCurried;

        while (++argsIndex < rangeLength) {
          result[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result;
      }

      /**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */
      function copyArray(source, array) {
        var index = -1,
            length = source.length;

        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }

      /**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];

          var newValue = customizer
            ? customizer(object[key], source[key], key, object, source)
            : undefined$1;

          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }

      /**
       * Copies own symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }

      /**
       * Copies own and inherited symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }

      /**
       * Creates a function like `_.groupBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} [initializer] The accumulator object initializer.
       * @returns {Function} Returns the new aggregator function.
       */
      function createAggregator(setter, initializer) {
        return function(collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator,
              accumulator = initializer ? initializer() : {};

          return func(collection, setter, getIteratee(iteratee, 2), accumulator);
        };
      }

      /**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined$1,
              guard = length > 2 ? sources[2] : undefined$1;

          customizer = (assigner.length > 3 && typeof customizer == 'function')
            ? (length--, customizer)
            : undefined$1;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }

      /**
       * Creates a `baseEach` or `baseEachRight` function.
       *
       * @private
       * @param {Function} eachFunc The function to iterate over a collection.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);

          while ((fromRight ? index-- : ++index < length)) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }

      /**
       * Creates a base function for methods like `_.forIn` and `_.forOwn`.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;

          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }

      /**
       * Creates a function that wraps `func` to invoke it with the optional `this`
       * binding of `thisArg`.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @returns {Function} Returns the new wrapped function.
       */
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);

        function wrapper() {
          var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }

      /**
       * Creates a function like `_.lowerFirst`.
       *
       * @private
       * @param {string} methodName The name of the `String` case method to use.
       * @returns {Function} Returns the new case function.
       */
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);

          var strSymbols = hasUnicode(string)
            ? stringToArray(string)
            : undefined$1;

          var chr = strSymbols
            ? strSymbols[0]
            : string.charAt(0);

          var trailing = strSymbols
            ? castSlice(strSymbols, 1).join('')
            : string.slice(1);

          return chr[methodName]() + trailing;
        };
      }

      /**
       * Creates a function like `_.camelCase`.
       *
       * @private
       * @param {Function} callback The function to combine each word.
       * @returns {Function} Returns the new compounder function.
       */
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
        };
      }

      /**
       * Creates a function that produces an instance of `Ctor` regardless of
       * whether it was invoked as part of a `new` expression or by `call` or `apply`.
       *
       * @private
       * @param {Function} Ctor The constructor to wrap.
       * @returns {Function} Returns the new wrapped function.
       */
      function createCtor(Ctor) {
        return function() {
          // Use a `switch` statement to work with class constructors. See
          // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
          // for more details.
          var args = arguments;
          switch (args.length) {
            case 0: return new Ctor;
            case 1: return new Ctor(args[0]);
            case 2: return new Ctor(args[0], args[1]);
            case 3: return new Ctor(args[0], args[1], args[2]);
            case 4: return new Ctor(args[0], args[1], args[2], args[3]);
            case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype),
              result = Ctor.apply(thisBinding, args);

          // Mimic the constructor's `return` behavior.
          // See https://es5.github.io/#x13.2.2 for more details.
          return isObject(result) ? result : thisBinding;
        };
      }

      /**
       * Creates a function that wraps `func` to enable currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {number} arity The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);

        function wrapper() {
          var length = arguments.length,
              args = Array(length),
              index = length,
              placeholder = getHolder(wrapper);

          while (index--) {
            args[index] = arguments[index];
          }
          var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
            ? []
            : replaceHolders(args, placeholder);

          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
              args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }

      /**
       * Creates a `_.find` or `_.findLast` function.
       *
       * @private
       * @param {Function} findIndexFunc The function to find the collection index.
       * @returns {Function} Returns the new find function.
       */
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object(collection);
          if (!isArrayLike(collection)) {
            var iteratee = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) { return iteratee(iterable[key], key, iterable); };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
        };
      }

      /**
       * Creates a `_.flow` or `_.flowRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new flow function.
       */
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length,
              index = length,
              prereq = LodashWrapper.prototype.thru;

          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];

            var funcName = getFuncName(func),
                data = funcName == 'wrapper' ? getData(func) : undefined$1;

            if (data && isLaziable(data[0]) &&
                  data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                  !data[4].length && data[9] == 1
                ) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = (func.length == 1 && isLaziable(func))
                ? wrapper[funcName]()
                : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments,
                value = args[0];

            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index = 0,
                result = length ? funcs[index].apply(this, args) : value;

            while (++index < length) {
              result = funcs[index].call(this, result);
            }
            return result;
          };
        });
      }

      /**
       * Creates a function that wraps `func` to invoke it with optional `this`
       * binding of `thisArg`, partial application, and currying.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [partialsRight] The arguments to append to those provided
       *  to the new function.
       * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG,
            isBind = bitmask & WRAP_BIND_FLAG,
            isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
            isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
            isFlip = bitmask & WRAP_FLIP_FLAG,
            Ctor = isBindKey ? undefined$1 : createCtor(func);

        function wrapper() {
          var length = arguments.length,
              args = Array(length),
              index = length;

          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper),
                holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func, bitmask, createHybrid, wrapper.placeholder, thisArg,
              args, newHolders, argPos, ary, arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this,
              fn = isBindKey ? thisBinding[func] : func;

          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary < length) {
            args.length = ary;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }

      /**
       * Creates a function like `_.invertBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} toIteratee The function to resolve iteratees.
       * @returns {Function} Returns the new inverter function.
       */
      function createInverter(setter, toIteratee) {
        return function(object, iteratee) {
          return baseInverter(object, setter, toIteratee(iteratee), {});
        };
      }

      /**
       * Creates a function that performs a mathematical operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @param {number} [defaultValue] The value used for `undefined` arguments.
       * @returns {Function} Returns the new mathematical operation function.
       */
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result = value;
          }
          if (other !== undefined$1) {
            if (result === undefined$1) {
              return other;
            }
            if (typeof value == 'string' || typeof other == 'string') {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result = operator(value, other);
          }
          return result;
        };
      }

      /**
       * Creates a function like `_.over`.
       *
       * @private
       * @param {Function} arrayFunc The function to iterate over iteratees.
       * @returns {Function} Returns the new over function.
       */
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee) {
              return apply(iteratee, thisArg, args);
            });
          });
        });
      }

      /**
       * Creates the padding for `string` based on `length`. The `chars` string
       * is truncated if the number of characters exceeds `length`.
       *
       * @private
       * @param {number} length The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padding for `string`.
       */
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? ' ' : baseToString(chars);

        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars)
          ? castSlice(stringToArray(result), 0, length).join('')
          : result.slice(0, length);
      }

      /**
       * Creates a function that wraps `func` to invoke it with the `this` binding
       * of `thisArg` and `partials` prepended to the arguments it receives.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} partials The arguments to prepend to those provided to
       *  the new function.
       * @returns {Function} Returns the new wrapped function.
       */
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);

        function wrapper() {
          var argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array(leftLength + argsLength),
              fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }

      /**
       * Creates a `_.range` or `_.rangeRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new range function.
       */
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          // Ensure the sign of `-0` is preserved.
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }

      /**
       * Creates a function that performs a relational operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @returns {Function} Returns the new relational operation function.
       */
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == 'string' && typeof other == 'string')) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }

      /**
       * Creates a function that wraps `func` to continue currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {Function} wrapFunc The function to create the `func` wrapper.
       * @param {*} placeholder The placeholder value.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG,
            newHolders = isCurry ? holders : undefined$1,
            newHoldersRight = isCurry ? undefined$1 : holders,
            newPartials = isCurry ? partials : undefined$1,
            newPartialsRight = isCurry ? undefined$1 : partials;

        bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
          newHoldersRight, argPos, ary, arity
        ];

        var result = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result, newData);
        }
        result.placeholder = placeholder;
        return setWrapToString(result, func, bitmask);
      }

      /**
       * Creates a function like `_.round`.
       *
       * @private
       * @param {string} methodName The name of the `Math` method to use when rounding.
       * @returns {Function} Returns the new round function.
       */
      function createRound(methodName) {
        var func = Math[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            // Shift with exponential notation to avoid floating-point issues.
            // See [MDN](https://mdn.io/round#Examples) for more details.
            var pair = (toString(number) + 'e').split('e'),
                value = func(pair[0] + 'e' + (+pair[1] + precision));

            pair = (toString(value) + 'e').split('e');
            return +(pair[0] + 'e' + (+pair[1] - precision));
          }
          return func(number);
        };
      }

      /**
       * Creates a set object of `values`.
       *
       * @private
       * @param {Array} values The values to add to the set.
       * @returns {Object} Returns the new set.
       */
      var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
        return new Set(values);
      };

      /**
       * Creates a `_.toPairs` or `_.toPairsIn` function.
       *
       * @private
       * @param {Function} keysFunc The function to get the keys of a given object.
       * @returns {Function} Returns the new pairs function.
       */
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }

      /**
       * Creates a function that either curries or invokes `func` with optional
       * `this` binding and partially applied arguments.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags.
       *    1 - `_.bind`
       *    2 - `_.bindKey`
       *    4 - `_.curry` or `_.curryRight` of a bound function
       *    8 - `_.curry`
       *   16 - `_.curryRight`
       *   32 - `_.partial`
       *   64 - `_.partialRight`
       *  128 - `_.rearg`
       *  256 - `_.ary`
       *  512 - `_.flip`
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to be partially applied.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;

        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials,
              holdersRight = holders;

          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);

        var newData = [
          func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
          argPos, ary, arity
        ];

        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1
          ? (isBindKey ? 0 : func.length)
          : nativeMax(newData[9] - length, 0);

        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result = createPartial(func, bitmask, thisArg, partials);
        } else {
          result = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result, newData), func, bitmask);
      }

      /**
       * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
       * of source objects to the destination object for all destination properties
       * that resolve to `undefined`.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to assign.
       * @param {Object} object The parent object of `objValue`.
       * @returns {*} Returns the value to assign.
       */
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 ||
            (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
          return srcValue;
        }
        return objValue;
      }

      /**
       * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
       * objects into destination objects that are passed thru.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to merge.
       * @param {Object} object The parent object of `objValue`.
       * @param {Object} source The parent object of `srcValue`.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       * @returns {*} Returns the value to assign.
       */
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          // Recursively merge objects and arrays (susceptible to call stack limits).
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack['delete'](srcValue);
        }
        return objValue;
      }

      /**
       * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
       * objects.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {string} key The key of the property to inspect.
       * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
       */
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }

      /**
       * A specialized version of `baseIsEqualDeep` for arrays with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Array} array The array to compare.
       * @param {Array} other The other array to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `array` and `other` objects.
       * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
       */
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            arrLength = array.length,
            othLength = other.length;

        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        // Check that cyclic values are equal.
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1,
            result = true,
            seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

        stack.set(array, other);
        stack.set(other, array);

        // Ignore non-index properties.
        while (++index < arrLength) {
          var arrValue = array[index],
              othValue = other[index];

          if (customizer) {
            var compared = isPartial
              ? customizer(othValue, arrValue, index, other, array, stack)
              : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          // Recursively compare arrays (susceptible to call stack limits).
          if (seen) {
            if (!arraySome(other, function(othValue, othIndex) {
                  if (!cacheHas(seen, othIndex) &&
                      (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
              result = false;
              break;
            }
          } else if (!(
                arrValue === othValue ||
                  equalFunc(arrValue, othValue, bitmask, customizer, stack)
              )) {
            result = false;
            break;
          }
        }
        stack['delete'](array);
        stack['delete'](other);
        return result;
      }

      /**
       * A specialized version of `baseIsEqualDeep` for comparing objects of
       * the same `toStringTag`.
       *
       * **Note:** This function only supports comparing values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {string} tag The `toStringTag` of the objects to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if ((object.byteLength != other.byteLength) ||
                (object.byteOffset != other.byteOffset)) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;

          case arrayBufferTag:
            if ((object.byteLength != other.byteLength) ||
                !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
              return false;
            }
            return true;

          case boolTag:
          case dateTag:
          case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return eq(+object, +other);

          case errorTag:
            return object.name == other.name && object.message == other.message;

          case regexpTag:
          case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == (other + '');

          case mapTag:
            var convert = mapToArray;

          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);

            if (object.size != other.size && !isPartial) {
              return false;
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;

            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack['delete'](object);
            return result;

          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }

      /**
       * A specialized version of `baseIsEqualDeep` for objects with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;

        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        // Check that cyclic values are equal.
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);

        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key],
              othValue = other[key];

          if (customizer) {
            var compared = isPartial
              ? customizer(othValue, objValue, key, other, object, stack)
              : customizer(objValue, othValue, key, object, other, stack);
          }
          // Recursively compare objects (susceptible to call stack limits).
          if (!(compared === undefined$1
                ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                : compared
              )) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == 'constructor');
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor,
              othCtor = other.constructor;

          // Non `Object` object instances with different constructors are not equal.
          if (objCtor != othCtor &&
              ('constructor' in object && 'constructor' in other) &&
              !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack['delete'](object);
        stack['delete'](other);
        return result;
      }

      /**
       * A specialized version of `baseRest` which flattens the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + '');
      }

      /**
       * Creates an array of own enumerable property names and symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }

      /**
       * Creates an array of own and inherited enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }

      /**
       * Gets metadata for `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {*} Returns the metadata for `func`.
       */
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };

      /**
       * Gets the name of `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {string} Returns the function name.
       */
      function getFuncName(func) {
        var result = (func.name + ''),
            array = realNames[result],
            length = hasOwnProperty.call(realNames, result) ? array.length : 0;

        while (length--) {
          var data = array[length],
              otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result;
      }

      /**
       * Gets the argument placeholder value for `func`.
       *
       * @private
       * @param {Function} func The function to inspect.
       * @returns {*} Returns the placeholder value.
       */
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
        return object.placeholder;
      }

      /**
       * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
       * this function returns the custom method, otherwise it returns `baseIteratee`.
       * If arguments are provided, the chosen function is invoked with them and
       * its result is returned.
       *
       * @private
       * @param {*} [value] The value to convert to an iteratee.
       * @param {number} [arity] The arity of the created iteratee.
       * @returns {Function} Returns the chosen function or its result.
       */
      function getIteratee() {
        var result = lodash.iteratee || iteratee;
        result = result === iteratee ? baseIteratee : result;
        return arguments.length ? result(arguments[0], arguments[1]) : result;
      }

      /**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key)
          ? data[typeof key == 'string' ? 'string' : 'hash']
          : data.map;
      }

      /**
       * Gets the property names, values, and compare flags of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the match data of `object`.
       */
      function getMatchData(object) {
        var result = keys(object),
            length = result.length;

        while (length--) {
          var key = result[length],
              value = object[key];

          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }

      /**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }

      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }

      /**
       * Creates an array of the own enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };

      /**
       * Creates an array of the own and inherited enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };

      /**
       * Gets the `toStringTag` of `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */
      var getTag = baseGetTag;

      // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
      if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
          (Map && getTag(new Map) != mapTag) ||
          (Promise && getTag(Promise.resolve()) != promiseTag) ||
          (Set && getTag(new Set) != setTag) ||
          (WeakMap && getTag(new WeakMap) != weakMapTag)) {
        getTag = function(value) {
          var result = baseGetTag(value),
              Ctor = result == objectTag ? value.constructor : undefined$1,
              ctorString = Ctor ? toSource(Ctor) : '';

          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString: return dataViewTag;
              case mapCtorString: return mapTag;
              case promiseCtorString: return promiseTag;
              case setCtorString: return setTag;
              case weakMapCtorString: return weakMapTag;
            }
          }
          return result;
        };
      }

      /**
       * Gets the view, applying any `transforms` to the `start` and `end` positions.
       *
       * @private
       * @param {number} start The start of the view.
       * @param {number} end The end of the view.
       * @param {Array} transforms The transformations to apply to the view.
       * @returns {Object} Returns an object containing the `start` and `end`
       *  positions of the view.
       */
      function getView(start, end, transforms) {
        var index = -1,
            length = transforms.length;

        while (++index < length) {
          var data = transforms[index],
              size = data.size;

          switch (data.type) {
            case 'drop':      start += size; break;
            case 'dropRight': end -= size; break;
            case 'take':      end = nativeMin(end, start + size); break;
            case 'takeRight': start = nativeMax(start, end - size); break;
          }
        }
        return { 'start': start, 'end': end };
      }

      /**
       * Extracts wrapper details from the `source` body comment.
       *
       * @private
       * @param {string} source The source to inspect.
       * @returns {Array} Returns the wrapper details.
       */
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }

      /**
       * Checks if `path` exists on `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @param {Function} hasFunc The function to check properties.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       */
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);

        var index = -1,
            length = path.length,
            result = false;

        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) &&
          (isArray(object) || isArguments(object));
      }

      /**
       * Initializes an array clone.
       *
       * @private
       * @param {Array} array The array to clone.
       * @returns {Array} Returns the initialized clone.
       */
      function initCloneArray(array) {
        var length = array.length,
            result = new array.constructor(length);

        // Add properties assigned by `RegExp#exec`.
        if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }

      /**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */
      function initCloneObject(object) {
        return (typeof object.constructor == 'function' && !isPrototype(object))
          ? baseCreate(getPrototype(object))
          : {};
      }

      /**
       * Initializes an object clone based on its `toStringTag`.
       *
       * **Note:** This function only supports cloning values with tags of
       * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
       *
       * @private
       * @param {Object} object The object to clone.
       * @param {string} tag The `toStringTag` of the object to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the initialized clone.
       */
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);

          case boolTag:
          case dateTag:
            return new Ctor(+object);

          case dataViewTag:
            return cloneDataView(object, isDeep);

          case float32Tag: case float64Tag:
          case int8Tag: case int16Tag: case int32Tag:
          case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
            return cloneTypedArray(object, isDeep);

          case mapTag:
            return new Ctor;

          case numberTag:
          case stringTag:
            return new Ctor(object);

          case regexpTag:
            return cloneRegExp(object);

          case setTag:
            return new Ctor;

          case symbolTag:
            return cloneSymbol(object);
        }
      }

      /**
       * Inserts wrapper `details` in a comment at the top of the `source` body.
       *
       * @private
       * @param {string} source The source to modify.
       * @returns {Array} details The details to insert.
       * @returns {string} Returns the modified source.
       */
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
        details = details.join(length > 2 ? ', ' : ' ');
        return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
      }

      /**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) ||
          !!(spreadableSymbol && value && value[spreadableSymbol]);
      }

      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;

        return !!length &&
          (type == 'number' ||
            (type != 'symbol' && reIsUint.test(value))) &&
              (value > -1 && value % 1 == 0 && value < length);
      }

      /**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == 'number'
              ? (isArrayLike(object) && isIndex(index, object.length))
              : (type == 'string' && index in object)
            ) {
          return eq(object[index], value);
        }
        return false;
      }

      /**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == 'number' || type == 'symbol' || type == 'boolean' ||
            value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
          (object != null && value in Object(object));
      }

      /**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */
      function isKeyable(value) {
        var type = typeof value;
        return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
          ? (value !== '__proto__')
          : (value === null);
      }

      /**
       * Checks if `func` has a lazy counterpart.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
       *  else `false`.
       */
      function isLaziable(func) {
        var funcName = getFuncName(func),
            other = lodash[funcName];

        if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }

      /**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */
      function isMasked(func) {
        return !!maskSrcKey && (maskSrcKey in func);
      }

      /**
       * Checks if `func` is capable of being masked.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
       */
      var isMaskable = coreJsData ? isFunction : stubFalse;

      /**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */
      function isPrototype(value) {
        var Ctor = value && value.constructor,
            proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

        return value === proto;
      }

      /**
       * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` if suitable for strict
       *  equality comparisons, else `false`.
       */
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }

      /**
       * A specialized version of `matchesProperty` for source values suitable
       * for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue &&
            (srcValue !== undefined$1 || (key in Object(object)));
        };
      }

      /**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });

        var cache = result.cache;
        return result;
      }

      /**
       * Merges the function metadata of `source` into `data`.
       *
       * Merging metadata reduces the number of wrappers used to invoke a function.
       * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
       * may be applied regardless of execution order. Methods like `_.ary` and
       * `_.rearg` modify function arguments, making the order in which they are
       * executed important, preventing the merging of metadata. However, we make
       * an exception for a safe combined case where curried functions have `_.ary`
       * and or `_.rearg` applied.
       *
       * @private
       * @param {Array} data The destination metadata.
       * @param {Array} source The source metadata.
       * @returns {Array} Returns `data`.
       */
      function mergeData(data, source) {
        var bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask,
            isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

        var isCombo =
          ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
          ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
          ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

        // Exit early if metadata can't be merged.
        if (!(isCommon || isCombo)) {
          return data;
        }
        // Use source `thisArg` if available.
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          // Set when currying a bound function.
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        // Compose partial arguments.
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        // Compose partial right arguments.
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        // Use source `argPos` if available.
        value = source[7];
        if (value) {
          data[7] = value;
        }
        // Use source `ary` if it's smaller.
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        // Use source `arity` if one is not provided.
        if (data[9] == null) {
          data[9] = source[9];
        }
        // Use source `func` and merge bitmasks.
        data[0] = source[0];
        data[1] = newBitmask;

        return data;
      }

      /**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }

      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }

      /**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */
      function overRest(func, start, transform) {
        start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
        return function() {
          var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }

      /**
       * Gets the parent value at `path` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} path The path to get the parent value of.
       * @returns {*} Returns the parent value.
       */
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }

      /**
       * Reorder `array` according to the specified indexes where the element at
       * the first index is assigned as the first element, the element at
       * the second index is assigned as the second element, and so on.
       *
       * @private
       * @param {Array} array The array to reorder.
       * @param {Array} indexes The arranged array indexes.
       * @returns {Array} Returns `array`.
       */
      function reorder(array, indexes) {
        var arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = copyArray(array);

        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array;
      }

      /**
       * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function safeGet(object, key) {
        if (key === 'constructor' && typeof object[key] === 'function') {
          return;
        }

        if (key == '__proto__') {
          return;
        }

        return object[key];
      }

      /**
       * Sets metadata for `func`.
       *
       * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
       * period of time, it will trip its breaker and transition to an identity
       * function to avoid garbage collection pauses in V8. See
       * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
       * for more details.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */
      var setData = shortOut(baseSetData);

      /**
       * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @returns {number|Object} Returns the timer id or timeout object.
       */
      var setTimeout = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };

      /**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */
      var setToString = shortOut(baseSetToString);

      /**
       * Sets the `toString` method of `wrapper` to mimic the source of `reference`
       * with wrapper details in a comment at the top of the source body.
       *
       * @private
       * @param {Function} wrapper The function to modify.
       * @param {Function} reference The reference function.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Function} Returns `wrapper`.
       */
      function setWrapToString(wrapper, reference, bitmask) {
        var source = (reference + '');
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }

      /**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */
      function shortOut(func) {
        var count = 0,
            lastCalled = 0;

        return function() {
          var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);

          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }

      /**
       * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @param {number} [size=array.length] The size of `array`.
       * @returns {Array} Returns `array`.
       */
      function shuffleSelf(array, size) {
        var index = -1,
            length = array.length,
            lastIndex = length - 1;

        size = size === undefined$1 ? length : size;
        while (++index < size) {
          var rand = baseRandom(index, lastIndex),
              value = array[rand];

          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size;
        return array;
      }

      /**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46 /* . */) {
          result.push('');
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
        });
        return result;
      });

      /**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */
      function toKey(value) {
        if (typeof value == 'string' || isSymbol(value)) {
          return value;
        }
        var result = (value + '');
        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
      }

      /**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}
          try {
            return (func + '');
          } catch (e) {}
        }
        return '';
      }

      /**
       * Updates wrapper `details` based on `bitmask` flags.
       *
       * @private
       * @returns {Array} details The details to modify.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Array} Returns `details`.
       */
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = '_.' + pair[0];
          if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }

      /**
       * Creates a clone of `wrapper`.
       *
       * @private
       * @param {Object} wrapper The wrapper to clone.
       * @returns {Object} Returns the cloned wrapper.
       */
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result.__actions__ = copyArray(wrapper.__actions__);
        result.__index__  = wrapper.__index__;
        result.__values__ = wrapper.__values__;
        return result;
      }

      /*------------------------------------------------------------------------*/

      /**
       * Creates an array of elements split into groups the length of `size`.
       * If `array` can't be split evenly, the final chunk will be the remaining
       * elements.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to process.
       * @param {number} [size=1] The length of each chunk
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the new array of chunks.
       * @example
       *
       * _.chunk(['a', 'b', 'c', 'd'], 2);
       * // => [['a', 'b'], ['c', 'd']]
       *
       * _.chunk(['a', 'b', 'c', 'd'], 3);
       * // => [['a', 'b', 'c'], ['d']]
       */
      function chunk(array, size, guard) {
        if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
          size = 1;
        } else {
          size = nativeMax(toInteger(size), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size < 1) {
          return [];
        }
        var index = 0,
            resIndex = 0,
            result = Array(nativeCeil(length / size));

        while (index < length) {
          result[resIndex++] = baseSlice(array, index, (index += size));
        }
        return result;
      }

      /**
       * Creates an array with all falsey values removed. The values `false`, `null`,
       * `0`, `""`, `undefined`, and `NaN` are falsey.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to compact.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.compact([0, 1, false, 2, '', 3]);
       * // => [1, 2, 3]
       */
      function compact(array) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (value) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      /**
       * Creates a new array concatenating `array` with any additional arrays
       * and/or values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to concatenate.
       * @param {...*} [values] The values to concatenate.
       * @returns {Array} Returns the new concatenated array.
       * @example
       *
       * var array = [1];
       * var other = _.concat(array, 2, [3], [[4]]);
       *
       * console.log(other);
       * // => [1, 2, 3, [4]]
       *
       * console.log(array);
       * // => [1]
       */
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array(length - 1),
            array = arguments[0],
            index = length;

        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }

      /**
       * Creates an array of `array` values not included in the other given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * **Note:** Unlike `_.pullAll`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.without, _.xor
       * @example
       *
       * _.difference([2, 1], [2, 3]);
       * // => [1]
       */
      var difference = baseRest(function(array, values) {
        return isArrayLikeObject(array)
          ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
          : [];
      });

      /**
       * This method is like `_.difference` except that it accepts `iteratee` which
       * is invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */
      var differenceBy = baseRest(function(array, values) {
        var iteratee = last(values);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined$1;
        }
        return isArrayLikeObject(array)
          ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
          : [];
      });

      /**
       * This method is like `_.difference` except that it accepts `comparator`
       * which is invoked to compare elements of `array` to `values`. The order and
       * references of result values are determined by the first array. The comparator
       * is invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       *
       * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }]
       */
      var differenceWith = baseRest(function(array, values) {
        var comparator = last(values);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array)
          ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
          : [];
      });

      /**
       * Creates a slice of `array` with `n` elements dropped from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.drop([1, 2, 3]);
       * // => [2, 3]
       *
       * _.drop([1, 2, 3], 2);
       * // => [3]
       *
       * _.drop([1, 2, 3], 5);
       * // => []
       *
       * _.drop([1, 2, 3], 0);
       * // => [1, 2, 3]
       */
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = (guard || n === undefined$1) ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }

      /**
       * Creates a slice of `array` with `n` elements dropped from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropRight([1, 2, 3]);
       * // => [1, 2]
       *
       * _.dropRight([1, 2, 3], 2);
       * // => [1]
       *
       * _.dropRight([1, 2, 3], 5);
       * // => []
       *
       * _.dropRight([1, 2, 3], 0);
       * // => [1, 2, 3]
       */
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = (guard || n === undefined$1) ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }

      /**
       * Creates a slice of `array` excluding elements dropped from the end.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.dropRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropRightWhile(users, ['active', false]);
       * // => objects for ['barney']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropRightWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */
      function dropRightWhile(array, predicate) {
        return (array && array.length)
          ? baseWhile(array, getIteratee(predicate, 3), true, true)
          : [];
      }

      /**
       * Creates a slice of `array` excluding elements dropped from the beginning.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.dropWhile(users, function(o) { return !o.active; });
       * // => objects for ['pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropWhile(users, ['active', false]);
       * // => objects for ['pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */
      function dropWhile(array, predicate) {
        return (array && array.length)
          ? baseWhile(array, getIteratee(predicate, 3), true)
          : [];
      }

      /**
       * Fills elements of `array` with `value` from `start` up to, but not
       * including, `end`.
       *
       * **Note:** This method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Array
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.fill(array, 'a');
       * console.log(array);
       * // => ['a', 'a', 'a']
       *
       * _.fill(Array(3), 2);
       * // => [2, 2, 2]
       *
       * _.fill([4, 6, 8, 10], '*', 1, 3);
       * // => [4, '*', '*', 10]
       */
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }

      /**
       * This method is like `_.find` except that it returns the index of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.findIndex(users, function(o) { return o.user == 'barney'; });
       * // => 0
       *
       * // The `_.matches` iteratee shorthand.
       * _.findIndex(users, { 'user': 'fred', 'active': false });
       * // => 1
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findIndex(users, ['active', false]);
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.findIndex(users, 'active');
       * // => 2
       */
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }

      /**
       * This method is like `_.findIndex` except that it iterates over elements
       * of `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
       * // => 2
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastIndex(users, { 'user': 'barney', 'active': true });
       * // => 0
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastIndex(users, ['active', false]);
       * // => 2
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastIndex(users, 'active');
       * // => 0
       */
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = fromIndex < 0
            ? nativeMax(length + index, 0)
            : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }

      /**
       * Flattens `array` a single level deep.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, [3, [4]], 5]]);
       * // => [1, 2, [3, [4]], 5]
       */
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }

      /**
       * Recursively flattens `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flattenDeep([1, [2, [3, [4]], 5]]);
       * // => [1, 2, 3, 4, 5]
       */
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }

      /**
       * Recursively flatten `array` up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * var array = [1, [2, [3, [4]], 5]];
       *
       * _.flattenDepth(array, 1);
       * // => [1, 2, [3, [4]], 5]
       *
       * _.flattenDepth(array, 2);
       * // => [1, 2, 3, [4], 5]
       */
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }

      /**
       * The inverse of `_.toPairs`; this method returns an object composed
       * from key-value `pairs`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} pairs The key-value pairs.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.fromPairs([['a', 1], ['b', 2]]);
       * // => { 'a': 1, 'b': 2 }
       */
      function fromPairs(pairs) {
        var index = -1,
            length = pairs == null ? 0 : pairs.length,
            result = {};

        while (++index < length) {
          var pair = pairs[index];
          result[pair[0]] = pair[1];
        }
        return result;
      }

      /**
       * Gets the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias first
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the first element of `array`.
       * @example
       *
       * _.head([1, 2, 3]);
       * // => 1
       *
       * _.head([]);
       * // => undefined
       */
      function head(array) {
        return (array && array.length) ? array[0] : undefined$1;
      }

      /**
       * Gets the index at which the first occurrence of `value` is found in `array`
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. If `fromIndex` is negative, it's used as the
       * offset from the end of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.indexOf([1, 2, 1, 2], 2);
       * // => 1
       *
       * // Search from the `fromIndex`.
       * _.indexOf([1, 2, 1, 2], 2, 2);
       * // => 3
       */
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }

      /**
       * Gets all but the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.initial([1, 2, 3]);
       * // => [1, 2]
       */
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }

      /**
       * Creates an array of unique values that are included in all given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersection([2, 1], [2, 3]);
       * // => [2]
       */
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return (mapped.length && mapped[0] === arrays[0])
          ? baseIntersection(mapped)
          : [];
      });

      /**
       * This method is like `_.intersection` except that it accepts `iteratee`
       * which is invoked for each element of each `arrays` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [2.1]
       *
       * // The `_.property` iteratee shorthand.
       * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }]
       */
      var intersectionBy = baseRest(function(arrays) {
        var iteratee = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);

        if (iteratee === last(mapped)) {
          iteratee = undefined$1;
        } else {
          mapped.pop();
        }
        return (mapped.length && mapped[0] === arrays[0])
          ? baseIntersection(mapped, getIteratee(iteratee, 2))
          : [];
      });

      /**
       * This method is like `_.intersection` except that it accepts `comparator`
       * which is invoked to compare elements of `arrays`. The order and references
       * of result values are determined by the first array. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.intersectionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }]
       */
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);

        comparator = typeof comparator == 'function' ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return (mapped.length && mapped[0] === arrays[0])
          ? baseIntersection(mapped, undefined$1, comparator)
          : [];
      });

      /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
      function join(array, separator) {
        return array == null ? '' : nativeJoin.call(array, separator);
      }

      /**
       * Gets the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the last element of `array`.
       * @example
       *
       * _.last([1, 2, 3]);
       * // => 3
       */
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }

      /**
       * This method is like `_.indexOf` except that it iterates over elements of
       * `array` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.lastIndexOf([1, 2, 1, 2], 2);
       * // => 3
       *
       * // Search from the `fromIndex`.
       * _.lastIndexOf([1, 2, 1, 2], 2, 2);
       * // => 1
       */
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value
          ? strictLastIndexOf(array, value, index)
          : baseFindIndex(array, baseIsNaN, index, true);
      }

      /**
       * Gets the element at index `n` of `array`. If `n` is negative, the nth
       * element from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.11.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=0] The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       *
       * _.nth(array, 1);
       * // => 'b'
       *
       * _.nth(array, -2);
       * // => 'c';
       */
      function nth(array, n) {
        return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
      }

      /**
       * Removes all given values from `array` using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
       * to remove elements from an array by predicate.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...*} [values] The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pull(array, 'a', 'c');
       * console.log(array);
       * // => ['b', 'b']
       */
      var pull = baseRest(pullAll);

      /**
       * This method is like `_.pull` except that it accepts an array of values to remove.
       *
       * **Note:** Unlike `_.difference`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pullAll(array, ['a', 'c']);
       * console.log(array);
       * // => ['b', 'b']
       */
      function pullAll(array, values) {
        return (array && array.length && values && values.length)
          ? basePullAll(array, values)
          : array;
      }

      /**
       * This method is like `_.pullAll` except that it accepts `iteratee` which is
       * invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The iteratee is invoked with one argument: (value).
       *
       * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
       *
       * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
       * console.log(array);
       * // => [{ 'x': 2 }]
       */
      function pullAllBy(array, values, iteratee) {
        return (array && array.length && values && values.length)
          ? basePullAll(array, values, getIteratee(iteratee, 2))
          : array;
      }

      /**
       * This method is like `_.pullAll` except that it accepts `comparator` which
       * is invoked to compare elements of `array` to `values`. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
       *
       * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
       * console.log(array);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
       */
      function pullAllWith(array, values, comparator) {
        return (array && array.length && values && values.length)
          ? basePullAll(array, values, undefined$1, comparator)
          : array;
      }

      /**
       * Removes elements from `array` corresponding to `indexes` and returns an
       * array of removed elements.
       *
       * **Note:** Unlike `_.at`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...(number|number[])} [indexes] The indexes of elements to remove.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       * var pulled = _.pullAt(array, [1, 3]);
       *
       * console.log(array);
       * // => ['a', 'c']
       *
       * console.log(pulled);
       * // => ['b', 'd']
       */
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length,
            result = baseAt(array, indexes);

        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));

        return result;
      });

      /**
       * Removes all elements from `array` that `predicate` returns truthy for
       * and returns an array of the removed elements. The predicate is invoked
       * with three arguments: (value, index, array).
       *
       * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
       * to pull elements from an array by value.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = [1, 2, 3, 4];
       * var evens = _.remove(array, function(n) {
       *   return n % 2 == 0;
       * });
       *
       * console.log(array);
       * // => [1, 3]
       *
       * console.log(evens);
       * // => [2, 4]
       */
      function remove(array, predicate) {
        var result = [];
        if (!(array && array.length)) {
          return result;
        }
        var index = -1,
            indexes = [],
            length = array.length;

        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result;
      }

      /**
       * Reverses `array` so that the first element becomes the last, the second
       * element becomes the second to last, and so on.
       *
       * **Note:** This method mutates `array` and is based on
       * [`Array#reverse`](https://mdn.io/Array/reverse).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.reverse(array);
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }

      /**
       * Creates a slice of `array` from `start` up to, but not including, `end`.
       *
       * **Note:** This method is used instead of
       * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
       * returned.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        }
        else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }

      /**
       * Uses a binary search to determine the lowest index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedIndex([30, 50], 40);
       * // => 1
       */
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }

      /**
       * This method is like `_.sortedIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
       * // => 0
       */
      function sortedIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
      }

      /**
       * This method is like `_.indexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
       * // => 1
       */
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * This method is like `_.sortedIndex` except that it returns the highest
       * index at which `value` should be inserted into `array` in order to
       * maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
       * // => 4
       */
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }

      /**
       * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 1
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
       * // => 1
       */
      function sortedLastIndexBy(array, value, iteratee) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
      }

      /**
       * This method is like `_.lastIndexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
       * // => 3
       */
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * This method is like `_.uniq` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniq([1, 1, 2]);
       * // => [1, 2]
       */
      function sortedUniq(array) {
        return (array && array.length)
          ? baseSortedUniq(array)
          : [];
      }

      /**
       * This method is like `_.uniqBy` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
       * // => [1.1, 2.3]
       */
      function sortedUniqBy(array, iteratee) {
        return (array && array.length)
          ? baseSortedUniq(array, getIteratee(iteratee, 2))
          : [];
      }

      /**
       * Gets all but the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.tail([1, 2, 3]);
       * // => [2, 3]
       */
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }

      /**
       * Creates a slice of `array` with `n` elements taken from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.take([1, 2, 3]);
       * // => [1]
       *
       * _.take([1, 2, 3], 2);
       * // => [1, 2]
       *
       * _.take([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.take([1, 2, 3], 0);
       * // => []
       */
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = (guard || n === undefined$1) ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }

      /**
       * Creates a slice of `array` with `n` elements taken from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeRight([1, 2, 3]);
       * // => [3]
       *
       * _.takeRight([1, 2, 3], 2);
       * // => [2, 3]
       *
       * _.takeRight([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.takeRight([1, 2, 3], 0);
       * // => []
       */
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = (guard || n === undefined$1) ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }

      /**
       * Creates a slice of `array` with elements taken from the end. Elements are
       * taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.takeRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeRightWhile(users, ['active', false]);
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeRightWhile(users, 'active');
       * // => []
       */
      function takeRightWhile(array, predicate) {
        return (array && array.length)
          ? baseWhile(array, getIteratee(predicate, 3), false, true)
          : [];
      }

      /**
       * Creates a slice of `array` with elements taken from the beginning. Elements
       * are taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.takeWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeWhile(users, ['active', false]);
       * // => objects for ['barney', 'fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeWhile(users, 'active');
       * // => []
       */
      function takeWhile(array, predicate) {
        return (array && array.length)
          ? baseWhile(array, getIteratee(predicate, 3))
          : [];
      }

      /**
       * Creates an array of unique values, in order, from all given arrays using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.union([2], [1, 2]);
       * // => [2, 1]
       */
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });

      /**
       * This method is like `_.union` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which uniqueness is computed. Result values are chosen from the first
       * array in which the value occurs. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.unionBy([2.1], [1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */
      var unionBy = baseRest(function(arrays) {
        var iteratee = last(arrays);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
      });

      /**
       * This method is like `_.union` except that it accepts `comparator` which
       * is invoked to compare elements of `arrays`. Result values are chosen from
       * the first array in which the value occurs. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.unionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == 'function' ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });

      /**
       * Creates a duplicate-free version of an array, using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons, in which only the first occurrence of each element
       * is kept. The order of result values is determined by the order they occur
       * in the array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniq([2, 1, 2]);
       * // => [2, 1]
       */
      function uniq(array) {
        return (array && array.length) ? baseUniq(array) : [];
      }

      /**
       * This method is like `_.uniq` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * uniqueness is computed. The order of result values is determined by the
       * order they occur in the array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */
      function uniqBy(array, iteratee) {
        return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
      }

      /**
       * This method is like `_.uniq` except that it accepts `comparator` which
       * is invoked to compare elements of `array`. The order of result values is
       * determined by the order they occur in the array.The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.uniqWith(objects, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
       */
      function uniqWith(array, comparator) {
        comparator = typeof comparator == 'function' ? comparator : undefined$1;
        return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
      }

      /**
       * This method is like `_.zip` except that it accepts an array of grouped
       * elements and creates an array regrouping the elements to their pre-zip
       * configuration.
       *
       * @static
       * @memberOf _
       * @since 1.2.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       *
       * _.unzip(zipped);
       * // => [['a', 'b'], [1, 2], [true, false]]
       */
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }

      /**
       * This method is like `_.unzip` except that it accepts `iteratee` to specify
       * how regrouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  regrouped values.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
       * // => [[1, 10, 100], [2, 20, 200]]
       *
       * _.unzipWith(zipped, _.add);
       * // => [3, 30, 300]
       */
      function unzipWith(array, iteratee) {
        if (!(array && array.length)) {
          return [];
        }
        var result = unzip(array);
        if (iteratee == null) {
          return result;
        }
        return arrayMap(result, function(group) {
          return apply(iteratee, undefined$1, group);
        });
      }

      /**
       * Creates an array excluding all given values using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.pull`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...*} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.xor
       * @example
       *
       * _.without([2, 1, 2, 3], 1, 2);
       * // => [3]
       */
      var without = baseRest(function(array, values) {
        return isArrayLikeObject(array)
          ? baseDifference(array, values)
          : [];
      });

      /**
       * Creates an array of unique values that is the
       * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
       * of the given arrays. The order of result values is determined by the order
       * they occur in the arrays.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.without
       * @example
       *
       * _.xor([2, 1], [2, 3]);
       * // => [1, 3]
       */
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });

      /**
       * This method is like `_.xor` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which by which they're compared. The order of result values is determined
       * by the order they occur in the arrays. The iteratee is invoked with one
       * argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2, 3.4]
       *
       * // The `_.property` iteratee shorthand.
       * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */
      var xorBy = baseRest(function(arrays) {
        var iteratee = last(arrays);
        if (isArrayLikeObject(iteratee)) {
          iteratee = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
      });

      /**
       * This method is like `_.xor` except that it accepts `comparator` which is
       * invoked to compare elements of `arrays`. The order of result values is
       * determined by the order they occur in the arrays. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.xorWith(objects, others, _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == 'function' ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });

      /**
       * Creates an array of grouped elements, the first of which contains the
       * first elements of the given arrays, the second of which contains the
       * second elements of the given arrays, and so on.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       */
      var zip = baseRest(unzip);

      /**
       * This method is like `_.fromPairs` except that it accepts two arrays,
       * one of property identifiers and one of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 0.4.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObject(['a', 'b'], [1, 2]);
       * // => { 'a': 1, 'b': 2 }
       */
      function zipObject(props, values) {
        return baseZipObject(props || [], values || [], assignValue);
      }

      /**
       * This method is like `_.zipObject` except that it supports property paths.
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
       * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
       */
      function zipObjectDeep(props, values) {
        return baseZipObject(props || [], values || [], baseSet);
      }

      /**
       * This method is like `_.zip` except that it accepts `iteratee` to specify
       * how grouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  grouped values.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
       *   return a + b + c;
       * });
       * // => [111, 222]
       */
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length,
            iteratee = length > 1 ? arrays[length - 1] : undefined$1;

        iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
        return unzipWith(arrays, iteratee);
      });

      /*------------------------------------------------------------------------*/

      /**
       * Creates a `lodash` wrapper instance that wraps `value` with explicit method
       * chain sequences enabled. The result of such sequences must be unwrapped
       * with `_#value`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Seq
       * @param {*} value The value to wrap.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36 },
       *   { 'user': 'fred',    'age': 40 },
       *   { 'user': 'pebbles', 'age': 1 }
       * ];
       *
       * var youngest = _
       *   .chain(users)
       *   .sortBy('age')
       *   .map(function(o) {
       *     return o.user + ' is ' + o.age;
       *   })
       *   .head()
       *   .value();
       * // => 'pebbles is 1'
       */
      function chain(value) {
        var result = lodash(value);
        result.__chain__ = true;
        return result;
      }

      /**
       * This method invokes `interceptor` and returns `value`. The interceptor
       * is invoked with one argument; (value). The purpose of this method is to
       * "tap into" a method chain sequence in order to modify intermediate results.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns `value`.
       * @example
       *
       * _([1, 2, 3])
       *  .tap(function(array) {
       *    // Mutate input array.
       *    array.pop();
       *  })
       *  .reverse()
       *  .value();
       * // => [2, 1]
       */
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }

      /**
       * This method is like `_.tap` except that it returns the result of `interceptor`.
       * The purpose of this method is to "pass thru" values replacing intermediate
       * results in a method chain sequence.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns the result of `interceptor`.
       * @example
       *
       * _('  abc  ')
       *  .chain()
       *  .trim()
       *  .thru(function(value) {
       *    return [value];
       *  })
       *  .value();
       * // => ['abc']
       */
      function thru(value, interceptor) {
        return interceptor(value);
      }

      /**
       * This method is the wrapper version of `_.at`.
       *
       * @name at
       * @memberOf _
       * @since 1.0.0
       * @category Seq
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _(object).at(['a[0].b.c', 'a[1]']).value();
       * // => [3, 4]
       */
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length,
            start = length ? paths[0] : 0,
            value = this.__wrapped__,
            interceptor = function(object) { return baseAt(object, paths); };

        if (length > 1 || this.__actions__.length ||
            !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          'func': thru,
          'args': [interceptor],
          'thisArg': undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });

      /**
       * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
       *
       * @name chain
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * // A sequence without explicit chaining.
       * _(users).head();
       * // => { 'user': 'barney', 'age': 36 }
       *
       * // A sequence with explicit chaining.
       * _(users)
       *   .chain()
       *   .head()
       *   .pick('user')
       *   .value();
       * // => { 'user': 'barney' }
       */
      function wrapperChain() {
        return chain(this);
      }

      /**
       * Executes the chain sequence and returns the wrapped result.
       *
       * @name commit
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2];
       * var wrapped = _(array).push(3);
       *
       * console.log(array);
       * // => [1, 2]
       *
       * wrapped = wrapped.commit();
       * console.log(array);
       * // => [1, 2, 3]
       *
       * wrapped.last();
       * // => 3
       *
       * console.log(array);
       * // => [1, 2, 3]
       */
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }

      /**
       * Gets the next value on a wrapped object following the
       * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
       *
       * @name next
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the next iterator value.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 1 }
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 2 }
       *
       * wrapped.next();
       * // => { 'done': true, 'value': undefined }
       */
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length,
            value = done ? undefined$1 : this.__values__[this.__index__++];

        return { 'done': done, 'value': value };
      }

      /**
       * Enables the wrapper to be iterable.
       *
       * @name Symbol.iterator
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the wrapper object.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped[Symbol.iterator]() === wrapped;
       * // => true
       *
       * Array.from(wrapped);
       * // => [1, 2]
       */
      function wrapperToIterator() {
        return this;
      }

      /**
       * Creates a clone of the chain sequence planting `value` as the wrapped value.
       *
       * @name plant
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @param {*} value The value to plant.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2]).map(square);
       * var other = wrapped.plant([3, 4]);
       *
       * other.value();
       * // => [9, 16]
       *
       * wrapped.value();
       * // => [1, 4]
       */
      function wrapperPlant(value) {
        var result,
            parent = this;

        while (parent instanceof baseLodash) {
          var clone = wrapperClone(parent);
          clone.__index__ = 0;
          clone.__values__ = undefined$1;
          if (result) {
            previous.__wrapped__ = clone;
          } else {
            result = clone;
          }
          var previous = clone;
          parent = parent.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result;
      }

      /**
       * This method is the wrapper version of `_.reverse`.
       *
       * **Note:** This method mutates the wrapped array.
       *
       * @name reverse
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _(array).reverse().value()
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            'func': thru,
            'args': [reverse],
            'thisArg': undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }

      /**
       * Executes the chain sequence to resolve the unwrapped value.
       *
       * @name value
       * @memberOf _
       * @since 0.1.0
       * @alias toJSON, valueOf
       * @category Seq
       * @returns {*} Returns the resolved unwrapped value.
       * @example
       *
       * _([1, 2, 3]).value();
       * // => [1, 2, 3]
       */
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }

      /*------------------------------------------------------------------------*/

      /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the number of times the key was returned by `iteratee`. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.countBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': 1, '6': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.countBy(['one', 'two', 'three'], 'length');
       * // => { '3': 2, '5': 1 }
       */
      var countBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          ++result[key];
        } else {
          baseAssignValue(result, key, 1);
        }
      });

      /**
       * Checks if `predicate` returns truthy for **all** elements of `collection`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * **Note:** This method returns `true` for
       * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
       * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
       * elements of empty collections.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * _.every([true, 1, null, 'yes'], Boolean);
       * // => false
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.every(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.every(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.every(users, 'active');
       * // => false
       */
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }

      /**
       * Iterates over elements of `collection`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * **Note:** Unlike `_.remove`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.reject
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * _.filter(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, { 'age': 36, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.filter(users, 'active');
       * // => objects for ['barney']
       *
       * // Combining several predicates using `_.overEvery` or `_.overSome`.
       * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
       * // => objects for ['fred', 'barney']
       */
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }

      /**
       * Iterates over elements of `collection`, returning the first element
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': true },
       *   { 'user': 'fred',    'age': 40, 'active': false },
       *   { 'user': 'pebbles', 'age': 1,  'active': true }
       * ];
       *
       * _.find(users, function(o) { return o.age < 40; });
       * // => object for 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.find(users, { 'age': 1, 'active': true });
       * // => object for 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.find(users, ['active', false]);
       * // => object for 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.find(users, 'active');
       * // => object for 'barney'
       */
      var find = createFind(findIndex);

      /**
       * This method is like `_.find` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=collection.length-1] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * _.findLast([1, 2, 3, 4], function(n) {
       *   return n % 2 == 1;
       * });
       * // => 3
       */
      var findLast = createFind(findLastIndex);

      /**
       * Creates a flattened array of values by running each element in `collection`
       * thru `iteratee` and flattening the mapped results. The iteratee is invoked
       * with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [n, n];
       * }
       *
       * _.flatMap([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }

      /**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDeep([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */
      function flatMapDeep(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), INFINITY);
      }

      /**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDepth([1, 2], duplicate, 2);
       * // => [[1, 1], [2, 2]]
       */
      function flatMapDepth(collection, iteratee, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee), depth);
      }

      /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * **Note:** As with other "Collections" methods, objects with a "length"
       * property are iterated like arrays. To avoid this behavior use `_.forIn`
       * or `_.forOwn` for object iteration.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias each
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEachRight
       * @example
       *
       * _.forEach([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `1` then `2`.
       *
       * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee, 3));
      }

      /**
       * This method is like `_.forEach` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @alias eachRight
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEach
       * @example
       *
       * _.forEachRight([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `2` then `1`.
       */
      function forEachRight(collection, iteratee) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee, 3));
      }

      /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The order of grouped values
       * is determined by the order they occur in `collection`. The corresponding
       * value of each key is an array of elements responsible for generating the
       * key. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.groupBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': [4.2], '6': [6.1, 6.3] }
       *
       * // The `_.property` iteratee shorthand.
       * _.groupBy(['one', 'two', 'three'], 'length');
       * // => { '3': ['one', 'two'], '5': ['three'] }
       */
      var groupBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          result[key].push(value);
        } else {
          baseAssignValue(result, key, [value]);
        }
      });

      /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * is used for equality comparisons. If `fromIndex` is negative, it's used as
       * the offset from the end of `collection`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes([1, 2, 3], 1, 2);
       * // => false
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection)
          ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
          : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
      }

      /**
       * Invokes the method at `path` of each element in `collection`, returning
       * an array of the results of each invoked method. Any additional arguments
       * are provided to each invoked method. If `path` is a function, it's invoked
       * for, and `this` bound to, each element in `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array|Function|string} path The path of the method to invoke or
       *  the function invoked per iteration.
       * @param {...*} [args] The arguments to invoke each method with.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
       * // => [[1, 5, 7], [1, 2, 3]]
       *
       * _.invokeMap([123, 456], String.prototype.split, '');
       * // => [['1', '2', '3'], ['4', '5', '6']]
       */
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1,
            isFunc = typeof path == 'function',
            result = isArrayLike(collection) ? Array(collection.length) : [];

        baseEach(collection, function(value) {
          result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result;
      });

      /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the last element responsible for generating the key. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * var array = [
       *   { 'dir': 'left', 'code': 97 },
       *   { 'dir': 'right', 'code': 100 }
       * ];
       *
       * _.keyBy(array, function(o) {
       *   return String.fromCharCode(o.code);
       * });
       * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
       *
       * _.keyBy(array, 'dir');
       * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
       */
      var keyBy = createAggregator(function(result, value, key) {
        baseAssignValue(result, key, value);
      });

      /**
       * Creates an array of values by running each element in `collection` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
       *
       * The guarded methods are:
       * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
       * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
       * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
       * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * _.map([4, 8], square);
       * // => [16, 64]
       *
       * _.map({ 'a': 4, 'b': 8 }, square);
       * // => [16, 64] (iteration order is not guaranteed)
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, 'user');
       * // => ['barney', 'fred']
       */
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee, 3));
      }

      /**
       * This method is like `_.sortBy` except that it allows specifying the sort
       * orders of the iteratees to sort by. If `orders` is unspecified, all values
       * are sorted in ascending order. Otherwise, specify an order of "desc" for
       * descending or "asc" for ascending sort order of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @param {string[]} [orders] The sort orders of `iteratees`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 34 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 36 }
       * ];
       *
       * // Sort by `user` in ascending order and by `age` in descending order.
       * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
       */
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }

      /**
       * Creates an array of elements split into two groups, the first of which
       * contains elements `predicate` returns truthy for, the second of which
       * contains elements `predicate` returns falsey for. The predicate is
       * invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of grouped elements.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': false },
       *   { 'user': 'fred',    'age': 40, 'active': true },
       *   { 'user': 'pebbles', 'age': 1,  'active': false }
       * ];
       *
       * _.partition(users, function(o) { return o.active; });
       * // => objects for [['fred'], ['barney', 'pebbles']]
       *
       * // The `_.matches` iteratee shorthand.
       * _.partition(users, { 'age': 1, 'active': false });
       * // => objects for [['pebbles'], ['barney', 'fred']]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.partition(users, ['active', false]);
       * // => objects for [['barney', 'pebbles'], ['fred']]
       *
       * // The `_.property` iteratee shorthand.
       * _.partition(users, 'active');
       * // => objects for [['fred'], ['barney', 'pebbles']]
       */
      var partition = createAggregator(function(result, value, key) {
        result[key ? 0 : 1].push(value);
      }, function() { return [[], []]; });

      /**
       * Reduces `collection` to a value which is the accumulated result of running
       * each element in `collection` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `collection` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.reduce`, `_.reduceRight`, and `_.transform`.
       *
       * The guarded methods are:
       * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
       * and `sortBy`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduceRight
       * @example
       *
       * _.reduce([1, 2], function(sum, n) {
       *   return sum + n;
       * }, 0);
       * // => 3
       *
       * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       *   return result;
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
       */
      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3;

        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }

      /**
       * This method is like `_.reduce` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduce
       * @example
       *
       * var array = [[0, 1], [2, 3], [4, 5]];
       *
       * _.reduceRight(array, function(flattened, other) {
       *   return flattened.concat(other);
       * }, []);
       * // => [4, 5, 2, 3, 0, 1]
       */
      function reduceRight(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3;

        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
      }

      /**
       * The opposite of `_.filter`; this method returns the elements of `collection`
       * that `predicate` does **not** return truthy for.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.filter
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': true }
       * ];
       *
       * _.reject(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.reject(users, { 'age': 40, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.reject(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.reject(users, 'active');
       * // => objects for ['barney']
       */
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }

      /**
       * Gets a random element from `collection`.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       * @example
       *
       * _.sample([1, 2, 3, 4]);
       * // => 2
       */
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }

      /**
       * Gets `n` random elements at unique keys from `collection` up to the
       * size of `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @param {number} [n=1] The number of elements to sample.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the random elements.
       * @example
       *
       * _.sampleSize([1, 2, 3], 2);
       * // => [3, 1]
       *
       * _.sampleSize([1, 2, 3], 4);
       * // => [2, 3, 1]
       */
      function sampleSize(collection, n, guard) {
        if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }

      /**
       * Creates an array of shuffled values, using a version of the
       * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       * @example
       *
       * _.shuffle([1, 2, 3, 4]);
       * // => [4, 1, 3, 2]
       */
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }

      /**
       * Gets the size of `collection` by returning its length for array-like
       * values or the number of own enumerable string keyed properties for objects.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * _.size([1, 2, 3]);
       * // => 3
       *
       * _.size({ 'a': 1, 'b': 2 });
       * // => 2
       *
       * _.size('pebbles');
       * // => 7
       */
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }

      /**
       * Checks if `predicate` returns truthy for **any** element of `collection`.
       * Iteration is stopped once `predicate` returns truthy. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       * @example
       *
       * _.some([null, 0, 'yes', false], Boolean);
       * // => true
       *
       * var users = [
       *   { 'user': 'barney', 'active': true },
       *   { 'user': 'fred',   'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.some(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.some(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.some(users, 'active');
       * // => true
       */
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }

      /**
       * Creates an array of elements, sorted in ascending order by the results of
       * running each element in a collection thru each iteratee. This method
       * performs a stable sort, that is, it preserves the original sort order of
       * equal elements. The iteratees are invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 30 },
       *   { 'user': 'barney', 'age': 34 }
       * ];
       *
       * _.sortBy(users, [function(o) { return o.user; }]);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
       *
       * _.sortBy(users, ['user', 'age']);
       * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
       */
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });

      /*------------------------------------------------------------------------*/

      /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */
      var now = ctxNow || function() {
        return root.Date.now();
      };

      /*------------------------------------------------------------------------*/

      /**
       * The opposite of `_.before`; this method creates a function that invokes
       * `func` once it's called `n` or more times.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {number} n The number of calls before `func` is invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var saves = ['profile', 'settings'];
       *
       * var done = _.after(saves.length, function() {
       *   console.log('done saving!');
       * });
       *
       * _.forEach(saves, function(type) {
       *   asyncSave({ 'type': type, 'complete': done });
       * });
       * // => Logs 'done saving!' after the two async saves have completed.
       */
      function after(n, func) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }

      /**
       * Creates a function that invokes `func`, with up to `n` arguments,
       * ignoring any additional arguments.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @param {number} [n=func.length] The arity cap.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.ary(parseInt, 1));
       * // => [6, 8, 10]
       */
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = (func && n == null) ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }

      /**
       * Creates a function that invokes `func`, with the `this` binding and arguments
       * of the created function, while it's called less than `n` times. Subsequent
       * calls to the created function return the result of the last `func` invocation.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {number} n The number of calls at which `func` is no longer invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * jQuery(element).on('click', _.before(5, addContactToList));
       * // => Allows adding up to 4 contacts to the list.
       */
      function before(n, func) {
        var result;
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result;
        };
      }

      /**
       * Creates a function that invokes `func` with the `this` binding of `thisArg`
       * and `partials` prepended to the arguments it receives.
       *
       * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for partially applied arguments.
       *
       * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
       * property of bound functions.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to bind.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * function greet(greeting, punctuation) {
       *   return greeting + ' ' + this.user + punctuation;
       * }
       *
       * var object = { 'user': 'fred' };
       *
       * var bound = _.bind(greet, object, 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bind(greet, object, _, '!');
       * bound('hi');
       * // => 'hi fred!'
       */
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });

      /**
       * Creates a function that invokes the method at `object[key]` with `partials`
       * prepended to the arguments it receives.
       *
       * This method differs from `_.bind` by allowing bound functions to reference
       * methods that may be redefined or don't yet exist. See
       * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
       * for more details.
       *
       * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Function
       * @param {Object} object The object to invoke the method on.
       * @param {string} key The key of the method.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * var object = {
       *   'user': 'fred',
       *   'greet': function(greeting, punctuation) {
       *     return greeting + ' ' + this.user + punctuation;
       *   }
       * };
       *
       * var bound = _.bindKey(object, 'greet', 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * object.greet = function(greeting, punctuation) {
       *   return greeting + 'ya ' + this.user + punctuation;
       * };
       *
       * bound('!');
       * // => 'hiya fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bindKey(object, 'greet', _, '!');
       * bound('hi');
       * // => 'hiya fred!'
       */
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });

      /**
       * Creates a function that accepts arguments of `func` and either invokes
       * `func` returning its result, if at least `arity` number of arguments have
       * been provided, or returns a function that accepts the remaining `func`
       * arguments, and so on. The arity of `func` may be specified if `func.length`
       * is not sufficient.
       *
       * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curry(abc);
       *
       * curried(1)(2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(1)(_, 3)(2);
       * // => [1, 2, 3]
       */
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result.placeholder = curry.placeholder;
        return result;
      }

      /**
       * This method is like `_.curry` except that arguments are applied to `func`
       * in the manner of `_.partialRight` instead of `_.partial`.
       *
       * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curryRight(abc);
       *
       * curried(3)(2)(1);
       * // => [1, 2, 3]
       *
       * curried(2, 3)(1);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(3)(1, _)(2);
       * // => [1, 2, 3]
       */
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result.placeholder = curryRight.placeholder;
        return result;
      }

      /**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */
      function debounce(func, wait, options) {
        var lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = 'maxWait' in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }

        function invokeFunc(time) {
          var args = lastArgs,
              thisArg = lastThis;

          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }

        function leadingEdge(time) {
          // Reset any `maxWait` timer.
          lastInvokeTime = time;
          // Start the timer for the trailing edge.
          timerId = setTimeout(timerExpired, wait);
          // Invoke the leading edge.
          return leading ? invokeFunc(time) : result;
        }

        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;

          return maxing
            ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
        }

        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

          // Either this is the first call, activity has stopped and we're at the
          // trailing edge, the system time has gone backwards and we're treating
          // it as the trailing edge, or we've hit the `maxWait` limit.
          return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
            (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
        }

        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          // Restart the timer.
          timerId = setTimeout(timerExpired, remainingWait(time));
        }

        function trailingEdge(time) {
          timerId = undefined$1;

          // Only invoke if we have `lastArgs` which means `func` has been
          // debounced at least once.
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result;
        }

        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }

        function flush() {
          return timerId === undefined$1 ? result : trailingEdge(now());
        }

        function debounced() {
          var time = now(),
              isInvoking = shouldInvoke(time);

          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;

          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              // Handle invocations in a tight loop.
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }

      /**
       * Defers invoking the `func` until the current call stack has cleared. Any
       * additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to defer.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.defer(function(text) {
       *   console.log(text);
       * }, 'deferred');
       * // => Logs 'deferred' after one millisecond.
       */
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });

      /**
       * Invokes `func` after `wait` milliseconds. Any additional arguments are
       * provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.delay(function(text) {
       *   console.log(text);
       * }, 1000, 'later');
       * // => Logs 'later' after one second.
       */
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });

      /**
       * Creates a function that invokes `func` with arguments reversed.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to flip arguments for.
       * @returns {Function} Returns the new flipped function.
       * @example
       *
       * var flipped = _.flip(function() {
       *   return _.toArray(arguments);
       * });
       *
       * flipped('a', 'b', 'c', 'd');
       * // => ['d', 'c', 'b', 'a']
       */
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }

      /**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */
      function memoize(func, resolver) {
        if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;

          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }

      // Expose `MapCache`.
      memoize.Cache = MapCache;

      /**
       * Creates a function that negates the result of the predicate `func`. The
       * `func` predicate is invoked with the `this` binding and arguments of the
       * created function.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} predicate The predicate to negate.
       * @returns {Function} Returns the new negated function.
       * @example
       *
       * function isEven(n) {
       *   return n % 2 == 0;
       * }
       *
       * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
       * // => [1, 3, 5]
       */
      function negate(predicate) {
        if (typeof predicate != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0: return !predicate.call(this);
            case 1: return !predicate.call(this, args[0]);
            case 2: return !predicate.call(this, args[0], args[1]);
            case 3: return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }

      /**
       * Creates a function that is restricted to invoking `func` once. Repeat calls
       * to the function return the value of the first invocation. The `func` is
       * invoked with the `this` binding and arguments of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var initialize = _.once(createApplication);
       * initialize();
       * initialize();
       * // => `createApplication` is invoked once
       */
      function once(func) {
        return before(2, func);
      }

      /**
       * Creates a function that invokes `func` with its arguments transformed.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Function
       * @param {Function} func The function to wrap.
       * @param {...(Function|Function[])} [transforms=[_.identity]]
       *  The argument transforms.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function doubled(n) {
       *   return n * 2;
       * }
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var func = _.overArgs(function(x, y) {
       *   return [x, y];
       * }, [square, doubled]);
       *
       * func(9, 3);
       * // => [81, 6]
       *
       * func(10, 5);
       * // => [100, 10]
       */
      var overArgs = castRest(function(func, transforms) {
        transforms = (transforms.length == 1 && isArray(transforms[0]))
          ? arrayMap(transforms[0], baseUnary(getIteratee()))
          : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1,
              length = nativeMin(args.length, funcsLength);

          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });

      /**
       * Creates a function that invokes `func` with `partials` prepended to the
       * arguments it receives. This method is like `_.bind` except it does **not**
       * alter the `this` binding.
       *
       * The `_.partial.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 0.2.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var sayHelloTo = _.partial(greet, 'hello');
       * sayHelloTo('fred');
       * // => 'hello fred'
       *
       * // Partially applied with placeholders.
       * var greetFred = _.partial(greet, _, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       */
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });

      /**
       * This method is like `_.partial` except that partially applied arguments
       * are appended to the arguments it receives.
       *
       * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var greetFred = _.partialRight(greet, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       *
       * // Partially applied with placeholders.
       * var sayHelloTo = _.partialRight(greet, 'hello', _);
       * sayHelloTo('fred');
       * // => 'hello fred'
       */
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });

      /**
       * Creates a function that invokes `func` with arguments arranged according
       * to the specified `indexes` where the argument value at the first index is
       * provided as the first argument, the argument value at the second index is
       * provided as the second argument, and so on.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to rearrange arguments for.
       * @param {...(number|number[])} indexes The arranged argument indexes.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var rearged = _.rearg(function(a, b, c) {
       *   return [a, b, c];
       * }, [2, 0, 1]);
       *
       * rearged('b', 'c', 'a')
       * // => ['a', 'b', 'c']
       */
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });

      /**
       * Creates a function that invokes `func` with the `this` binding of the
       * created function and arguments from `start` and beyond provided as
       * an array.
       *
       * **Note:** This method is based on the
       * [rest parameter](https://mdn.io/rest_parameters).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.rest(function(what, names) {
       *   return what + ' ' + _.initial(names).join(', ') +
       *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
       * });
       *
       * say('hello', 'fred', 'barney', 'pebbles');
       * // => 'hello fred, barney, & pebbles'
       */
      function rest(func, start) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }

      /**
       * Creates a function that invokes `func` with the `this` binding of the
       * create function and an array of arguments much like
       * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
       *
       * **Note:** This method is based on the
       * [spread operator](https://mdn.io/spread_operator).
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Function
       * @param {Function} func The function to spread arguments over.
       * @param {number} [start=0] The start position of the spread.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.spread(function(who, what) {
       *   return who + ' says ' + what;
       * });
       *
       * say(['fred', 'hello']);
       * // => 'fred says hello'
       *
       * var numbers = Promise.all([
       *   Promise.resolve(40),
       *   Promise.resolve(36)
       * ]);
       *
       * numbers.then(_.spread(function(x, y) {
       *   return x + y;
       * }));
       * // => a Promise of 76
       */
      function spread(func, start) {
        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start],
              otherArgs = castSlice(args, 0, start);

          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }

      /**
       * Creates a throttled function that only invokes `func` at most once per
       * every `wait` milliseconds. The throttled function comes with a `cancel`
       * method to cancel delayed `func` invocations and a `flush` method to
       * immediately invoke them. Provide `options` to indicate whether `func`
       * should be invoked on the leading and/or trailing edge of the `wait`
       * timeout. The `func` is invoked with the last arguments provided to the
       * throttled function. Subsequent calls to the throttled function return the
       * result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the throttled function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.throttle` and `_.debounce`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to throttle.
       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=true]
       *  Specify invoking on the leading edge of the timeout.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new throttled function.
       * @example
       *
       * // Avoid excessively updating the position while scrolling.
       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
       *
       * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
       * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
       * jQuery(element).on('click', throttled);
       *
       * // Cancel the trailing throttled invocation.
       * jQuery(window).on('popstate', throttled.cancel);
       */
      function throttle(func, wait, options) {
        var leading = true,
            trailing = true;

        if (typeof func != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = 'leading' in options ? !!options.leading : leading;
          trailing = 'trailing' in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          'leading': leading,
          'maxWait': wait,
          'trailing': trailing
        });
      }

      /**
       * Creates a function that accepts up to one argument, ignoring any
       * additional arguments.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.unary(parseInt));
       * // => [6, 8, 10]
       */
      function unary(func) {
        return ary(func, 1);
      }

      /**
       * Creates a function that provides `value` to `wrapper` as its first
       * argument. Any additional arguments provided to the function are appended
       * to those provided to the `wrapper`. The wrapper is invoked with the `this`
       * binding of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {*} value The value to wrap.
       * @param {Function} [wrapper=identity] The wrapper function.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var p = _.wrap(_.escape, function(func, text) {
       *   return '<p>' + func(text) + '</p>';
       * });
       *
       * p('fred, barney, & pebbles');
       * // => '<p>fred, barney, &amp; pebbles</p>'
       */
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }

      /*------------------------------------------------------------------------*/

      /**
       * Casts `value` as an array if it's not one.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Lang
       * @param {*} value The value to inspect.
       * @returns {Array} Returns the cast array.
       * @example
       *
       * _.castArray(1);
       * // => [1]
       *
       * _.castArray({ 'a': 1 });
       * // => [{ 'a': 1 }]
       *
       * _.castArray('abc');
       * // => ['abc']
       *
       * _.castArray(null);
       * // => [null]
       *
       * _.castArray(undefined);
       * // => [undefined]
       *
       * _.castArray();
       * // => []
       *
       * var array = [1, 2, 3];
       * console.log(_.castArray(array) === array);
       * // => true
       */
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }

      /**
       * Creates a shallow clone of `value`.
       *
       * **Note:** This method is loosely based on the
       * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
       * and supports cloning arrays, array buffers, booleans, date objects, maps,
       * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
       * arrays. The own enumerable properties of `arguments` objects are cloned
       * as plain objects. An empty object is returned for uncloneable values such
       * as error objects, functions, DOM nodes, and WeakMaps.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to clone.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeep
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var shallow = _.clone(objects);
       * console.log(shallow[0] === objects[0]);
       * // => true
       */
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }

      /**
       * This method is like `_.clone` except that it accepts `customizer` which
       * is invoked to produce the cloned value. If `customizer` returns `undefined`,
       * cloning is handled by the method instead. The `customizer` is invoked with
       * up to four arguments; (value [, index|key, object, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeepWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(false);
       *   }
       * }
       *
       * var el = _.cloneWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 0
       */
      function cloneWith(value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }

      /**
       * This method is like `_.clone` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @returns {*} Returns the deep cloned value.
       * @see _.clone
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var deep = _.cloneDeep(objects);
       * console.log(deep[0] === objects[0]);
       * // => false
       */
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }

      /**
       * This method is like `_.cloneWith` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the deep cloned value.
       * @see _.cloneWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(true);
       *   }
       * }
       *
       * var el = _.cloneDeepWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 20
       */
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }

      /**
       * Checks if `object` conforms to `source` by invoking the predicate
       * properties of `source` with the corresponding property values of `object`.
       *
       * **Note:** This method is equivalent to `_.conforms` when `source` is
       * partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
       * // => true
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
       * // => false
       */
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }

      /**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */
      function eq(value, other) {
        return value === other || (value !== value && other !== other);
      }

      /**
       * Checks if `value` is greater than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       * @see _.lt
       * @example
       *
       * _.gt(3, 1);
       * // => true
       *
       * _.gt(3, 3);
       * // => false
       *
       * _.gt(1, 3);
       * // => false
       */
      var gt = createRelationalOperation(baseGt);

      /**
       * Checks if `value` is greater than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than or equal to
       *  `other`, else `false`.
       * @see _.lte
       * @example
       *
       * _.gte(3, 1);
       * // => true
       *
       * _.gte(3, 3);
       * // => true
       *
       * _.gte(1, 3);
       * // => false
       */
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });

      /**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */
      var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
          !propertyIsEnumerable.call(value, 'callee');
      };

      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */
      var isArray = Array.isArray;

      /**
       * Checks if `value` is classified as an `ArrayBuffer` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       * @example
       *
       * _.isArrayBuffer(new ArrayBuffer(2));
       * // => true
       *
       * _.isArrayBuffer(new Array(2));
       * // => false
       */
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

      /**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }

      /**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }

      /**
       * Checks if `value` is classified as a boolean primitive or object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
       * @example
       *
       * _.isBoolean(false);
       * // => true
       *
       * _.isBoolean(null);
       * // => false
       */
      function isBoolean(value) {
        return value === true || value === false ||
          (isObjectLike(value) && baseGetTag(value) == boolTag);
      }

      /**
       * Checks if `value` is a buffer.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
       * @example
       *
       * _.isBuffer(new Buffer(2));
       * // => true
       *
       * _.isBuffer(new Uint8Array(2));
       * // => false
       */
      var isBuffer = nativeIsBuffer || stubFalse;

      /**
       * Checks if `value` is classified as a `Date` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       * @example
       *
       * _.isDate(new Date);
       * // => true
       *
       * _.isDate('Mon April 23 2012');
       * // => false
       */
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

      /**
       * Checks if `value` is likely a DOM element.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
       * @example
       *
       * _.isElement(document.body);
       * // => true
       *
       * _.isElement('<body>');
       * // => false
       */
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }

      /**
       * Checks if `value` is an empty object, collection, map, or set.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Array-like values such as `arguments` objects, arrays, buffers, strings, or
       * jQuery-like collections are considered empty if they have a `length` of `0`.
       * Similarly, maps and sets are considered empty if they have a `size` of `0`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * _.isEmpty(null);
       * // => true
       *
       * _.isEmpty(true);
       * // => true
       *
       * _.isEmpty(1);
       * // => true
       *
       * _.isEmpty([1, 2, 3]);
       * // => false
       *
       * _.isEmpty({ 'a': 1 });
       * // => false
       */
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) &&
            (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
              isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }

      /**
       * Performs a deep comparison between two values to determine if they are
       * equivalent.
       *
       * **Note:** This method supports comparing arrays, array buffers, booleans,
       * date objects, error objects, maps, numbers, `Object` objects, regexes,
       * sets, strings, symbols, and typed arrays. `Object` objects are compared
       * by their own, not inherited, enumerable properties. Functions and DOM
       * nodes are compared by strict equality, i.e. `===`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.isEqual(object, other);
       * // => true
       *
       * object === other;
       * // => false
       */
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }

      /**
       * This method is like `_.isEqual` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with up to
       * six arguments: (objValue, othValue [, index|key, object, other, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, othValue) {
       *   if (isGreeting(objValue) && isGreeting(othValue)) {
       *     return true;
       *   }
       * }
       *
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * _.isEqualWith(array, other, customizer);
       * // => true
       */
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined$1;
        var result = customizer ? customizer(value, other) : undefined$1;
        return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
      }

      /**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag ||
          (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
      }

      /**
       * Checks if `value` is a finite primitive number.
       *
       * **Note:** This method is based on
       * [`Number.isFinite`](https://mdn.io/Number/isFinite).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
       * @example
       *
       * _.isFinite(3);
       * // => true
       *
       * _.isFinite(Number.MIN_VALUE);
       * // => true
       *
       * _.isFinite(Infinity);
       * // => false
       *
       * _.isFinite('3');
       * // => false
       */
      function isFinite(value) {
        return typeof value == 'number' && nativeIsFinite(value);
      }

      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }

      /**
       * Checks if `value` is an integer.
       *
       * **Note:** This method is based on
       * [`Number.isInteger`](https://mdn.io/Number/isInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
       * @example
       *
       * _.isInteger(3);
       * // => true
       *
       * _.isInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isInteger(Infinity);
       * // => false
       *
       * _.isInteger('3');
       * // => false
       */
      function isInteger(value) {
        return typeof value == 'number' && value == toInteger(value);
      }

      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */
      function isLength(value) {
        return typeof value == 'number' &&
          value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }

      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
      }

      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */
      function isObjectLike(value) {
        return value != null && typeof value == 'object';
      }

      /**
       * Checks if `value` is classified as a `Map` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       * @example
       *
       * _.isMap(new Map);
       * // => true
       *
       * _.isMap(new WeakMap);
       * // => false
       */
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

      /**
       * Performs a partial deep comparison between `object` and `source` to
       * determine if `object` contains equivalent property values.
       *
       * **Note:** This method is equivalent to `_.matches` when `source` is
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.isMatch(object, { 'b': 2 });
       * // => true
       *
       * _.isMatch(object, { 'b': 1 });
       * // => false
       */
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }

      /**
       * This method is like `_.isMatch` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with five
       * arguments: (objValue, srcValue, index|key, object, source).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, srcValue) {
       *   if (isGreeting(objValue) && isGreeting(srcValue)) {
       *     return true;
       *   }
       * }
       *
       * var object = { 'greeting': 'hello' };
       * var source = { 'greeting': 'hi' };
       *
       * _.isMatchWith(object, source, customizer);
       * // => true
       */
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }

      /**
       * Checks if `value` is `NaN`.
       *
       * **Note:** This method is based on
       * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
       * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
       * `undefined` and other non-number values.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       * @example
       *
       * _.isNaN(NaN);
       * // => true
       *
       * _.isNaN(new Number(NaN));
       * // => true
       *
       * isNaN(undefined);
       * // => true
       *
       * _.isNaN(undefined);
       * // => false
       */
      function isNaN(value) {
        // An `NaN` primitive is the only value that is not equal to itself.
        // Perform the `toStringTag` check first to avoid errors with some
        // ActiveX objects in IE.
        return isNumber(value) && value != +value;
      }

      /**
       * Checks if `value` is a pristine native function.
       *
       * **Note:** This method can't reliably detect native functions in the presence
       * of the core-js package because core-js circumvents this kind of detection.
       * Despite multiple requests, the core-js maintainer has made it clear: any
       * attempt to fix the detection will be obstructed. As a result, we're left
       * with little choice but to throw an error. Unfortunately, this also affects
       * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
       * which rely on core-js.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       * @example
       *
       * _.isNative(Array.prototype.push);
       * // => true
       *
       * _.isNative(_);
       * // => false
       */
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }

      /**
       * Checks if `value` is `null`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
       * @example
       *
       * _.isNull(null);
       * // => true
       *
       * _.isNull(void 0);
       * // => false
       */
      function isNull(value) {
        return value === null;
      }

      /**
       * Checks if `value` is `null` or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
       * @example
       *
       * _.isNil(null);
       * // => true
       *
       * _.isNil(void 0);
       * // => true
       *
       * _.isNil(NaN);
       * // => false
       */
      function isNil(value) {
        return value == null;
      }

      /**
       * Checks if `value` is classified as a `Number` primitive or object.
       *
       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
       * classified as numbers, use the `_.isFinite` method.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a number, else `false`.
       * @example
       *
       * _.isNumber(3);
       * // => true
       *
       * _.isNumber(Number.MIN_VALUE);
       * // => true
       *
       * _.isNumber(Infinity);
       * // => true
       *
       * _.isNumber('3');
       * // => false
       */
      function isNumber(value) {
        return typeof value == 'number' ||
          (isObjectLike(value) && baseGetTag(value) == numberTag);
      }

      /**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor == 'function' && Ctor instanceof Ctor &&
          funcToString.call(Ctor) == objectCtorString;
      }

      /**
       * Checks if `value` is classified as a `RegExp` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       * @example
       *
       * _.isRegExp(/abc/);
       * // => true
       *
       * _.isRegExp('/abc/');
       * // => false
       */
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

      /**
       * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
       * double precision number which isn't the result of a rounded unsafe integer.
       *
       * **Note:** This method is based on
       * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
       * @example
       *
       * _.isSafeInteger(3);
       * // => true
       *
       * _.isSafeInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isSafeInteger(Infinity);
       * // => false
       *
       * _.isSafeInteger('3');
       * // => false
       */
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }

      /**
       * Checks if `value` is classified as a `Set` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       * @example
       *
       * _.isSet(new Set);
       * // => true
       *
       * _.isSet(new WeakSet);
       * // => false
       */
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

      /**
       * Checks if `value` is classified as a `String` primitive or object.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a string, else `false`.
       * @example
       *
       * _.isString('abc');
       * // => true
       *
       * _.isString(1);
       * // => false
       */
      function isString(value) {
        return typeof value == 'string' ||
          (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
      }

      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */
      function isSymbol(value) {
        return typeof value == 'symbol' ||
          (isObjectLike(value) && baseGetTag(value) == symbolTag);
      }

      /**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

      /**
       * Checks if `value` is `undefined`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * _.isUndefined(void 0);
       * // => true
       *
       * _.isUndefined(null);
       * // => false
       */
      function isUndefined(value) {
        return value === undefined$1;
      }

      /**
       * Checks if `value` is classified as a `WeakMap` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
       * @example
       *
       * _.isWeakMap(new WeakMap);
       * // => true
       *
       * _.isWeakMap(new Map);
       * // => false
       */
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }

      /**
       * Checks if `value` is classified as a `WeakSet` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
       * @example
       *
       * _.isWeakSet(new WeakSet);
       * // => true
       *
       * _.isWeakSet(new Set);
       * // => false
       */
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }

      /**
       * Checks if `value` is less than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       * @see _.gt
       * @example
       *
       * _.lt(1, 3);
       * // => true
       *
       * _.lt(3, 3);
       * // => false
       *
       * _.lt(3, 1);
       * // => false
       */
      var lt = createRelationalOperation(baseLt);

      /**
       * Checks if `value` is less than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than or equal to
       *  `other`, else `false`.
       * @see _.gte
       * @example
       *
       * _.lte(1, 3);
       * // => true
       *
       * _.lte(3, 3);
       * // => true
       *
       * _.lte(3, 1);
       * // => false
       */
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });

      /**
       * Converts `value` to an array.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Array} Returns the converted array.
       * @example
       *
       * _.toArray({ 'a': 1, 'b': 2 });
       * // => [1, 2]
       *
       * _.toArray('abc');
       * // => ['a', 'b', 'c']
       *
       * _.toArray(1);
       * // => []
       *
       * _.toArray(null);
       * // => []
       */
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value),
            func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

        return func(value);
      }

      /**
       * Converts `value` to a finite number.
       *
       * @static
       * @memberOf _
       * @since 4.12.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted number.
       * @example
       *
       * _.toFinite(3.2);
       * // => 3.2
       *
       * _.toFinite(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toFinite(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toFinite('3.2');
       * // => 3.2
       */
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = (value < 0 ? -1 : 1);
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }

      /**
       * Converts `value` to an integer.
       *
       * **Note:** This method is loosely based on
       * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toInteger(3.2);
       * // => 3
       *
       * _.toInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toInteger(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toInteger('3.2');
       * // => 3
       */
      function toInteger(value) {
        var result = toFinite(value),
            remainder = result % 1;

        return result === result ? (remainder ? result - remainder : result) : 0;
      }

      /**
       * Converts `value` to an integer suitable for use as the length of an
       * array-like object.
       *
       * **Note:** This method is based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toLength(3.2);
       * // => 3
       *
       * _.toLength(Number.MIN_VALUE);
       * // => 0
       *
       * _.toLength(Infinity);
       * // => 4294967295
       *
       * _.toLength('3.2');
       * // => 3
       */
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }

      /**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */
      function toNumber(value) {
        if (typeof value == 'number') {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
          value = isObject(other) ? (other + '') : other;
        }
        if (typeof value != 'string') {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return (isBinary || reIsOctal.test(value))
          ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
          : (reIsBadHex.test(value) ? NAN : +value);
      }

      /**
       * Converts `value` to a plain object flattening inherited enumerable string
       * keyed properties of `value` to own properties of the plain object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Object} Returns the converted plain object.
       * @example
       *
       * function Foo() {
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.assign({ 'a': 1 }, new Foo);
       * // => { 'a': 1, 'b': 2 }
       *
       * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
       * // => { 'a': 1, 'b': 2, 'c': 3 }
       */
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }

      /**
       * Converts `value` to a safe integer. A safe integer can be compared and
       * represented correctly.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toSafeInteger(3.2);
       * // => 3
       *
       * _.toSafeInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toSafeInteger(Infinity);
       * // => 9007199254740991
       *
       * _.toSafeInteger('3.2');
       * // => 3
       */
      function toSafeInteger(value) {
        return value
          ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
          : (value === 0 ? value : 0);
      }

      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */
      function toString(value) {
        return value == null ? '' : baseToString(value);
      }

      /*------------------------------------------------------------------------*/

      /**
       * Assigns own enumerable string keyed properties of source objects to the
       * destination object. Source objects are applied from left to right.
       * Subsequent sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object` and is loosely based on
       * [`Object.assign`](https://mdn.io/Object/assign).
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assignIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assign({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'c': 3 }
       */
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });

      /**
       * This method is like `_.assign` except that it iterates over own and
       * inherited source properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extend
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assign
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assignIn({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
       */
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });

      /**
       * This method is like `_.assignIn` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extendWith
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignInWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });

      /**
       * This method is like `_.assign` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignInWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });

      /**
       * Creates an array of values corresponding to `paths` of `object`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Array} Returns the picked values.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _.at(object, ['a[0].b.c', 'a[1]']);
       * // => [3, 4]
       */
      var at = flatRest(baseAt);

      /**
       * Creates an object that inherits from the `prototype` object. If a
       * `properties` object is given, its own enumerable string keyed properties
       * are assigned to the created object.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Object
       * @param {Object} prototype The object to inherit from.
       * @param {Object} [properties] The properties to assign to the object.
       * @returns {Object} Returns the new object.
       * @example
       *
       * function Shape() {
       *   this.x = 0;
       *   this.y = 0;
       * }
       *
       * function Circle() {
       *   Shape.call(this);
       * }
       *
       * Circle.prototype = _.create(Shape.prototype, {
       *   'constructor': Circle
       * });
       *
       * var circle = new Circle;
       * circle instanceof Circle;
       * // => true
       *
       * circle instanceof Shape;
       * // => true
       */
      function create(prototype, properties) {
        var result = baseCreate(prototype);
        return properties == null ? result : baseAssign(result, properties);
      }

      /**
       * Assigns own and inherited enumerable string keyed properties of source
       * objects to the destination object for all destination properties that
       * resolve to `undefined`. Source objects are applied from left to right.
       * Once a property is set, additional values of the same property are ignored.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaultsDeep
       * @example
       *
       * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */
      var defaults = baseRest(function(object, sources) {
        object = Object(object);

        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }

        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;

          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];

            if (value === undefined$1 ||
                (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
              object[key] = source[key];
            }
          }
        }

        return object;
      });

      /**
       * This method is like `_.defaults` except that it recursively assigns
       * default properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaults
       * @example
       *
       * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
       * // => { 'a': { 'b': 2, 'c': 3 } }
       */
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });

      /**
       * This method is like `_.find` except that it returns the key of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findKey(users, function(o) { return o.age < 40; });
       * // => 'barney' (iteration order is not guaranteed)
       *
       * // The `_.matches` iteratee shorthand.
       * _.findKey(users, { 'age': 1, 'active': true });
       * // => 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findKey(users, 'active');
       * // => 'barney'
       */
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }

      /**
       * This method is like `_.findKey` except that it iterates over elements of
       * a collection in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findLastKey(users, function(o) { return o.age < 40; });
       * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastKey(users, { 'age': 36, 'active': true });
       * // => 'barney'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastKey(users, 'active');
       * // => 'pebbles'
       */
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }

      /**
       * Iterates over own and inherited enumerable string keyed properties of an
       * object and invokes `iteratee` for each property. The iteratee is invoked
       * with three arguments: (value, key, object). Iteratee functions may exit
       * iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forInRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forIn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
       */
      function forIn(object, iteratee) {
        return object == null
          ? object
          : baseFor(object, getIteratee(iteratee, 3), keysIn);
      }

      /**
       * This method is like `_.forIn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forInRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
       */
      function forInRight(object, iteratee) {
        return object == null
          ? object
          : baseForRight(object, getIteratee(iteratee, 3), keysIn);
      }

      /**
       * Iterates over own enumerable string keyed properties of an object and
       * invokes `iteratee` for each property. The iteratee is invoked with three
       * arguments: (value, key, object). Iteratee functions may exit iteration
       * early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwnRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */
      function forOwn(object, iteratee) {
        return object && baseForOwn(object, getIteratee(iteratee, 3));
      }

      /**
       * This method is like `_.forOwn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwnRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
       */
      function forOwnRight(object, iteratee) {
        return object && baseForOwnRight(object, getIteratee(iteratee, 3));
      }

      /**
       * Creates an array of function property names from own enumerable properties
       * of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functionsIn
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functions(new Foo);
       * // => ['a', 'b']
       */
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }

      /**
       * Creates an array of function property names from own and inherited
       * enumerable properties of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functions
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functionsIn(new Foo);
       * // => ['a', 'b', 'c']
       */
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }

      /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */
      function get(object, path, defaultValue) {
        var result = object == null ? undefined$1 : baseGet(object, path);
        return result === undefined$1 ? defaultValue : result;
      }

      /**
       * Checks if `path` is a direct property of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = { 'a': { 'b': 2 } };
       * var other = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.has(object, 'a');
       * // => true
       *
       * _.has(object, 'a.b');
       * // => true
       *
       * _.has(object, ['a', 'b']);
       * // => true
       *
       * _.has(other, 'a');
       * // => false
       */
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }

      /**
       * Checks if `path` is a direct or inherited property of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.hasIn(object, 'a');
       * // => true
       *
       * _.hasIn(object, 'a.b');
       * // => true
       *
       * _.hasIn(object, ['a', 'b']);
       * // => true
       *
       * _.hasIn(object, 'b');
       * // => false
       */
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }

      /**
       * Creates an object composed of the inverted keys and values of `object`.
       * If `object` contains duplicate values, subsequent values overwrite
       * property assignments of previous values.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Object
       * @param {Object} object The object to invert.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invert(object);
       * // => { '1': 'c', '2': 'b' }
       */
      var invert = createInverter(function(result, value, key) {
        if (value != null &&
            typeof value.toString != 'function') {
          value = nativeObjectToString.call(value);
        }

        result[value] = key;
      }, constant(identity));

      /**
       * This method is like `_.invert` except that the inverted object is generated
       * from the results of running each element of `object` thru `iteratee`. The
       * corresponding inverted value of each inverted key is an array of keys
       * responsible for generating the inverted value. The iteratee is invoked
       * with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Object
       * @param {Object} object The object to invert.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invertBy(object);
       * // => { '1': ['a', 'c'], '2': ['b'] }
       *
       * _.invertBy(object, function(value) {
       *   return 'group' + value;
       * });
       * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
       */
      var invertBy = createInverter(function(result, value, key) {
        if (value != null &&
            typeof value.toString != 'function') {
          value = nativeObjectToString.call(value);
        }

        if (hasOwnProperty.call(result, value)) {
          result[value].push(key);
        } else {
          result[value] = [key];
        }
      }, getIteratee);

      /**
       * Invokes the method at `path` of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
       *
       * _.invoke(object, 'a[0].b.c.slice', 1, 3);
       * // => [2, 3]
       */
      var invoke = baseRest(baseInvoke);

      /**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }

      /**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }

      /**
       * The opposite of `_.mapValues`; this method creates an object with the
       * same values as `object` and keys generated by running each own enumerable
       * string keyed property of `object` thru `iteratee`. The iteratee is invoked
       * with three arguments: (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapValues
       * @example
       *
       * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
       *   return key + value;
       * });
       * // => { 'a1': 1, 'b2': 2 }
       */
      function mapKeys(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);

        baseForOwn(object, function(value, key, object) {
          baseAssignValue(result, iteratee(value, key, object), value);
        });
        return result;
      }

      /**
       * Creates an object with the same keys as `object` and values generated
       * by running each own enumerable string keyed property of `object` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapKeys
       * @example
       *
       * var users = {
       *   'fred':    { 'user': 'fred',    'age': 40 },
       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
       * };
       *
       * _.mapValues(users, function(o) { return o.age; });
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       *
       * // The `_.property` iteratee shorthand.
       * _.mapValues(users, 'age');
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       */
      function mapValues(object, iteratee) {
        var result = {};
        iteratee = getIteratee(iteratee, 3);

        baseForOwn(object, function(value, key, object) {
          baseAssignValue(result, key, iteratee(value, key, object));
        });
        return result;
      }

      /**
       * This method is like `_.assign` except that it recursively merges own and
       * inherited enumerable string keyed properties of source objects into the
       * destination object. Source properties that resolve to `undefined` are
       * skipped if a destination value exists. Array and plain object properties
       * are merged recursively. Other objects and value types are overridden by
       * assignment. Source objects are applied from left to right. Subsequent
       * sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {
       *   'a': [{ 'b': 2 }, { 'd': 4 }]
       * };
       *
       * var other = {
       *   'a': [{ 'c': 3 }, { 'e': 5 }]
       * };
       *
       * _.merge(object, other);
       * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
       */
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });

      /**
       * This method is like `_.merge` except that it accepts `customizer` which
       * is invoked to produce the merged values of the destination and source
       * properties. If `customizer` returns `undefined`, merging is handled by the
       * method instead. The `customizer` is invoked with six arguments:
       * (objValue, srcValue, key, object, source, stack).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} customizer The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   if (_.isArray(objValue)) {
       *     return objValue.concat(srcValue);
       *   }
       * }
       *
       * var object = { 'a': [1], 'b': [2] };
       * var other = { 'a': [3], 'b': [4] };
       *
       * _.mergeWith(object, other, customizer);
       * // => { 'a': [1, 3], 'b': [2, 4] }
       */
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });

      /**
       * The opposite of `_.pick`; this method creates an object composed of the
       * own and inherited enumerable property paths of `object` that are not omitted.
       *
       * **Note:** This method is considerably slower than `_.pick`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to omit.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omit(object, ['a', 'c']);
       * // => { 'b': '2' }
       */
      var omit = flatRest(function(object, paths) {
        var result = {};
        if (object == null) {
          return result;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result);
        if (isDeep) {
          result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result, paths[length]);
        }
        return result;
      });

      /**
       * The opposite of `_.pickBy`; this method creates an object composed of
       * the own and inherited enumerable string keyed properties of `object` that
       * `predicate` doesn't return truthy for. The predicate is invoked with two
       * arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omitBy(object, _.isNumber);
       * // => { 'b': '2' }
       */
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }

      /**
       * Creates an object composed of the picked `object` properties.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pick(object, ['a', 'c']);
       * // => { 'a': 1, 'c': 3 }
       */
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });

      /**
       * Creates an object composed of the `object` properties `predicate` returns
       * truthy for. The predicate is invoked with two arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pickBy(object, _.isNumber);
       * // => { 'a': 1, 'c': 3 }
       */
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }

      /**
       * This method is like `_.get` except that if the resolved value is a
       * function it's invoked with the `this` binding of its parent object and
       * its result is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to resolve.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
       *
       * _.result(object, 'a[0].b.c1');
       * // => 3
       *
       * _.result(object, 'a[0].b.c2');
       * // => 4
       *
       * _.result(object, 'a[0].b.c3', 'default');
       * // => 'default'
       *
       * _.result(object, 'a[0].b.c3', _.constant('default'));
       * // => 'default'
       */
      function result(object, path, defaultValue) {
        path = castPath(path, object);

        var index = -1,
            length = path.length;

        // Ensure the loop is entered when path is empty.
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index])];
          if (value === undefined$1) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }

      /**
       * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
       * it's created. Arrays are created for missing index properties while objects
       * are created for all other missing properties. Use `_.setWith` to customize
       * `path` creation.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.set(object, 'a[0].b.c', 4);
       * console.log(object.a[0].b.c);
       * // => 4
       *
       * _.set(object, ['x', '0', 'y', 'z'], 5);
       * console.log(object.x[0].y.z);
       * // => 5
       */
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }

      /**
       * This method is like `_.set` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.setWith(object, '[0][1]', 'a', Object);
       * // => { '0': { '1': 'a' } }
       */
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }

      /**
       * Creates an array of own enumerable string keyed-value pairs for `object`
       * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
       * entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entries
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairs(new Foo);
       * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
       */
      var toPairs = createToPairs(keys);

      /**
       * Creates an array of own and inherited enumerable string keyed-value pairs
       * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
       * or set, its entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entriesIn
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairsIn(new Foo);
       * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
       */
      var toPairsIn = createToPairs(keysIn);

      /**
       * An alternative to `_.reduce`; this method transforms `object` to a new
       * `accumulator` object which is the result of running each of its own
       * enumerable string keyed properties thru `iteratee`, with each invocation
       * potentially mutating the `accumulator` object. If `accumulator` is not
       * provided, a new object with the same `[[Prototype]]` will be used. The
       * iteratee is invoked with four arguments: (accumulator, value, key, object).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The custom accumulator value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * _.transform([2, 3, 4], function(result, n) {
       *   result.push(n *= n);
       *   return n % 2 == 0;
       * }, []);
       * // => [4, 9]
       *
       * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] }
       */
      function transform(object, iteratee, accumulator) {
        var isArr = isArray(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object);

        iteratee = getIteratee(iteratee, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          }
          else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          }
          else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
          return iteratee(accumulator, value, index, object);
        });
        return accumulator;
      }

      /**
       * Removes the property at `path` of `object`.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 7 } }] };
       * _.unset(object, 'a[0].b.c');
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       *
       * _.unset(object, ['a', '0', 'b', 'c']);
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       */
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }

      /**
       * This method is like `_.set` except that accepts `updater` to produce the
       * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
       * is invoked with one argument: (value).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.update(object, 'a[0].b.c', function(n) { return n * n; });
       * console.log(object.a[0].b.c);
       * // => 9
       *
       * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
       * console.log(object.x[0].y.z);
       * // => 0
       */
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }

      /**
       * This method is like `_.update` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.updateWith(object, '[0][1]', _.constant('a'), Object);
       * // => { '0': { '1': 'a' } }
       */
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }

      /**
       * Creates an array of the own enumerable string keyed property values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.values(new Foo);
       * // => [1, 2] (iteration order is not guaranteed)
       *
       * _.values('hi');
       * // => ['h', 'i']
       */
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }

      /**
       * Creates an array of the own and inherited enumerable string keyed property
       * values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.valuesIn(new Foo);
       * // => [1, 2, 3] (iteration order is not guaranteed)
       */
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }

      /*------------------------------------------------------------------------*/

      /**
       * Clamps `number` within the inclusive `lower` and `upper` bounds.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Number
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       * @example
       *
       * _.clamp(-10, -5, 5);
       * // => -5
       *
       * _.clamp(10, -5, 5);
       * // => 5
       */
      function clamp(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }

      /**
       * Checks if `n` is between `start` and up to, but not including, `end`. If
       * `end` is not specified, it's set to `start` with `start` then set to `0`.
       * If `start` is greater than `end` the params are swapped to support
       * negative ranges.
       *
       * @static
       * @memberOf _
       * @since 3.3.0
       * @category Number
       * @param {number} number The number to check.
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       * @see _.range, _.rangeRight
       * @example
       *
       * _.inRange(3, 2, 4);
       * // => true
       *
       * _.inRange(4, 8);
       * // => true
       *
       * _.inRange(4, 2);
       * // => false
       *
       * _.inRange(2, 2);
       * // => false
       *
       * _.inRange(1.2, 2);
       * // => true
       *
       * _.inRange(5.2, 4);
       * // => false
       *
       * _.inRange(-3, -2, -6);
       * // => true
       */
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }

      /**
       * Produces a random number between the inclusive `lower` and `upper` bounds.
       * If only one argument is provided a number between `0` and the given number
       * is returned. If `floating` is `true`, or either `lower` or `upper` are
       * floats, a floating-point number is returned instead of an integer.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Number
       * @param {number} [lower=0] The lower bound.
       * @param {number} [upper=1] The upper bound.
       * @param {boolean} [floating] Specify returning a floating-point number.
       * @returns {number} Returns the random number.
       * @example
       *
       * _.random(0, 5);
       * // => an integer between 0 and 5
       *
       * _.random(5);
       * // => also an integer between 0 and 5
       *
       * _.random(5, true);
       * // => a floating-point number between 0 and 5
       *
       * _.random(1.2, 5.2);
       * // => a floating-point number between 1.2 and 5.2
       */
      function random(lower, upper, floating) {
        if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == 'boolean') {
            floating = upper;
            upper = undefined$1;
          }
          else if (typeof lower == 'boolean') {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        }
        else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
        }
        return baseRandom(lower, upper);
      }

      /*------------------------------------------------------------------------*/

      /**
       * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the camel cased string.
       * @example
       *
       * _.camelCase('Foo Bar');
       * // => 'fooBar'
       *
       * _.camelCase('--foo-bar--');
       * // => 'fooBar'
       *
       * _.camelCase('__FOO_BAR__');
       * // => 'fooBar'
       */
      var camelCase = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });

      /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * _.capitalize('FRED');
       * // => 'Fred'
       */
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }

      /**
       * Deburrs `string` by converting
       * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
       * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
       * letters to basic Latin letters and removing
       * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to deburr.
       * @returns {string} Returns the deburred string.
       * @example
       *
       * _.deburr('déjà vu');
       * // => 'deja vu'
       */
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
      }

      /**
       * Checks if `string` ends with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=string.length] The position to search up to.
       * @returns {boolean} Returns `true` if `string` ends with `target`,
       *  else `false`.
       * @example
       *
       * _.endsWith('abc', 'c');
       * // => true
       *
       * _.endsWith('abc', 'b');
       * // => false
       *
       * _.endsWith('abc', 'b', 2);
       * // => true
       */
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);

        var length = string.length;
        position = position === undefined$1
          ? length
          : baseClamp(toInteger(position), 0, length);

        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }

      /**
       * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
       * corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */
      function escape(string) {
        string = toString(string);
        return (string && reHasUnescapedHtml.test(string))
          ? string.replace(reUnescapedHtml, escapeHtmlChar)
          : string;
      }

      /**
       * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
       * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escapeRegExp('[lodash](https://lodash.com/)');
       * // => '\[lodash\]\(https://lodash\.com/\)'
       */
      function escapeRegExp(string) {
        string = toString(string);
        return (string && reHasRegExpChar.test(string))
          ? string.replace(reRegExpChar, '\\$&')
          : string;
      }

      /**
       * Converts `string` to
       * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the kebab cased string.
       * @example
       *
       * _.kebabCase('Foo Bar');
       * // => 'foo-bar'
       *
       * _.kebabCase('fooBar');
       * // => 'foo-bar'
       *
       * _.kebabCase('__FOO_BAR__');
       * // => 'foo-bar'
       */
      var kebabCase = createCompounder(function(result, word, index) {
        return result + (index ? '-' : '') + word.toLowerCase();
      });

      /**
       * Converts `string`, as space separated words, to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.lowerCase('--Foo-Bar--');
       * // => 'foo bar'
       *
       * _.lowerCase('fooBar');
       * // => 'foo bar'
       *
       * _.lowerCase('__FOO_BAR__');
       * // => 'foo bar'
       */
      var lowerCase = createCompounder(function(result, word, index) {
        return result + (index ? ' ' : '') + word.toLowerCase();
      });

      /**
       * Converts the first character of `string` to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.lowerFirst('Fred');
       * // => 'fred'
       *
       * _.lowerFirst('FRED');
       * // => 'fRED'
       */
      var lowerFirst = createCaseFirst('toLowerCase');

      /**
       * Pads `string` on the left and right sides if it's shorter than `length`.
       * Padding characters are truncated if they can't be evenly divided by `length`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.pad('abc', 8);
       * // => '  abc   '
       *
       * _.pad('abc', 8, '_-');
       * // => '_-abc_-_'
       *
       * _.pad('abc', 3);
       * // => 'abc'
       */
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);

        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return (
          createPadding(nativeFloor(mid), chars) +
          string +
          createPadding(nativeCeil(mid), chars)
        );
      }

      /**
       * Pads `string` on the right side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padEnd('abc', 6);
       * // => 'abc   '
       *
       * _.padEnd('abc', 6, '_-');
       * // => 'abc_-_'
       *
       * _.padEnd('abc', 3);
       * // => 'abc'
       */
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);

        var strLength = length ? stringSize(string) : 0;
        return (length && strLength < length)
          ? (string + createPadding(length - strLength, chars))
          : string;
      }

      /**
       * Pads `string` on the left side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padStart('abc', 6);
       * // => '   abc'
       *
       * _.padStart('abc', 6, '_-');
       * // => '_-_abc'
       *
       * _.padStart('abc', 3);
       * // => 'abc'
       */
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);

        var strLength = length ? stringSize(string) : 0;
        return (length && strLength < length)
          ? (createPadding(length - strLength, chars) + string)
          : string;
      }

      /**
       * Converts `string` to an integer of the specified radix. If `radix` is
       * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
       * hexadecimal, in which case a `radix` of `16` is used.
       *
       * **Note:** This method aligns with the
       * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category String
       * @param {string} string The string to convert.
       * @param {number} [radix=10] The radix to interpret `value` by.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.parseInt('08');
       * // => 8
       *
       * _.map(['6', '08', '10'], _.parseInt);
       * // => [6, 8, 10]
       */
      function parseInt(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
      }

      /**
       * Repeats the given string `n` times.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to repeat.
       * @param {number} [n=1] The number of times to repeat the string.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the repeated string.
       * @example
       *
       * _.repeat('*', 3);
       * // => '***'
       *
       * _.repeat('abc', 2);
       * // => 'abcabc'
       *
       * _.repeat('abc', 0);
       * // => ''
       */
      function repeat(string, n, guard) {
        if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }

      /**
       * Replaces matches for `pattern` in `string` with `replacement`.
       *
       * **Note:** This method is based on
       * [`String#replace`](https://mdn.io/String/replace).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to modify.
       * @param {RegExp|string} pattern The pattern to replace.
       * @param {Function|string} replacement The match replacement.
       * @returns {string} Returns the modified string.
       * @example
       *
       * _.replace('Hi Fred', 'Fred', 'Barney');
       * // => 'Hi Barney'
       */
      function replace() {
        var args = arguments,
            string = toString(args[0]);

        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }

      /**
       * Converts `string` to
       * [snake case](https://en.wikipedia.org/wiki/Snake_case).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the snake cased string.
       * @example
       *
       * _.snakeCase('Foo Bar');
       * // => 'foo_bar'
       *
       * _.snakeCase('fooBar');
       * // => 'foo_bar'
       *
       * _.snakeCase('--FOO-BAR--');
       * // => 'foo_bar'
       */
      var snakeCase = createCompounder(function(result, word, index) {
        return result + (index ? '_' : '') + word.toLowerCase();
      });

      /**
       * Splits `string` by `separator`.
       *
       * **Note:** This method is based on
       * [`String#split`](https://mdn.io/String/split).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to split.
       * @param {RegExp|string} separator The separator pattern to split by.
       * @param {number} [limit] The length to truncate results to.
       * @returns {Array} Returns the string segments.
       * @example
       *
       * _.split('a-b-c', '-', 2);
       * // => ['a', 'b']
       */
      function split(string, separator, limit) {
        if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (
              typeof separator == 'string' ||
              (separator != null && !isRegExp(separator))
            )) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }

      /**
       * Converts `string` to
       * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
       *
       * @static
       * @memberOf _
       * @since 3.1.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the start cased string.
       * @example
       *
       * _.startCase('--foo-bar--');
       * // => 'Foo Bar'
       *
       * _.startCase('fooBar');
       * // => 'Foo Bar'
       *
       * _.startCase('__FOO_BAR__');
       * // => 'FOO BAR'
       */
      var startCase = createCompounder(function(result, word, index) {
        return result + (index ? ' ' : '') + upperFirst(word);
      });

      /**
       * Checks if `string` starts with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=0] The position to search from.
       * @returns {boolean} Returns `true` if `string` starts with `target`,
       *  else `false`.
       * @example
       *
       * _.startsWith('abc', 'a');
       * // => true
       *
       * _.startsWith('abc', 'b');
       * // => false
       *
       * _.startsWith('abc', 'b', 1);
       * // => true
       */
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null
          ? 0
          : baseClamp(toInteger(position), 0, string.length);

        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }

      /**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is given, it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes
       * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for easier debugging.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options={}] The options object.
       * @param {RegExp} [options.escape=_.templateSettings.escape]
       *  The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
       *  The "evaluate" delimiter.
       * @param {Object} [options.imports=_.templateSettings.imports]
       *  An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
       *  The "interpolate" delimiter.
       * @param {string} [options.sourceURL='lodash.templateSources[n]']
       *  The sourceURL of the compiled template.
       * @param {string} [options.variable='obj']
       *  The data object variable name.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // Use the "interpolate" delimiter to create a compiled template.
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // Use the HTML "escape" delimiter to escape data property values.
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the internal `print` function in "evaluate" delimiters.
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // Use the ES template literal delimiter as an "interpolate" delimiter.
       * // Disable support by replacing the "interpolate" delimiter.
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // Use backslashes to treat delimiters as plain text.
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // Use the `imports` option to import `jQuery` as `jq`.
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the `sourceURL` option to specify a custom sourceURL for the template.
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
       *
       * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // Use custom template delimiters.
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // Use the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and stack traces.
       * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */
      function template(string, options, guard) {
        // Based on John Resig's `tmpl` implementation
        // (http://ejohn.org/blog/javascript-micro-templating/)
        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
        var settings = lodash.templateSettings;

        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);

        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys);

        var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";

        // Compile the regexp to match each delimiter.
        var reDelimiters = RegExp(
          (options.escape || reNoMatch).source + '|' +
          interpolate.source + '|' +
          (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
          (options.evaluate || reNoMatch).source + '|$'
        , 'g');

        // Use a sourceURL for easier debugging.
        // The sourceURL gets injected into the source that's eval-ed, so be careful
        // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
        // and escape the comment, thus injecting code that gets evaled.
        var sourceURL = '//# sourceURL=' +
          (hasOwnProperty.call(options, 'sourceURL')
            ? (options.sourceURL + '').replace(/\s/g, ' ')
            : ('lodash.templateSources[' + (++templateCounter) + ']')
          ) + '\n';

        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);

          // Escape characters that can't be included in string literals.
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

          // Replace delimiters with snippets.
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;

          // The JS engine embedded in Adobe products needs `match` returned in
          // order to produce the correct `offset` value.
          return match;
        });

        source += "';\n";

        // If `variable` is not specified wrap a with-statement around the generated
        // code to add the data object to the top of the scope chain.
        var variable = hasOwnProperty.call(options, 'variable') && options.variable;
        if (!variable) {
          source = 'with (obj) {\n' + source + '\n}\n';
        }
        // Throw an error if a forbidden character was found in `variable`, to prevent
        // potential command injection attacks.
        else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
        }

        // Cleanup code by stripping empty strings.
        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
          .replace(reEmptyStringMiddle, '$1')
          .replace(reEmptyStringTrailing, '$1;');

        // Frame code as the function body.
        source = 'function(' + (variable || 'obj') + ') {\n' +
          (variable
            ? ''
            : 'obj || (obj = {});\n'
          ) +
          "var __t, __p = ''" +
          (isEscaping
             ? ', __e = _.escape'
             : ''
          ) +
          (isEvaluating
            ? ', __j = Array.prototype.join;\n' +
              "function print() { __p += __j.call(arguments, '') }\n"
            : ';\n'
          ) +
          source +
          'return __p\n}';

        var result = attempt(function() {
          return Function(importsKeys, sourceURL + 'return ' + source)
            .apply(undefined$1, importsValues);
        });

        // Provide the compiled function's source by its `toString` method or
        // the `source` property as a convenience for inlining compiled templates.
        result.source = source;
        if (isError(result)) {
          throw result;
        }
        return result;
      }

      /**
       * Converts `string`, as a whole, to lower case just like
       * [String#toLowerCase](https://mdn.io/toLowerCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.toLower('--Foo-Bar--');
       * // => '--foo-bar--'
       *
       * _.toLower('fooBar');
       * // => 'foobar'
       *
       * _.toLower('__FOO_BAR__');
       * // => '__foo_bar__'
       */
      function toLower(value) {
        return toString(value).toLowerCase();
      }

      /**
       * Converts `string`, as a whole, to upper case just like
       * [String#toUpperCase](https://mdn.io/toUpperCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.toUpper('--foo-bar--');
       * // => '--FOO-BAR--'
       *
       * _.toUpper('fooBar');
       * // => 'FOOBAR'
       *
       * _.toUpper('__foo_bar__');
       * // => '__FOO_BAR__'
       */
      function toUpper(value) {
        return toString(value).toUpperCase();
      }

      /**
       * Removes leading and trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trim('  abc  ');
       * // => 'abc'
       *
       * _.trim('-_-abc-_-', '_-');
       * // => 'abc'
       *
       * _.map(['  foo  ', '  bar  '], _.trim);
       * // => ['foo', 'bar']
       */
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars),
            start = charsStartIndex(strSymbols, chrSymbols),
            end = charsEndIndex(strSymbols, chrSymbols) + 1;

        return castSlice(strSymbols, start, end).join('');
      }

      /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimEnd('  abc  ');
       * // => '  abc'
       *
       * _.trimEnd('-_-abc-_-', '_-');
       * // => '-_-abc'
       */
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string),
            end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

        return castSlice(strSymbols, 0, end).join('');
      }

      /**
       * Removes leading whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimStart('  abc  ');
       * // => 'abc  '
       *
       * _.trimStart('-_-abc-_-', '_-');
       * // => 'abc-_-'
       */
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, '');
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string),
            start = charsStartIndex(strSymbols, stringToArray(chars));

        return castSlice(strSymbols, start).join('');
      }

      /**
       * Truncates `string` if it's longer than the given maximum string length.
       * The last characters of the truncated string are replaced with the omission
       * string which defaults to "...".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to truncate.
       * @param {Object} [options={}] The options object.
       * @param {number} [options.length=30] The maximum string length.
       * @param {string} [options.omission='...'] The string to indicate text is omitted.
       * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
       * @returns {string} Returns the truncated string.
       * @example
       *
       * _.truncate('hi-diddly-ho there, neighborino');
       * // => 'hi-diddly-ho there, neighbo...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': ' '
       * });
       * // => 'hi-diddly-ho there,...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': /,? +/
       * });
       * // => 'hi-diddly-ho there...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'omission': ' [...]'
       * });
       * // => 'hi-diddly-ho there, neig [...]'
       */
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION;

        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? toInteger(options.length) : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);

        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result = strSymbols
          ? castSlice(strSymbols, 0, end).join('')
          : string.slice(0, end);

        if (separator === undefined$1) {
          return result + omission;
        }
        if (strSymbols) {
          end += (result.length - end);
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match,
                substring = result;

            if (!separator.global) {
              separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
            }
            separator.lastIndex = 0;
            while ((match = separator.exec(substring))) {
              var newEnd = match.index;
            }
            result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result.lastIndexOf(separator);
          if (index > -1) {
            result = result.slice(0, index);
          }
        }
        return result + omission;
      }

      /**
       * The inverse of `_.escape`; this method converts the HTML entities
       * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
       * their corresponding characters.
       *
       * **Note:** No other HTML entities are unescaped. To unescape additional
       * HTML entities use a third-party library like [_he_](https://mths.be/he).
       *
       * @static
       * @memberOf _
       * @since 0.6.0
       * @category String
       * @param {string} [string=''] The string to unescape.
       * @returns {string} Returns the unescaped string.
       * @example
       *
       * _.unescape('fred, barney, &amp; pebbles');
       * // => 'fred, barney, & pebbles'
       */
      function unescape(string) {
        string = toString(string);
        return (string && reHasEscapedHtml.test(string))
          ? string.replace(reEscapedHtml, unescapeHtmlChar)
          : string;
      }

      /**
       * Converts `string`, as space separated words, to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.upperCase('--foo-bar');
       * // => 'FOO BAR'
       *
       * _.upperCase('fooBar');
       * // => 'FOO BAR'
       *
       * _.upperCase('__foo_bar__');
       * // => 'FOO BAR'
       */
      var upperCase = createCompounder(function(result, word, index) {
        return result + (index ? ' ' : '') + word.toUpperCase();
      });

      /**
       * Converts the first character of `string` to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.upperFirst('fred');
       * // => 'Fred'
       *
       * _.upperFirst('FRED');
       * // => 'FRED'
       */
      var upperFirst = createCaseFirst('toUpperCase');

      /**
       * Splits `string` into an array of its words.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {RegExp|string} [pattern] The pattern to match words.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the words of `string`.
       * @example
       *
       * _.words('fred, barney, & pebbles');
       * // => ['fred', 'barney', 'pebbles']
       *
       * _.words('fred, barney, & pebbles', /[^, ]+/g);
       * // => ['fred', 'barney', '&', 'pebbles']
       */
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined$1 : pattern;

        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }

      /*------------------------------------------------------------------------*/

      /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Function} func The function to attempt.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // Avoid throwing errors for invalid selectors.
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error(e);
        }
      });

      /**
       * Binds methods of an object to the object itself, overwriting the existing
       * method.
       *
       * **Note:** This method doesn't set the "length" property of bound functions.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Object} object The object to bind and assign the bound methods to.
       * @param {...(string|string[])} methodNames The object method names to bind.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var view = {
       *   'label': 'docs',
       *   'click': function() {
       *     console.log('clicked ' + this.label);
       *   }
       * };
       *
       * _.bindAll(view, ['click']);
       * jQuery(element).on('click', view.click);
       * // => Logs 'clicked docs' when clicked.
       */
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });

      /**
       * Creates a function that iterates over `pairs` and invokes the corresponding
       * function of the first predicate to return truthy. The predicate-function
       * pairs are invoked with the `this` binding and arguments of the created
       * function.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Array} pairs The predicate-function pairs.
       * @returns {Function} Returns the new composite function.
       * @example
       *
       * var func = _.cond([
       *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
       *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
       *   [_.stubTrue,                      _.constant('no match')]
       * ]);
       *
       * func({ 'a': 1, 'b': 2 });
       * // => 'matches A'
       *
       * func({ 'a': 0, 'b': 1 });
       * // => 'matches B'
       *
       * func({ 'a': '1', 'b': '2' });
       * // => 'no match'
       */
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length,
            toIteratee = getIteratee();

        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });

        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }

      /**
       * Creates a function that invokes the predicate properties of `source` with
       * the corresponding property values of a given object, returning `true` if
       * all predicates return truthy, else `false`.
       *
       * **Note:** The created function is equivalent to `_.conformsTo` with
       * `source` partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 2, 'b': 1 },
       *   { 'a': 1, 'b': 2 }
       * ];
       *
       * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
       * // => [{ 'a': 1, 'b': 2 }]
       */
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }

      /**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */
      function constant(value) {
        return function() {
          return value;
        };
      }

      /**
       * Checks `value` to determine whether a default value should be returned in
       * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
       * or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Util
       * @param {*} value The value to check.
       * @param {*} defaultValue The default value.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * _.defaultTo(1, 10);
       * // => 1
       *
       * _.defaultTo(undefined, 10);
       * // => 10
       */
      function defaultTo(value, defaultValue) {
        return (value == null || value !== value) ? defaultValue : value;
      }

      /**
       * Creates a function that returns the result of invoking the given functions
       * with the `this` binding of the created function, where each successive
       * invocation is supplied the return value of the previous.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flowRight
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flow([_.add, square]);
       * addSquare(1, 2);
       * // => 9
       */
      var flow = createFlow();

      /**
       * This method is like `_.flow` except that it creates a function that
       * invokes the given functions from right to left.
       *
       * @static
       * @since 3.0.0
       * @memberOf _
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flow
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flowRight([square, _.add]);
       * addSquare(1, 2);
       * // => 9
       */
      var flowRight = createFlow(true);

      /**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */
      function identity(value) {
        return value;
      }

      /**
       * Creates a function that invokes `func` with the arguments of the created
       * function. If `func` is a property name, the created function returns the
       * property value for a given element. If `func` is an array or object, the
       * created function returns `true` for elements that contain the equivalent
       * source properties, otherwise it returns `false`.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Util
       * @param {*} [func=_.identity] The value to convert to a callback.
       * @returns {Function} Returns the callback.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
       * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, _.iteratee(['user', 'fred']));
       * // => [{ 'user': 'fred', 'age': 40 }]
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, _.iteratee('user'));
       * // => ['barney', 'fred']
       *
       * // Create custom iteratee shorthands.
       * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
       *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
       *     return func.test(string);
       *   };
       * });
       *
       * _.filter(['abc', 'def'], /ef/);
       * // => ['def']
       */
      function iteratee(func) {
        return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
      }

      /**
       * Creates a function that performs a partial deep comparison between a given
       * object and `source`, returning `true` if the given object has equivalent
       * property values, else `false`.
       *
       * **Note:** The created function is equivalent to `_.isMatch` with `source`
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
       * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }

      /**
       * Creates a function that performs a partial deep comparison between the
       * value at `path` of a given object to `srcValue`, returning `true` if the
       * object value is equivalent, else `false`.
       *
       * **Note:** Partial comparisons will match empty array and empty object
       * `srcValue` values against any array or object value, respectively. See
       * `_.isEqual` for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.find(objects, _.matchesProperty('a', 4));
       * // => { 'a': 4, 'b': 5, 'c': 6 }
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }

      /**
       * Creates a function that invokes the method at `path` of a given object.
       * Any additional arguments are provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': _.constant(2) } },
       *   { 'a': { 'b': _.constant(1) } }
       * ];
       *
       * _.map(objects, _.method('a.b'));
       * // => [2, 1]
       *
       * _.map(objects, _.method(['a', 'b']));
       * // => [2, 1]
       */
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });

      /**
       * The opposite of `_.method`; this method creates a function that invokes
       * the method at a given path of `object`. Any additional arguments are
       * provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Object} object The object to query.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var array = _.times(3, _.constant),
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.methodOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
       * // => [2, 0]
       */
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });

      /**
       * Adds all own enumerable string keyed function properties of a source
       * object to the destination object. If `object` is a function, then methods
       * are added to its prototype as well.
       *
       * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
       * avoid conflicts caused by modifying the original.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Function|Object} [object=lodash] The destination object.
       * @param {Object} source The object of functions to add.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
       * @returns {Function|Object} Returns `object`.
       * @example
       *
       * function vowels(string) {
       *   return _.filter(string, function(v) {
       *     return /[aeiou]/i.test(v);
       *   });
       * }
       *
       * _.mixin({ 'vowels': vowels });
       * _.vowels('fred');
       * // => ['e']
       *
       * _('fred').vowels().value();
       * // => ['e']
       *
       * _.mixin({ 'vowels': vowels }, { 'chain': false });
       * _('fred').vowels();
       * // => ['e']
       */
      function mixin(object, source, options) {
        var props = keys(source),
            methodNames = baseFunctions(source, props);

        if (options == null &&
            !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
            isFunc = isFunction(object);

        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__),
                    actions = result.__actions__ = copyArray(this.__actions__);

                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });

        return object;
      }

      /**
       * Reverts the `_` variable to its previous value and returns a reference to
       * the `lodash` function.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @returns {Function} Returns the `lodash` function.
       * @example
       *
       * var lodash = _.noConflict();
       */
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }

      /**
       * This method returns `undefined`.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Util
       * @example
       *
       * _.times(2, _.noop);
       * // => [undefined, undefined]
       */
      function noop() {
        // No operation performed.
      }

      /**
       * Creates a function that gets the argument at index `n`. If `n` is negative,
       * the nth argument from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [n=0] The index of the argument to return.
       * @returns {Function} Returns the new pass-thru function.
       * @example
       *
       * var func = _.nthArg(1);
       * func('a', 'b', 'c', 'd');
       * // => 'b'
       *
       * var func = _.nthArg(-2);
       * func('a', 'b', 'c', 'd');
       * // => 'c'
       */
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }

      /**
       * Creates a function that invokes `iteratees` with the arguments it receives
       * and returns their results.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to invoke.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.over([Math.max, Math.min]);
       *
       * func(1, 2, 3, 4);
       * // => [4, 1]
       */
      var over = createOver(arrayMap);

      /**
       * Creates a function that checks if **all** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overEvery([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => false
       *
       * func(NaN);
       * // => false
       */
      var overEvery = createOver(arrayEvery);

      /**
       * Creates a function that checks if **any** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overSome([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => true
       *
       * func(NaN);
       * // => false
       *
       * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
       * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
       */
      var overSome = createOver(arraySome);

      /**
       * Creates a function that returns the value at `path` of a given object.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': 2 } },
       *   { 'a': { 'b': 1 } }
       * ];
       *
       * _.map(objects, _.property('a.b'));
       * // => [2, 1]
       *
       * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
       * // => [1, 2]
       */
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }

      /**
       * The opposite of `_.property`; this method creates a function that returns
       * the value at a given path of `object`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var array = [0, 1, 2],
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
       * // => [2, 0]
       */
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }

      /**
       * Creates an array of numbers (positive and/or negative) progressing from
       * `start` up to, but not including, `end`. A step of `-1` is used if a negative
       * `start` is specified without an `end` or `step`. If `end` is not specified,
       * it's set to `start` with `start` then set to `0`.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.rangeRight
       * @example
       *
       * _.range(4);
       * // => [0, 1, 2, 3]
       *
       * _.range(-4);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 5);
       * // => [1, 2, 3, 4]
       *
       * _.range(0, 20, 5);
       * // => [0, 5, 10, 15]
       *
       * _.range(0, -4, -1);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.range(0);
       * // => []
       */
      var range = createRange();

      /**
       * This method is like `_.range` except that it populates values in
       * descending order.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.range
       * @example
       *
       * _.rangeRight(4);
       * // => [3, 2, 1, 0]
       *
       * _.rangeRight(-4);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 5);
       * // => [4, 3, 2, 1]
       *
       * _.rangeRight(0, 20, 5);
       * // => [15, 10, 5, 0]
       *
       * _.rangeRight(0, -4, -1);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.rangeRight(0);
       * // => []
       */
      var rangeRight = createRange(true);

      /**
       * This method returns a new empty array.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Array} Returns the new empty array.
       * @example
       *
       * var arrays = _.times(2, _.stubArray);
       *
       * console.log(arrays);
       * // => [[], []]
       *
       * console.log(arrays[0] === arrays[1]);
       * // => false
       */
      function stubArray() {
        return [];
      }

      /**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */
      function stubFalse() {
        return false;
      }

      /**
       * This method returns a new empty object.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Object} Returns the new empty object.
       * @example
       *
       * var objects = _.times(2, _.stubObject);
       *
       * console.log(objects);
       * // => [{}, {}]
       *
       * console.log(objects[0] === objects[1]);
       * // => false
       */
      function stubObject() {
        return {};
      }

      /**
       * This method returns an empty string.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {string} Returns the empty string.
       * @example
       *
       * _.times(2, _.stubString);
       * // => ['', '']
       */
      function stubString() {
        return '';
      }

      /**
       * This method returns `true`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `true`.
       * @example
       *
       * _.times(2, _.stubTrue);
       * // => [true, true]
       */
      function stubTrue() {
        return true;
      }

      /**
       * Invokes the iteratee `n` times, returning an array of the results of
       * each invocation. The iteratee is invoked with one argument; (index).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.times(3, String);
       * // => ['0', '1', '2']
       *
       *  _.times(4, _.constant(0));
       * // => [0, 0, 0, 0]
       */
      function times(n, iteratee) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH,
            length = nativeMin(n, MAX_ARRAY_LENGTH);

        iteratee = getIteratee(iteratee);
        n -= MAX_ARRAY_LENGTH;

        var result = baseTimes(length, iteratee);
        while (++index < n) {
          iteratee(index);
        }
        return result;
      }

      /**
       * Converts `value` to a property path array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {*} value The value to convert.
       * @returns {Array} Returns the new property path array.
       * @example
       *
       * _.toPath('a.b.c');
       * // => ['a', 'b', 'c']
       *
       * _.toPath('a[0].b.c');
       * // => ['a', '0', 'b', 'c']
       */
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }

      /**
       * Generates a unique ID. If `prefix` is given, the ID is appended to it.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {string} [prefix=''] The value to prefix the ID with.
       * @returns {string} Returns the unique ID.
       * @example
       *
       * _.uniqueId('contact_');
       * // => 'contact_104'
       *
       * _.uniqueId();
       * // => '105'
       */
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }

      /*------------------------------------------------------------------------*/

      /**
       * Adds two numbers.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {number} augend The first number in an addition.
       * @param {number} addend The second number in an addition.
       * @returns {number} Returns the total.
       * @example
       *
       * _.add(6, 4);
       * // => 10
       */
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);

      /**
       * Computes `number` rounded up to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round up.
       * @param {number} [precision=0] The precision to round up to.
       * @returns {number} Returns the rounded up number.
       * @example
       *
       * _.ceil(4.006);
       * // => 5
       *
       * _.ceil(6.004, 2);
       * // => 6.01
       *
       * _.ceil(6040, -2);
       * // => 6100
       */
      var ceil = createRound('ceil');

      /**
       * Divide two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} dividend The first number in a division.
       * @param {number} divisor The second number in a division.
       * @returns {number} Returns the quotient.
       * @example
       *
       * _.divide(6, 4);
       * // => 1.5
       */
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);

      /**
       * Computes `number` rounded down to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round down.
       * @param {number} [precision=0] The precision to round down to.
       * @returns {number} Returns the rounded down number.
       * @example
       *
       * _.floor(4.006);
       * // => 4
       *
       * _.floor(0.046, 2);
       * // => 0.04
       *
       * _.floor(4060, -2);
       * // => 4000
       */
      var floor = createRound('floor');

      /**
       * Computes the maximum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * _.max([4, 2, 8, 6]);
       * // => 8
       *
       * _.max([]);
       * // => undefined
       */
      function max(array) {
        return (array && array.length)
          ? baseExtremum(array, identity, baseGt)
          : undefined$1;
      }

      /**
       * This method is like `_.max` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.maxBy(objects, function(o) { return o.n; });
       * // => { 'n': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.maxBy(objects, 'n');
       * // => { 'n': 2 }
       */
      function maxBy(array, iteratee) {
        return (array && array.length)
          ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
          : undefined$1;
      }

      /**
       * Computes the mean of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the mean.
       * @example
       *
       * _.mean([4, 2, 8, 6]);
       * // => 5
       */
      function mean(array) {
        return baseMean(array, identity);
      }

      /**
       * This method is like `_.mean` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be averaged.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the mean.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.meanBy(objects, function(o) { return o.n; });
       * // => 5
       *
       * // The `_.property` iteratee shorthand.
       * _.meanBy(objects, 'n');
       * // => 5
       */
      function meanBy(array, iteratee) {
        return baseMean(array, getIteratee(iteratee, 2));
      }

      /**
       * Computes the minimum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * _.min([4, 2, 8, 6]);
       * // => 2
       *
       * _.min([]);
       * // => undefined
       */
      function min(array) {
        return (array && array.length)
          ? baseExtremum(array, identity, baseLt)
          : undefined$1;
      }

      /**
       * This method is like `_.min` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.minBy(objects, function(o) { return o.n; });
       * // => { 'n': 1 }
       *
       * // The `_.property` iteratee shorthand.
       * _.minBy(objects, 'n');
       * // => { 'n': 1 }
       */
      function minBy(array, iteratee) {
        return (array && array.length)
          ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
          : undefined$1;
      }

      /**
       * Multiply two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} multiplier The first number in a multiplication.
       * @param {number} multiplicand The second number in a multiplication.
       * @returns {number} Returns the product.
       * @example
       *
       * _.multiply(6, 4);
       * // => 24
       */
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);

      /**
       * Computes `number` rounded to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round.
       * @param {number} [precision=0] The precision to round to.
       * @returns {number} Returns the rounded number.
       * @example
       *
       * _.round(4.006);
       * // => 4
       *
       * _.round(4.006, 2);
       * // => 4.01
       *
       * _.round(4060, -2);
       * // => 4100
       */
      var round = createRound('round');

      /**
       * Subtract two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {number} minuend The first number in a subtraction.
       * @param {number} subtrahend The second number in a subtraction.
       * @returns {number} Returns the difference.
       * @example
       *
       * _.subtract(6, 4);
       * // => 2
       */
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);

      /**
       * Computes the sum of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the sum.
       * @example
       *
       * _.sum([4, 2, 8, 6]);
       * // => 20
       */
      function sum(array) {
        return (array && array.length)
          ? baseSum(array, identity)
          : 0;
      }

      /**
       * This method is like `_.sum` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be summed.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the sum.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.sumBy(objects, function(o) { return o.n; });
       * // => 20
       *
       * // The `_.property` iteratee shorthand.
       * _.sumBy(objects, 'n');
       * // => 20
       */
      function sumBy(array, iteratee) {
        return (array && array.length)
          ? baseSum(array, getIteratee(iteratee, 2))
          : 0;
      }

      /*------------------------------------------------------------------------*/

      // Add methods that return wrapped values in chain sequences.
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;

      // Add aliases.
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;

      // Add methods to `lodash.prototype`.
      mixin(lodash, lodash);

      /*------------------------------------------------------------------------*/

      // Add methods that return unwrapped values in chain sequences.
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;

      // Add aliases.
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;

      mixin(lodash, (function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }()), { 'chain': false });

      /*------------------------------------------------------------------------*/

      /**
       * The semantic version number.
       *
       * @static
       * @memberOf _
       * @type {string}
       */
      lodash.VERSION = VERSION;

      // Assign default placeholders.
      arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });

      // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
      arrayEach(['drop', 'take'], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

          var result = (this.__filtered__ && !index)
            ? new LazyWrapper(this)
            : this.clone();

          if (result.__filtered__) {
            result.__takeCount__ = nativeMin(n, result.__takeCount__);
          } else {
            result.__views__.push({
              'size': nativeMin(n, MAX_ARRAY_LENGTH),
              'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
            });
          }
          return result;
        };

        LazyWrapper.prototype[methodName + 'Right'] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });

      // Add `LazyWrapper` methods that accept an `iteratee` value.
      arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
        var type = index + 1,
            isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

        LazyWrapper.prototype[methodName] = function(iteratee) {
          var result = this.clone();
          result.__iteratees__.push({
            'iteratee': getIteratee(iteratee, 3),
            'type': type
          });
          result.__filtered__ = result.__filtered__ || isFilter;
          return result;
        };
      });

      // Add `LazyWrapper` methods for `_.head` and `_.last`.
      arrayEach(['head', 'last'], function(methodName, index) {
        var takeName = 'take' + (index ? 'Right' : '');

        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });

      // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
      arrayEach(['initial', 'tail'], function(methodName, index) {
        var dropName = 'drop' + (index ? '' : 'Right');

        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });

      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };

      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };

      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };

      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == 'function') {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });

      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };

      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);

        var result = this;
        if (result.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result);
        }
        if (start < 0) {
          result = result.takeRight(-start);
        } else if (start) {
          result = result.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result = end < 0 ? result.dropRight(-end) : result.take(end - start);
        }
        return result;
      };

      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };

      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };

      // Add `LazyWrapper` methods to `lodash.prototype`.
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
            retUnwrapped = isTaker || /^find/.test(methodName);

        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__,
              args = isTaker ? [1] : arguments,
              isLazy = value instanceof LazyWrapper,
              iteratee = args[0],
              useLazy = isLazy || isArray(value);

          var interceptor = function(value) {
            var result = lodashFunc.apply(lodash, arrayPush([value], args));
            return (isTaker && chainAll) ? result[0] : result;
          };

          if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
            // Avoid lazy use if the iteratee has a "length" value other than `1`.
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__,
              isHybrid = !!this.__actions__.length,
              isUnwrapped = retUnwrapped && !chainAll,
              onlyLazy = isLazy && !isHybrid;

          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result = func.apply(value, args);
            result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
            return new LodashWrapper(result, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result = this.thru(interceptor);
          return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
        };
      });

      // Add `Array` methods to `lodash.prototype`.
      arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
        var func = arrayProto[methodName],
            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
            retUnwrapped = /^(?:pop|shift)$/.test(methodName);

        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value) {
            return func.apply(isArray(value) ? value : [], args);
          });
        };
      });

      // Map minified method names to their real names.
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + '';
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ 'name': methodName, 'func': lodashFunc });
        }
      });

      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        'name': 'wrapper',
        'func': undefined$1
      }];

      // Add methods to `LazyWrapper`.
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;

      // Add chain sequence methods to the `lodash` wrapper.
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

      // Add lazy aliases.
      lodash.prototype.first = lodash.prototype.head;

      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    });

    /*--------------------------------------------------------------------------*/

    // Export lodash.
    var _ = runInContext();

    // Some AMD build optimizers, like r.js, check for condition patterns like:
    if (freeModule) {
      // Export for Node.js.
      (freeModule.exports = _)._ = _;
      // Export for CommonJS support.
      freeExports._ = _;
    }
    else {
      // Export to the global object.
      root._ = _;
    }
  }.call(commonjsGlobal));
  }(lodash, lodash.exports));

  function isContainChinese(str) {
    return /[\u4e00-\u9fa5]/.test(str);
  }

  var lib$a = {};

  var context$1 = {};

  var path$1 = {};

  var virtualTypes$2 = {};

  var lib$9 = {};

  var isReactComponent$1 = {};

  var buildMatchMemberExpression$1 = {};

  var matchesPattern$2 = {};

  var generated$4 = {};

  var shallowEqual$1 = {};

  Object.defineProperty(shallowEqual$1, "__esModule", {
    value: true
  });
  shallowEqual$1.default = shallowEqual;

  function shallowEqual(actual, expected) {
    const keys = Object.keys(expected);

    for (const key of keys) {
      if (actual[key] !== expected[key]) {
        return false;
      }
    }

    return true;
  }

  Object.defineProperty(generated$4, "__esModule", {
    value: true
  });
  generated$4.isArrayExpression = isArrayExpression;
  generated$4.isAssignmentExpression = isAssignmentExpression;
  generated$4.isBinaryExpression = isBinaryExpression;
  generated$4.isInterpreterDirective = isInterpreterDirective;
  generated$4.isDirective = isDirective;
  generated$4.isDirectiveLiteral = isDirectiveLiteral;
  generated$4.isBlockStatement = isBlockStatement;
  generated$4.isBreakStatement = isBreakStatement;
  generated$4.isCallExpression = isCallExpression;
  generated$4.isCatchClause = isCatchClause;
  generated$4.isConditionalExpression = isConditionalExpression;
  generated$4.isContinueStatement = isContinueStatement;
  generated$4.isDebuggerStatement = isDebuggerStatement;
  generated$4.isDoWhileStatement = isDoWhileStatement;
  generated$4.isEmptyStatement = isEmptyStatement;
  generated$4.isExpressionStatement = isExpressionStatement;
  generated$4.isFile = isFile;
  generated$4.isForInStatement = isForInStatement;
  generated$4.isForStatement = isForStatement;
  generated$4.isFunctionDeclaration = isFunctionDeclaration;
  generated$4.isFunctionExpression = isFunctionExpression;
  generated$4.isIdentifier = isIdentifier;
  generated$4.isIfStatement = isIfStatement;
  generated$4.isLabeledStatement = isLabeledStatement;
  generated$4.isStringLiteral = isStringLiteral;
  generated$4.isNumericLiteral = isNumericLiteral;
  generated$4.isNullLiteral = isNullLiteral;
  generated$4.isBooleanLiteral = isBooleanLiteral;
  generated$4.isRegExpLiteral = isRegExpLiteral;
  generated$4.isLogicalExpression = isLogicalExpression;
  generated$4.isMemberExpression = isMemberExpression;
  generated$4.isNewExpression = isNewExpression;
  generated$4.isProgram = isProgram;
  generated$4.isObjectExpression = isObjectExpression;
  generated$4.isObjectMethod = isObjectMethod;
  generated$4.isObjectProperty = isObjectProperty;
  generated$4.isRestElement = isRestElement;
  generated$4.isReturnStatement = isReturnStatement;
  generated$4.isSequenceExpression = isSequenceExpression;
  generated$4.isParenthesizedExpression = isParenthesizedExpression;
  generated$4.isSwitchCase = isSwitchCase;
  generated$4.isSwitchStatement = isSwitchStatement;
  generated$4.isThisExpression = isThisExpression;
  generated$4.isThrowStatement = isThrowStatement;
  generated$4.isTryStatement = isTryStatement;
  generated$4.isUnaryExpression = isUnaryExpression;
  generated$4.isUpdateExpression = isUpdateExpression;
  generated$4.isVariableDeclaration = isVariableDeclaration;
  generated$4.isVariableDeclarator = isVariableDeclarator;
  generated$4.isWhileStatement = isWhileStatement;
  generated$4.isWithStatement = isWithStatement;
  generated$4.isAssignmentPattern = isAssignmentPattern;
  generated$4.isArrayPattern = isArrayPattern;
  generated$4.isArrowFunctionExpression = isArrowFunctionExpression;
  generated$4.isClassBody = isClassBody;
  generated$4.isClassExpression = isClassExpression;
  generated$4.isClassDeclaration = isClassDeclaration;
  generated$4.isExportAllDeclaration = isExportAllDeclaration;
  generated$4.isExportDefaultDeclaration = isExportDefaultDeclaration;
  generated$4.isExportNamedDeclaration = isExportNamedDeclaration;
  generated$4.isExportSpecifier = isExportSpecifier;
  generated$4.isForOfStatement = isForOfStatement;
  generated$4.isImportDeclaration = isImportDeclaration;
  generated$4.isImportDefaultSpecifier = isImportDefaultSpecifier;
  generated$4.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  generated$4.isImportSpecifier = isImportSpecifier;
  generated$4.isMetaProperty = isMetaProperty;
  generated$4.isClassMethod = isClassMethod;
  generated$4.isObjectPattern = isObjectPattern;
  generated$4.isSpreadElement = isSpreadElement;
  generated$4.isSuper = isSuper;
  generated$4.isTaggedTemplateExpression = isTaggedTemplateExpression;
  generated$4.isTemplateElement = isTemplateElement;
  generated$4.isTemplateLiteral = isTemplateLiteral;
  generated$4.isYieldExpression = isYieldExpression;
  generated$4.isAwaitExpression = isAwaitExpression;
  generated$4.isImport = isImport;
  generated$4.isBigIntLiteral = isBigIntLiteral;
  generated$4.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  generated$4.isOptionalMemberExpression = isOptionalMemberExpression;
  generated$4.isOptionalCallExpression = isOptionalCallExpression;
  generated$4.isAnyTypeAnnotation = isAnyTypeAnnotation;
  generated$4.isArrayTypeAnnotation = isArrayTypeAnnotation;
  generated$4.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  generated$4.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  generated$4.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  generated$4.isClassImplements = isClassImplements;
  generated$4.isDeclareClass = isDeclareClass;
  generated$4.isDeclareFunction = isDeclareFunction;
  generated$4.isDeclareInterface = isDeclareInterface;
  generated$4.isDeclareModule = isDeclareModule;
  generated$4.isDeclareModuleExports = isDeclareModuleExports;
  generated$4.isDeclareTypeAlias = isDeclareTypeAlias;
  generated$4.isDeclareOpaqueType = isDeclareOpaqueType;
  generated$4.isDeclareVariable = isDeclareVariable;
  generated$4.isDeclareExportDeclaration = isDeclareExportDeclaration;
  generated$4.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  generated$4.isDeclaredPredicate = isDeclaredPredicate;
  generated$4.isExistsTypeAnnotation = isExistsTypeAnnotation;
  generated$4.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  generated$4.isFunctionTypeParam = isFunctionTypeParam;
  generated$4.isGenericTypeAnnotation = isGenericTypeAnnotation;
  generated$4.isInferredPredicate = isInferredPredicate;
  generated$4.isInterfaceExtends = isInterfaceExtends;
  generated$4.isInterfaceDeclaration = isInterfaceDeclaration;
  generated$4.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  generated$4.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  generated$4.isMixedTypeAnnotation = isMixedTypeAnnotation;
  generated$4.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  generated$4.isNullableTypeAnnotation = isNullableTypeAnnotation;
  generated$4.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  generated$4.isNumberTypeAnnotation = isNumberTypeAnnotation;
  generated$4.isObjectTypeAnnotation = isObjectTypeAnnotation;
  generated$4.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  generated$4.isObjectTypeCallProperty = isObjectTypeCallProperty;
  generated$4.isObjectTypeIndexer = isObjectTypeIndexer;
  generated$4.isObjectTypeProperty = isObjectTypeProperty;
  generated$4.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  generated$4.isOpaqueType = isOpaqueType;
  generated$4.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  generated$4.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  generated$4.isStringTypeAnnotation = isStringTypeAnnotation;
  generated$4.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  generated$4.isThisTypeAnnotation = isThisTypeAnnotation;
  generated$4.isTupleTypeAnnotation = isTupleTypeAnnotation;
  generated$4.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  generated$4.isTypeAlias = isTypeAlias;
  generated$4.isTypeAnnotation = isTypeAnnotation;
  generated$4.isTypeCastExpression = isTypeCastExpression;
  generated$4.isTypeParameter = isTypeParameter;
  generated$4.isTypeParameterDeclaration = isTypeParameterDeclaration;
  generated$4.isTypeParameterInstantiation = isTypeParameterInstantiation;
  generated$4.isUnionTypeAnnotation = isUnionTypeAnnotation;
  generated$4.isVariance = isVariance;
  generated$4.isVoidTypeAnnotation = isVoidTypeAnnotation;
  generated$4.isEnumDeclaration = isEnumDeclaration;
  generated$4.isEnumBooleanBody = isEnumBooleanBody;
  generated$4.isEnumNumberBody = isEnumNumberBody;
  generated$4.isEnumStringBody = isEnumStringBody;
  generated$4.isEnumSymbolBody = isEnumSymbolBody;
  generated$4.isEnumBooleanMember = isEnumBooleanMember;
  generated$4.isEnumNumberMember = isEnumNumberMember;
  generated$4.isEnumStringMember = isEnumStringMember;
  generated$4.isEnumDefaultedMember = isEnumDefaultedMember;
  generated$4.isIndexedAccessType = isIndexedAccessType;
  generated$4.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  generated$4.isJSXAttribute = isJSXAttribute;
  generated$4.isJSXClosingElement = isJSXClosingElement;
  generated$4.isJSXElement = isJSXElement;
  generated$4.isJSXEmptyExpression = isJSXEmptyExpression;
  generated$4.isJSXExpressionContainer = isJSXExpressionContainer;
  generated$4.isJSXSpreadChild = isJSXSpreadChild;
  generated$4.isJSXIdentifier = isJSXIdentifier;
  generated$4.isJSXMemberExpression = isJSXMemberExpression;
  generated$4.isJSXNamespacedName = isJSXNamespacedName;
  generated$4.isJSXOpeningElement = isJSXOpeningElement;
  generated$4.isJSXSpreadAttribute = isJSXSpreadAttribute;
  generated$4.isJSXText = isJSXText;
  generated$4.isJSXFragment = isJSXFragment;
  generated$4.isJSXOpeningFragment = isJSXOpeningFragment;
  generated$4.isJSXClosingFragment = isJSXClosingFragment;
  generated$4.isNoop = isNoop;
  generated$4.isPlaceholder = isPlaceholder;
  generated$4.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  generated$4.isArgumentPlaceholder = isArgumentPlaceholder;
  generated$4.isBindExpression = isBindExpression;
  generated$4.isClassProperty = isClassProperty;
  generated$4.isPipelineTopicExpression = isPipelineTopicExpression;
  generated$4.isPipelineBareFunction = isPipelineBareFunction;
  generated$4.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  generated$4.isClassPrivateProperty = isClassPrivateProperty;
  generated$4.isClassPrivateMethod = isClassPrivateMethod;
  generated$4.isImportAttribute = isImportAttribute;
  generated$4.isDecorator = isDecorator;
  generated$4.isDoExpression = isDoExpression;
  generated$4.isExportDefaultSpecifier = isExportDefaultSpecifier;
  generated$4.isPrivateName = isPrivateName;
  generated$4.isRecordExpression = isRecordExpression;
  generated$4.isTupleExpression = isTupleExpression;
  generated$4.isDecimalLiteral = isDecimalLiteral;
  generated$4.isStaticBlock = isStaticBlock;
  generated$4.isModuleExpression = isModuleExpression;
  generated$4.isTSParameterProperty = isTSParameterProperty;
  generated$4.isTSDeclareFunction = isTSDeclareFunction;
  generated$4.isTSDeclareMethod = isTSDeclareMethod;
  generated$4.isTSQualifiedName = isTSQualifiedName;
  generated$4.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  generated$4.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
  generated$4.isTSPropertySignature = isTSPropertySignature;
  generated$4.isTSMethodSignature = isTSMethodSignature;
  generated$4.isTSIndexSignature = isTSIndexSignature;
  generated$4.isTSAnyKeyword = isTSAnyKeyword;
  generated$4.isTSBooleanKeyword = isTSBooleanKeyword;
  generated$4.isTSBigIntKeyword = isTSBigIntKeyword;
  generated$4.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  generated$4.isTSNeverKeyword = isTSNeverKeyword;
  generated$4.isTSNullKeyword = isTSNullKeyword;
  generated$4.isTSNumberKeyword = isTSNumberKeyword;
  generated$4.isTSObjectKeyword = isTSObjectKeyword;
  generated$4.isTSStringKeyword = isTSStringKeyword;
  generated$4.isTSSymbolKeyword = isTSSymbolKeyword;
  generated$4.isTSUndefinedKeyword = isTSUndefinedKeyword;
  generated$4.isTSUnknownKeyword = isTSUnknownKeyword;
  generated$4.isTSVoidKeyword = isTSVoidKeyword;
  generated$4.isTSThisType = isTSThisType;
  generated$4.isTSFunctionType = isTSFunctionType;
  generated$4.isTSConstructorType = isTSConstructorType;
  generated$4.isTSTypeReference = isTSTypeReference;
  generated$4.isTSTypePredicate = isTSTypePredicate;
  generated$4.isTSTypeQuery = isTSTypeQuery;
  generated$4.isTSTypeLiteral = isTSTypeLiteral;
  generated$4.isTSArrayType = isTSArrayType;
  generated$4.isTSTupleType = isTSTupleType;
  generated$4.isTSOptionalType = isTSOptionalType;
  generated$4.isTSRestType = isTSRestType;
  generated$4.isTSNamedTupleMember = isTSNamedTupleMember;
  generated$4.isTSUnionType = isTSUnionType;
  generated$4.isTSIntersectionType = isTSIntersectionType;
  generated$4.isTSConditionalType = isTSConditionalType;
  generated$4.isTSInferType = isTSInferType;
  generated$4.isTSParenthesizedType = isTSParenthesizedType;
  generated$4.isTSTypeOperator = isTSTypeOperator;
  generated$4.isTSIndexedAccessType = isTSIndexedAccessType;
  generated$4.isTSMappedType = isTSMappedType;
  generated$4.isTSLiteralType = isTSLiteralType;
  generated$4.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  generated$4.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  generated$4.isTSInterfaceBody = isTSInterfaceBody;
  generated$4.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  generated$4.isTSAsExpression = isTSAsExpression;
  generated$4.isTSTypeAssertion = isTSTypeAssertion;
  generated$4.isTSEnumDeclaration = isTSEnumDeclaration;
  generated$4.isTSEnumMember = isTSEnumMember;
  generated$4.isTSModuleDeclaration = isTSModuleDeclaration;
  generated$4.isTSModuleBlock = isTSModuleBlock;
  generated$4.isTSImportType = isTSImportType;
  generated$4.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  generated$4.isTSExternalModuleReference = isTSExternalModuleReference;
  generated$4.isTSNonNullExpression = isTSNonNullExpression;
  generated$4.isTSExportAssignment = isTSExportAssignment;
  generated$4.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  generated$4.isTSTypeAnnotation = isTSTypeAnnotation;
  generated$4.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  generated$4.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  generated$4.isTSTypeParameter = isTSTypeParameter;
  generated$4.isExpression = isExpression;
  generated$4.isBinary = isBinary;
  generated$4.isScopable = isScopable;
  generated$4.isBlockParent = isBlockParent;
  generated$4.isBlock = isBlock;
  generated$4.isStatement = isStatement;
  generated$4.isTerminatorless = isTerminatorless;
  generated$4.isCompletionStatement = isCompletionStatement;
  generated$4.isConditional = isConditional;
  generated$4.isLoop = isLoop;
  generated$4.isWhile = isWhile;
  generated$4.isExpressionWrapper = isExpressionWrapper;
  generated$4.isFor = isFor;
  generated$4.isForXStatement = isForXStatement;
  generated$4.isFunction = isFunction$2;
  generated$4.isFunctionParent = isFunctionParent;
  generated$4.isPureish = isPureish;
  generated$4.isDeclaration = isDeclaration;
  generated$4.isPatternLike = isPatternLike;
  generated$4.isLVal = isLVal;
  generated$4.isTSEntityName = isTSEntityName;
  generated$4.isLiteral = isLiteral;
  generated$4.isImmutable = isImmutable$2;
  generated$4.isUserWhitespacable = isUserWhitespacable;
  generated$4.isMethod = isMethod;
  generated$4.isObjectMember = isObjectMember;
  generated$4.isProperty = isProperty;
  generated$4.isUnaryLike = isUnaryLike;
  generated$4.isPattern = isPattern;
  generated$4.isClass = isClass;
  generated$4.isModuleDeclaration = isModuleDeclaration;
  generated$4.isExportDeclaration = isExportDeclaration;
  generated$4.isModuleSpecifier = isModuleSpecifier;
  generated$4.isFlow = isFlow;
  generated$4.isFlowType = isFlowType;
  generated$4.isFlowBaseAnnotation = isFlowBaseAnnotation;
  generated$4.isFlowDeclaration = isFlowDeclaration;
  generated$4.isFlowPredicate = isFlowPredicate;
  generated$4.isEnumBody = isEnumBody;
  generated$4.isEnumMember = isEnumMember;
  generated$4.isJSX = isJSX;
  generated$4.isPrivate = isPrivate;
  generated$4.isTSTypeElement = isTSTypeElement;
  generated$4.isTSType = isTSType;
  generated$4.isTSBaseType = isTSBaseType;
  generated$4.isNumberLiteral = isNumberLiteral;
  generated$4.isRegexLiteral = isRegexLiteral;
  generated$4.isRestProperty = isRestProperty;
  generated$4.isSpreadProperty = isSpreadProperty;

  var _shallowEqual$1 = shallowEqual$1;

  function isArrayExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ArrayExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isAssignmentExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "AssignmentExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBinaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BinaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "InterpreterDirective") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDirective(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Directive") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DirectiveLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBlockStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BlockStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBreakStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BreakStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "CallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isCatchClause(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "CatchClause") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isConditionalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ConditionalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isContinueStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ContinueStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DebuggerStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DoWhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEmptyStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EmptyStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExpressionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExpressionStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "File") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isForInStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ForInStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isForStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ForStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "FunctionDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "FunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Identifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isIfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "IfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isLabeledStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "LabeledStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isStringLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "StringLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNumericLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NumericLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNullLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NullLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BooleanLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isRegExpLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "RegExpLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isLogicalExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "LogicalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "MemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNewExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NewExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isProgram(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Program") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isRestElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "RestElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isReturnStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ReturnStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isSequenceExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "SequenceExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ParenthesizedExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isSwitchCase(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "SwitchCase") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isSwitchStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "SwitchStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isThisExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ThisExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isThrowStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ThrowStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTryStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TryStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isUnaryExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "UnaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isUpdateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "UpdateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isVariableDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "VariableDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "VariableDeclarator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isWhileStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "WhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isWithStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "WithStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isAssignmentPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "AssignmentPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isArrayPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ArrayPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ArrowFunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExportDefaultDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExportNamedDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isForOfStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ForOfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isImportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ImportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ImportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ImportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isImportSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ImportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isMetaProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "MetaProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isSpreadElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "SpreadElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isSuper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Super") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TaggedTemplateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTemplateElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TemplateElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTemplateLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TemplateLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isYieldExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "YieldExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isAwaitExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "AwaitExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isImport(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Import") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BigIntLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "OptionalMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "OptionalCallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "AnyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ArrayTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BooleanTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BooleanLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NullLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassImplements(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassImplements") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareClass") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareInterface(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareInterface") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareModule(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareModule") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareModuleExports") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareTypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareOpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareVariable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareVariable") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclareExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DeclaredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExistsTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "FunctionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "FunctionTypeParam") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "GenericTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isInferredPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "InferredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "InterfaceExtends") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "InterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "InterfaceTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "IntersectionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "MixedTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EmptyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NullableTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NumberLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NumberTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectTypeInternalSlot") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectTypeCallProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectTypeIndexer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectTypeProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ObjectTypeSpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isOpaqueType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "OpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "QualifiedTypeIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "StringLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "StringTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "SymbolTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ThisTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TupleTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TypeofTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeAlias(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeCastExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TypeCastExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "UnionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isVariance(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Variance") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "VoidTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumBooleanBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumNumberBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumStringBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumStringBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumSymbolBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumBooleanMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumNumberMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumStringMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumStringMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "EnumDefaultedMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "IndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "OptionalIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXClosingElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXEmptyExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXExpressionContainer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXSpreadChild") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXNamespacedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXOpeningElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXSpreadAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXText(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXText") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXOpeningFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "JSXClosingFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Noop") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Placeholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "V8IntrinsicIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ArgumentPlaceholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBindExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "BindExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "PipelineTopicExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "PipelineBareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "PipelinePrimaryTopicReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassPrivateProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ClassPrivateMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isImportAttribute(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ImportAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDecorator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "Decorator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDoExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DoExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ExportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPrivateName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "PrivateName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isRecordExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "RecordExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTupleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TupleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDecimalLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "DecimalLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isStaticBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "StaticBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isModuleExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "ModuleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSParameterProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSDeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSDeclareMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSQualifiedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSCallSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSConstructSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSPropertySignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSMethodSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSIndexSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSAnyKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSBooleanKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSBigIntKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSIntrinsicKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSNeverKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSNullKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSNumberKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSObjectKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSStringKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSSymbolKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSUndefinedKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSUnknownKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSVoidKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSThisType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSThisType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSFunctionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSFunctionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSConstructorType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSConstructorType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypePredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeQuery") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSArrayType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSArrayType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTupleType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTupleType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSOptionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSOptionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSRestType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSRestType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSNamedTupleMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSUnionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSUnionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSIntersectionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSConditionalType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSConditionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSInferType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSInferType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSParenthesizedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeOperator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSMappedType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSMappedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSLiteralType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSLiteralType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSExpressionWithTypeArguments") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSInterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSInterfaceBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeAliasDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSAsExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSAsExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeAssertion") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSEnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSEnumMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSModuleDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSModuleBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSImportType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSImportType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSImportEqualsDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSExternalModuleReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSNonNullExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSExportAssignment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSNamespaceExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "TSTypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExpression(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBinary(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isScopable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBlockParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isBlock(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTerminatorless(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isCompletionStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isConditional(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isLoop(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isWhile(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFor(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isForXStatement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFunction$2(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFunctionParent(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPureish(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPatternLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isLVal(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSEntityName(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isLiteral(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isImmutable$2(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isMethod(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isObjectMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isProperty(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isUnaryLike(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPattern(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isClass(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isModuleDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isExportDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isModuleSpecifier(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFlow(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isFlowPredicate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumBody(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isEnumMember(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isJSX(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isPrivate(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSTypeElement(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isTSBaseType(node, opts) {
    if (!node) return false;
    const nodeType = node.type;

    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "NumberLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "RegexLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "RestProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  function isSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    if (!node) return false;
    const nodeType = node.type;

    if (nodeType === "SpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return (0, _shallowEqual$1.default)(node, opts);
      }
    }

    return false;
  }

  Object.defineProperty(matchesPattern$2, "__esModule", {
    value: true
  });
  matchesPattern$2.default = matchesPattern$1;

  var _generated$o = generated$4;

  function matchesPattern$1(member, match, allowPartial) {
    if (!(0, _generated$o.isMemberExpression)(member)) return false;
    const parts = Array.isArray(match) ? match : match.split(".");
    const nodes = [];
    let node;

    for (node = member; (0, _generated$o.isMemberExpression)(node); node = node.object) {
      nodes.push(node.property);
    }

    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;

    for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      const node = nodes[j];
      let value;

      if ((0, _generated$o.isIdentifier)(node)) {
        value = node.name;
      } else if ((0, _generated$o.isStringLiteral)(node)) {
        value = node.value;
      } else if ((0, _generated$o.isThisExpression)(node)) {
        value = "this";
      } else {
        return false;
      }

      if (parts[i] !== value) return false;
    }

    return true;
  }

  Object.defineProperty(buildMatchMemberExpression$1, "__esModule", {
    value: true
  });
  buildMatchMemberExpression$1.default = buildMatchMemberExpression;

  var _matchesPattern = matchesPattern$2;

  function buildMatchMemberExpression(match, allowPartial) {
    const parts = match.split(".");
    return member => (0, _matchesPattern.default)(member, parts, allowPartial);
  }

  Object.defineProperty(isReactComponent$1, "__esModule", {
    value: true
  });
  isReactComponent$1.default = void 0;

  var _buildMatchMemberExpression = buildMatchMemberExpression$1;

  const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
  var _default$c = isReactComponent;
  isReactComponent$1.default = _default$c;

  var isCompatTag$1 = {};

  Object.defineProperty(isCompatTag$1, "__esModule", {
    value: true
  });
  isCompatTag$1.default = isCompatTag;

  function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }

  var buildChildren$1 = {};

  var cleanJSXElementLiteralChild$1 = {};

  var generated$3 = {};

  var builder$2 = {};

  var definitions = {};

  var core = {};

  var is$2 = {};

  var isType$2 = {};

  Object.defineProperty(isType$2, "__esModule", {
    value: true
  });
  isType$2.default = isType$1;

  var _definitions$a = definitions;

  function isType$1(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (_definitions$a.ALIAS_KEYS[targetType]) return false;
    const aliases = _definitions$a.FLIPPED_ALIAS_KEYS[targetType];

    if (aliases) {
      if (aliases[0] === nodeType) return true;

      for (const alias of aliases) {
        if (nodeType === alias) return true;
      }
    }

    return false;
  }

  var isPlaceholderType$1 = {};

  Object.defineProperty(isPlaceholderType$1, "__esModule", {
    value: true
  });
  isPlaceholderType$1.default = isPlaceholderType;

  var _definitions$9 = definitions;

  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    const aliases = _definitions$9.PLACEHOLDERS_ALIAS[placeholderType];

    if (aliases) {
      for (const alias of aliases) {
        if (targetType === alias) return true;
      }
    }

    return false;
  }

  Object.defineProperty(is$2, "__esModule", {
    value: true
  });
  is$2.default = is$1;

  var _shallowEqual = shallowEqual$1;

  var _isType$1 = isType$2;

  var _isPlaceholderType = isPlaceholderType$1;

  var _definitions$8 = definitions;

  function is$1(type, node, opts) {
    if (!node) return false;
    const matches = (0, _isType$1.default)(node.type, type);

    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in _definitions$8.FLIPPED_ALIAS_KEYS) {
        return (0, _isPlaceholderType.default)(node.expectedNode, type);
      }

      return false;
    }

    if (typeof opts === "undefined") {
      return true;
    } else {
      return (0, _shallowEqual.default)(node, opts);
    }
  }

  var isValidIdentifier$1 = {};

  var lib$8 = {};

  var identifier$1 = {};

  Object.defineProperty(identifier$1, "__esModule", {
    value: true
  });
  identifier$1.isIdentifierStart = isIdentifierStart;
  identifier$1.isIdentifierChar = isIdentifierChar;
  identifier$1.isIdentifierName = isIdentifierName;
  let nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08c7\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\u9ffc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7ca\ua7f5-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  let nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf\u1ac0\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  const nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  const astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  function isInAstralSet(code, set) {
    let pos = 0x10000;

    for (let i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes);
  }

  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }

  function isIdentifierName(name) {
    let isFirst = true;

    for (let i = 0; i < name.length; i++) {
      let cp = name.charCodeAt(i);

      if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
        const trail = name.charCodeAt(++i);

        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }

      if (isFirst) {
        isFirst = false;

        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }

    return !isFirst;
  }

  var keyword = {};

  Object.defineProperty(keyword, "__esModule", {
    value: true
  });
  keyword.isReservedWord = isReservedWord;
  keyword.isStrictReservedWord = isStrictReservedWord;
  keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  keyword.isStrictBindReservedWord = isStrictBindReservedWord;
  keyword.isKeyword = isKeyword;
  const reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  const keywords = new Set(reservedWords.keyword);
  const reservedWordsStrictSet = new Set(reservedWords.strict);
  const reservedWordsStrictBindSet = new Set(reservedWords.strictBind);

  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }

  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }

  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }

  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }

  function isKeyword(word) {
    return keywords.has(word);
  }

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "isIdentifierName", {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierName;
    }
  });
  Object.defineProperty(exports, "isIdentifierChar", {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierChar;
    }
  });
  Object.defineProperty(exports, "isIdentifierStart", {
    enumerable: true,
    get: function () {
      return _identifier.isIdentifierStart;
    }
  });
  Object.defineProperty(exports, "isReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isStrictBindOnlyReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictBindReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isStrictBindReservedWord;
    }
  });
  Object.defineProperty(exports, "isStrictReservedWord", {
    enumerable: true,
    get: function () {
      return _keyword.isStrictReservedWord;
    }
  });
  Object.defineProperty(exports, "isKeyword", {
    enumerable: true,
    get: function () {
      return _keyword.isKeyword;
    }
  });

  var _identifier = identifier$1;

  var _keyword = keyword;
  }(lib$8));

  Object.defineProperty(isValidIdentifier$1, "__esModule", {
    value: true
  });
  isValidIdentifier$1.default = isValidIdentifier;

  var _helperValidatorIdentifier$3 = lib$8;

  function isValidIdentifier(name, reserved = true) {
    if (typeof name !== "string") return false;

    if (reserved) {
      if ((0, _helperValidatorIdentifier$3.isKeyword)(name) || (0, _helperValidatorIdentifier$3.isStrictReservedWord)(name, true)) {
        return false;
      }
    }

    return (0, _helperValidatorIdentifier$3.isIdentifierName)(name);
  }

  var constants = {};

  Object.defineProperty(constants, "__esModule", {
    value: true
  });
  constants.NOT_LOCAL_BINDING = constants.BLOCK_SCOPED_SYMBOL = constants.INHERIT_KEYS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = constants.BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.UPDATE_OPERATORS = constants.LOGICAL_OPERATORS = constants.COMMENT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.STATEMENT_OR_BLOCK_KEYS = void 0;
  const STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  constants.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;
  const FLATTENABLE_KEYS = ["body", "expressions"];
  constants.FLATTENABLE_KEYS = FLATTENABLE_KEYS;
  const FOR_INIT_KEYS = ["left", "init"];
  constants.FOR_INIT_KEYS = FOR_INIT_KEYS;
  const COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  constants.COMMENT_KEYS = COMMENT_KEYS;
  const LOGICAL_OPERATORS = ["||", "&&", "??"];
  constants.LOGICAL_OPERATORS = LOGICAL_OPERATORS;
  const UPDATE_OPERATORS = ["++", "--"];
  constants.UPDATE_OPERATORS = UPDATE_OPERATORS;
  const BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  constants.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;
  const EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  constants.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;
  const COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
  constants.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;
  const BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
  constants.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;
  const NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  constants.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;
  const BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS];
  constants.BINARY_OPERATORS = BINARY_OPERATORS;
  const ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];
  constants.ASSIGNMENT_OPERATORS = ASSIGNMENT_OPERATORS;
  const BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  constants.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;
  const NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  constants.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;
  const STRING_UNARY_OPERATORS = ["typeof"];
  constants.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;
  const UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
  constants.UNARY_OPERATORS = UNARY_OPERATORS;
  const INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  constants.INHERIT_KEYS = INHERIT_KEYS;
  const BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
  constants.BLOCK_SCOPED_SYMBOL = BLOCK_SCOPED_SYMBOL;
  const NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  constants.NOT_LOCAL_BINDING = NOT_LOCAL_BINDING;

  var utils = {};

  var validate$3 = {};

  Object.defineProperty(validate$3, "__esModule", {
    value: true
  });
  validate$3.default = validate$2;
  validate$3.validateField = validateField;
  validate$3.validateChild = validateChild;

  var _definitions$7 = definitions;

  function validate$2(node, key, val) {
    if (!node) return;
    const fields = _definitions$7.NODE_FIELDS[node.type];
    if (!fields) return;
    const field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }

  function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }

  function validateChild(node, key, val) {
    if (val == null) return;
    const validate = _definitions$7.NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
  }

  Object.defineProperty(utils, "__esModule", {
    value: true
  });
  utils.validate = validate$1;
  utils.typeIs = typeIs;
  utils.validateType = validateType;
  utils.validateOptional = validateOptional;
  utils.validateOptionalType = validateOptionalType;
  utils.arrayOf = arrayOf;
  utils.arrayOfType = arrayOfType;
  utils.validateArrayOfType = validateArrayOfType;
  utils.assertEach = assertEach;
  utils.assertOneOf = assertOneOf;
  utils.assertNodeType = assertNodeType;
  utils.assertNodeOrValueType = assertNodeOrValueType;
  utils.assertValueType = assertValueType;
  utils.assertShape = assertShape;
  utils.assertOptionalChainStart = assertOptionalChainStart;
  utils.chain = chain;
  utils.default = defineType;
  utils.NODE_PARENT_VALIDATIONS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.ALIAS_KEYS = utils.VISITOR_KEYS = void 0;

  var _is$2 = is$2;

  var _validate$1 = validate$3;

  const VISITOR_KEYS = {};
  utils.VISITOR_KEYS = VISITOR_KEYS;
  const ALIAS_KEYS = {};
  utils.ALIAS_KEYS = ALIAS_KEYS;
  const FLIPPED_ALIAS_KEYS = {};
  utils.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
  const NODE_FIELDS = {};
  utils.NODE_FIELDS = NODE_FIELDS;
  const BUILDER_KEYS = {};
  utils.BUILDER_KEYS = BUILDER_KEYS;
  const DEPRECATED_KEYS = {};
  utils.DEPRECATED_KEYS = DEPRECATED_KEYS;
  const NODE_PARENT_VALIDATIONS = {};
  utils.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;

  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }

  function validate$1(validate) {
    return {
      validate
    };
  }

  function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
  }

  function validateType(typeName) {
    return validate$1(typeIs(typeName));
  }

  function validateOptional(validate) {
    return {
      validate,
      optional: true
    };
  }

  function validateOptionalType(typeName) {
    return {
      validate: typeIs(typeName),
      optional: true
    };
  }

  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }

  function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
  }

  function validateArrayOfType(typeName) {
    return validate$1(arrayOfType(typeName));
  }

  function assertEach(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;

      for (let i = 0; i < val.length; i++) {
        const subkey = `${key}[${i}]`;
        const v = val[i];
        callback(node, subkey, v);
        if (browser$1$1.env.BABEL_TYPES_8_BREAKING) (0, _validate$1.validateChild)(node, subkey, v);
      }
    }

    validator.each = callback;
    return validator;
  }

  function assertOneOf(...values) {
    function validate(node, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
      }
    }

    validate.oneOf = values;
    return validate;
  }

  function assertNodeType(...types) {
    function validate(node, key, val) {
      for (const type of types) {
        if ((0, _is$2.default)(type, val)) {
          (0, _validate$1.validateChild)(node, key, val);
          return;
        }
      }

      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }

    validate.oneOfNodeTypes = types;
    return validate;
  }

  function assertNodeOrValueType(...types) {
    function validate(node, key, val) {
      for (const type of types) {
        if (getType(val) === type || (0, _is$2.default)(type, val)) {
          (0, _validate$1.validateChild)(node, key, val);
          return;
        }
      }

      throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
    }

    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }

  function assertValueType(type) {
    function validate(node, key, val) {
      const valid = getType(val) === type;

      if (!valid) {
        throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
      }
    }

    validate.type = type;
    return validate;
  }

  function assertShape(shape) {
    function validate(node, key, val) {
      const errors = [];

      for (const property of Object.keys(shape)) {
        try {
          (0, _validate$1.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }

          throw error;
        }
      }

      if (errors.length) {
        throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\n${errors.join("\n")}`);
      }
    }

    validate.shapeOf = shape;
    return validate;
  }

  function assertOptionalChainStart() {
    function validate(node) {
      var _current;

      let current = node;

      while (node) {
        const {
          type
        } = current;

        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }

        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }

        break;
      }

      throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
    }

    return validate;
  }

  function chain(...fns) {
    function validate(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }

    validate.chainOf = fns;

    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
    }

    return validate;
  }

  const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
  const validFieldKeys = ["default", "optional", "validate"];

  function defineType(type, opts = {}) {
    const inherits = opts.inherits && store[opts.inherits] || {};
    let fields = opts.fields;

    if (!fields) {
      fields = {};

      if (inherits.fields) {
        const keys = Object.getOwnPropertyNames(inherits.fields);

        for (const key of keys) {
          const field = inherits.fields[key];
          const def = field.default;

          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }

          fields[key] = {
            default: Array.isArray(def) ? [] : def,
            optional: field.optional,
            validate: field.validate
          };
        }
      }
    }

    const visitor = opts.visitor || inherits.visitor || [];
    const aliases = opts.aliases || inherits.aliases || [];
    const builder = opts.builder || inherits.builder || opts.visitor || [];

    for (const k of Object.keys(opts)) {
      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error(`Unknown type option "${k}" on ${type}`);
      }
    }

    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }

    for (const key of visitor.concat(builder)) {
      fields[key] = fields[key] || {};
    }

    for (const key of Object.keys(fields)) {
      const field = fields[key];

      if (field.default !== undefined && builder.indexOf(key) === -1) {
        field.optional = true;
      }

      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate && field.default != null) {
        field.validate = assertValueType(getType(field.default));
      }

      for (const k of Object.keys(field)) {
        if (validFieldKeys.indexOf(k) === -1) {
          throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
        }
      }
    }

    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach(alias => {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });

    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }

    store[type] = opts;
  }

  const store = {};

  Object.defineProperty(core, "__esModule", {
    value: true
  });
  core.classMethodOrDeclareMethodCommon = core.classMethodOrPropertyCommon = core.patternLikeCommon = core.functionDeclarationCommon = core.functionTypeAnnotationCommon = core.functionCommon = void 0;

  var _is$1 = is$2;

  var _isValidIdentifier$3 = isValidIdentifier$1;

  var _helperValidatorIdentifier$2 = lib$8;

  var _constants$5 = constants;

  var _utils$6 = utils;

  (0, _utils$6.default)("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, _utils$6.default)("AssignmentExpression", {
    fields: {
      operator: {
        validate: function () {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils$6.assertValueType)("string");
          }

          const identifier = (0, _utils$6.assertOneOf)(..._constants$5.ASSIGNMENT_OPERATORS);
          const pattern = (0, _utils$6.assertOneOf)("=");
          return function (node, key, val) {
            const validator = (0, _is$1.default)("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }()
      },
      left: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils$6.assertNodeType)("LVal") : (0, _utils$6.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  (0, _utils$6.default)("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, _utils$6.assertOneOf)(..._constants$5.BINARY_OPERATORS)
      },
      left: {
        validate: function () {
          const expression = (0, _utils$6.assertNodeType)("Expression");
          const inOp = (0, _utils$6.assertNodeType)("Expression", "PrivateName");

          const validator = function (node, key, val) {
            const validator = node.operator === "in" ? inOp : expression;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "PrivateName"];
          return validator;
        }()
      },
      right: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  (0, _utils$6.default)("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils$6.assertValueType)("string")
      }
    }
  });
  (0, _utils$6.default)("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils$6.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  (0, _utils$6.default)("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils$6.assertValueType)("string")
      }
    }
  });
  (0, _utils$6.default)("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  (0, _utils$6.default)("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils$6.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  (0, _utils$6.default)("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils$6.assertNodeType)("Expression", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, !browser$1$1.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils$6.assertOneOf)(true, false),
        optional: true
      }
    } : {}, {
      typeArguments: {
        validate: (0, _utils$6.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils$6.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  (0, _utils$6.default)("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils$6.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  (0, _utils$6.default)("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  (0, _utils$6.default)("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils$6.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  (0, _utils$6.default)("DebuggerStatement", {
    aliases: ["Statement"]
  });
  (0, _utils$6.default)("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  (0, _utils$6.default)("EmptyStatement", {
    aliases: ["Statement"]
  });
  (0, _utils$6.default)("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  (0, _utils$6.default)("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, _utils$6.assertNodeType)("Program")
      },
      comments: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: (0, _utils$6.assertEach)(Object.assign(() => {}, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  (0, _utils$6.default)("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils$6.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils$6.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      }
    }
  });
  (0, _utils$6.default)("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils$6.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _utils$6.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _utils$6.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      }
    }
  });
  const functionCommon = {
    params: {
      validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: false
    },
    async: {
      default: false
    }
  };
  core.functionCommon = functionCommon;
  const functionTypeAnnotationCommon = {
    returnType: {
      validate: (0, _utils$6.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils$6.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  const functionDeclarationCommon = Object.assign({}, functionCommon, {
    declare: {
      validate: (0, _utils$6.assertValueType)("boolean"),
      optional: true
    },
    id: {
      validate: (0, _utils$6.assertNodeType)("Identifier"),
      optional: true
    }
  });
  core.functionDeclarationCommon = functionDeclarationCommon;
  (0, _utils$6.default)("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
      body: {
        validate: (0, _utils$6.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function () {
      if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return () => {};
      const identifier = (0, _utils$6.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!(0, _is$1.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  (0, _utils$6.default)("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      id: {
        validate: (0, _utils$6.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("BlockStatement")
      }
    })
  });
  const patternLikeCommon = {
    typeAnnotation: {
      validate: (0, _utils$6.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator")))
    }
  };
  core.patternLikeCommon = patternLikeCommon;
  (0, _utils$6.default)("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon, {
      name: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("string"), Object.assign(function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

          if (!(0, _isValidIdentifier$3.default)(val, false)) {
            throw new TypeError(`"${val}" is not a valid identifier name`);
          }
        }, {
          type: "string"
        }))
      },
      optional: {
        validate: (0, _utils$6.assertValueType)("boolean"),
        optional: true
      }
    }),

    validate(parent, key, node) {
      if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;
      const match = /\.(\w+)$/.exec(key);
      if (!match) return;
      const [, parentKey] = match;
      const nonComp = {
        computed: false
      };

      if (parentKey === "property") {
        if ((0, _is$1.default)("MemberExpression", parent, nonComp)) return;
        if ((0, _is$1.default)("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if ((0, _is$1.default)("Property", parent, nonComp)) return;
        if ((0, _is$1.default)("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if ((0, _is$1.default)("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if ((0, _is$1.default)("ImportSpecifier", parent, {
          imported: node
        })) return;
      } else if (parentKey === "meta") {
        if ((0, _is$1.default)("MetaProperty", parent, {
          meta: node
        })) return;
      }

      if (((0, _helperValidatorIdentifier$2.isKeyword)(node.name) || (0, _helperValidatorIdentifier$2.isReservedWord)(node.name, false)) && node.name !== "this") {
        throw new TypeError(`"${node.name}" is not a valid identifier`);
      }
    }

  });
  (0, _utils$6.default)("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, _utils$6.assertNodeType)("Statement")
      }
    }
  });
  (0, _utils$6.default)("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      }
    }
  });
  (0, _utils$6.default)("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils$6.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils$6.default)("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils$6.assertValueType)("number")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils$6.default)("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils$6.default)("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils$6.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils$6.default)("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, _utils$6.assertValueType)("string")
      },
      flags: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("string"), Object.assign(function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;
          const invalid = /[^gimsuy]/.exec(val);

          if (invalid) {
            throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
          }
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  });
  (0, _utils$6.default)("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, _utils$6.assertOneOf)(..._constants$5.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$6.default)("MemberExpression", {
    builder: ["object", "property", "computed", ...(!browser$1$1.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      property: {
        validate: function () {
          const normal = (0, _utils$6.assertNodeType)("Identifier", "PrivateName");
          const computed = (0, _utils$6.assertNodeType)("Expression");

          const validator = function (node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        default: false
      }
    }, !browser$1$1.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils$6.assertOneOf)(true, false),
        optional: true
      }
    } : {})
  });
  (0, _utils$6.default)("NewExpression", {
    inherits: "CallExpression"
  });
  (0, _utils$6.default)("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: (0, _utils$6.assertValueType)("string")
      },
      sourceType: {
        validate: (0, _utils$6.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, _utils$6.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: true
      },
      directives: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  (0, _utils$6.default)("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, _utils$6.default)("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      kind: Object.assign({
        validate: (0, _utils$6.assertOneOf)("method", "get", "set")
      }, !browser$1$1.env.BABEL_TYPES_8_BREAKING ? {
        default: "method"
      } : {}),
      computed: {
        default: false
      },
      key: {
        validate: function () {
          const normal = (0, _utils$6.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
          const computed = (0, _utils$6.assertNodeType)("Expression");

          const validator = function (node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator"))),
        optional: true
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  (0, _utils$6.default)("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...(!browser$1$1.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
    fields: {
      computed: {
        default: false
      },
      key: {
        validate: function () {
          const normal = (0, _utils$6.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
          const computed = (0, _utils$6.assertNodeType)("Expression");

          const validator = function (node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
          return validator;
        }()
      },
      value: {
        validate: (0, _utils$6.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("boolean"), Object.assign(function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
        }, {
          type: "boolean"
        }), function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !(0, _is$1.default)("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }),
        default: false
      },
      decorators: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator"))),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function () {
      const pattern = (0, _utils$6.assertNodeType)("Identifier", "Pattern");
      const expression = (0, _utils$6.assertNodeType)("Expression");
      return function (parent, key, node) {
        if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;
        const validator = (0, _is$1.default)("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  (0, _utils$6.default)("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon, {
      argument: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils$6.assertNodeType)("LVal") : (0, _utils$6.assertNodeType)("Identifier", "Pattern", "MemberExpression")
      }
    }),

    validate(parent, key) {
      if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;
      const match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");
      const [, listKey, index] = match;

      if (parent[listKey].length > index + 1) {
        throw new TypeError(`RestElement must be last element of ${listKey}`);
      }
    }

  });
  (0, _utils$6.default)("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils$6.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  (0, _utils$6.default)("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils$6.default)("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$6.default)("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils$6.assertNodeType)("Expression"),
        optional: true
      },
      consequent: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Statement")))
      }
    }
  });
  (0, _utils$6.default)("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("SwitchCase")))
      }
    }
  });
  (0, _utils$6.default)("ThisExpression", {
    aliases: ["Expression"]
  });
  (0, _utils$6.default)("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$6.default)("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertNodeType)("BlockStatement"), Object.assign(function (node) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: true,
        validate: (0, _utils$6.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, _utils$6.assertNodeType)("BlockStatement")
      }
    }
  });
  (0, _utils$6.default)("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: true
      },
      argument: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, _utils$6.assertOneOf)(..._constants$5.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  (0, _utils$6.default)("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: false
      },
      argument: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils$6.assertNodeType)("Expression") : (0, _utils$6.assertNodeType)("Identifier", "MemberExpression")
      },
      operator: {
        validate: (0, _utils$6.assertOneOf)(..._constants$5.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  (0, _utils$6.default)("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils$6.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, _utils$6.assertOneOf)("var", "let", "const")
      },
      declarations: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("VariableDeclarator")))
      }
    },

    validate(parent, key, node) {
      if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;
      if (!(0, _is$1.default)("ForXStatement", parent, {
        left: node
      })) return;

      if (node.declarations.length !== 1) {
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
      }
    }

  });
  (0, _utils$6.default)("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function () {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils$6.assertNodeType)("LVal");
          }

          const normal = (0, _utils$6.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
          const without = (0, _utils$6.assertNodeType)("Identifier");
          return function (node, key, val) {
            const validator = node.init ? normal : without;
            validator(node, key, val);
          };
        }()
      },
      definite: {
        optional: true,
        validate: (0, _utils$6.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$6.default)("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      }
    }
  });
  (0, _utils$6.default)("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      }
    }
  });
  (0, _utils$6.default)("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      left: {
        validate: (0, _utils$6.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
      },
      right: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator"))),
        optional: true
      }
    })
  });
  (0, _utils$6.default)("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      elements: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeOrValueType)("null", "PatternLike")))
      },
      decorators: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator"))),
        optional: true
      }
    })
  });
  (0, _utils$6.default)("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      expression: {
        validate: (0, _utils$6.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("BlockStatement", "Expression")
      }
    })
  });
  (0, _utils$6.default)("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
      }
    }
  });
  (0, _utils$6.default)("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, _utils$6.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils$6.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils$6.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, _utils$6.assertNodeType)("InterfaceExtends"),
        optional: true
      }
    }
  });
  (0, _utils$6.default)("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      },
      typeParameters: {
        validate: (0, _utils$6.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, _utils$6.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      implements: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator"))),
        optional: true
      },
      mixins: {
        validate: (0, _utils$6.assertNodeType)("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: (0, _utils$6.assertValueType)("boolean"),
        optional: true
      },
      abstract: {
        validate: (0, _utils$6.assertValueType)("boolean"),
        optional: true
      }
    },
    validate: function () {
      const identifier = (0, _utils$6.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

        if (!(0, _is$1.default)("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  (0, _utils$6.default)("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, _utils$6.assertNodeType)("StringLiteral")
      },
      exportKind: (0, _utils$6.validateOptional)((0, _utils$6.assertOneOf)("type", "value")),
      assertions: {
        optional: true,
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("ImportAttribute")))
      }
    }
  });
  (0, _utils$6.default)("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, _utils$6.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
      }
    }
  });
  (0, _utils$6.default)("ExportNamedDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: true,
        validate: (0, _utils$6.chain)((0, _utils$6.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        })
      },
      assertions: {
        optional: true,
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)(function () {
          const sourced = (0, _utils$6.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          const sourceless = (0, _utils$6.assertNodeType)("ExportSpecifier");
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return sourced;
          return function (node, key, val) {
            const validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          };
        }()))
      },
      source: {
        validate: (0, _utils$6.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, _utils$6.validateOptional)((0, _utils$6.assertOneOf)("type", "value"))
    }
  });
  (0, _utils$6.default)("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils$6.assertNodeType)("Identifier", "StringLiteral")
      }
    }
  });
  (0, _utils$6.default)("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function () {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils$6.assertNodeType)("VariableDeclaration", "LVal");
          }

          const declaration = (0, _utils$6.assertNodeType)("VariableDeclaration");
          const lval = (0, _utils$6.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
          return function (node, key, val) {
            if ((0, _is$1.default)("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          };
        }()
      },
      right: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils$6.assertNodeType)("Statement")
      },
      await: {
        default: false
      }
    }
  });
  (0, _utils$6.default)("ImportDeclaration", {
    visitor: ["specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration"],
    fields: {
      assertions: {
        optional: true,
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, _utils$6.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils$6.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  (0, _utils$6.default)("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils$6.default)("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils$6.default)("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils$6.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, _utils$6.assertOneOf)("type", "typeof"),
        optional: true
      }
    }
  });
  (0, _utils$6.default)("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;
          let property;

          switch (val.name) {
            case "function":
              property = "sent";
              break;

            case "new":
              property = "target";
              break;

            case "import":
              property = "meta";
              break;
          }

          if (!(0, _is$1.default)("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      }
    }
  });
  const classMethodOrPropertyCommon = {
    abstract: {
      validate: (0, _utils$6.assertValueType)("boolean"),
      optional: true
    },
    accessibility: {
      validate: (0, _utils$6.assertOneOf)("public", "private", "protected"),
      optional: true
    },
    static: {
      default: false
    },
    override: {
      default: false
    },
    computed: {
      default: false
    },
    optional: {
      validate: (0, _utils$6.assertValueType)("boolean"),
      optional: true
    },
    key: {
      validate: (0, _utils$6.chain)(function () {
        const normal = (0, _utils$6.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
        const computed = (0, _utils$6.assertNodeType)("Expression");
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), (0, _utils$6.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
  };
  core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  const classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
    params: {
      validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: (0, _utils$6.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("string"), (0, _utils$6.assertOneOf)("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Decorator"))),
      optional: true
    }
  });
  core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  (0, _utils$6.default)("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
      body: {
        validate: (0, _utils$6.assertNodeType)("BlockStatement")
      }
    })
  });
  (0, _utils$6.default)("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      properties: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  });
  (0, _utils$6.default)("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$6.default)("Super", {
    aliases: ["Expression"]
  });
  (0, _utils$6.default)("TaggedTemplateExpression", {
    visitor: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils$6.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, _utils$6.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  (0, _utils$6.default)("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils$6.assertShape)({
          raw: {
            validate: (0, _utils$6.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils$6.assertValueType)("string"),
            optional: true
          }
        })
      },
      tail: {
        default: false
      }
    }
  });
  (0, _utils$6.default)("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Expression", "TSType")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
          }
        })
      }
    }
  });
  (0, _utils$6.default)("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("boolean"), Object.assign(function (node, key, val) {
          if (!browser$1$1.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })),
        default: false
      },
      argument: {
        optional: true,
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$6.default)("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$6.default)("Import", {
    aliases: ["Expression"]
  });
  (0, _utils$6.default)("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils$6.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils$6.default)("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils$6.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils$6.default)("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      property: {
        validate: function () {
          const normal = (0, _utils$6.assertNodeType)("Identifier");
          const computed = (0, _utils$6.assertNodeType)("Expression");

          const validator = function (node, key, val) {
            const validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier"];
          return validator;
        }()
      },
      computed: {
        default: false
      },
      optional: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils$6.assertValueType)("boolean") : (0, _utils$6.chain)((0, _utils$6.assertValueType)("boolean"), (0, _utils$6.assertOptionalChainStart)())
      }
    }
  });
  (0, _utils$6.default)("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, _utils$6.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, _utils$6.chain)((0, _utils$6.assertValueType)("array"), (0, _utils$6.assertEach)((0, _utils$6.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? (0, _utils$6.assertValueType)("boolean") : (0, _utils$6.chain)((0, _utils$6.assertValueType)("boolean"), (0, _utils$6.assertOptionalChainStart)())
      },
      typeArguments: {
        validate: (0, _utils$6.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils$6.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });

  var _utils$5 = utils;

  const defineInterfaceishType = (name, typeParameterType = "TypeParameterDeclaration") => {
    (0, _utils$5.default)(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils$5.validateType)("Identifier"),
        typeParameters: (0, _utils$5.validateOptionalType)(typeParameterType),
        extends: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)("InterfaceExtends")),
        mixins: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)("InterfaceExtends")),
        implements: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)("ClassImplements")),
        body: (0, _utils$5.validateType)("ObjectTypeAnnotation")
      }
    });
  };

  (0, _utils$5.default)("AnyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      elementType: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("BooleanTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("NullLiteralTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("ClassImplements", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  (0, _utils$5.default)("DeclareFunction", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      predicate: (0, _utils$5.validateOptionalType)("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  (0, _utils$5.default)("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils$5.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils$5.validateType)("BlockStatement"),
      kind: (0, _utils$5.validateOptional)((0, _utils$5.assertOneOf)("CommonJS", "ES"))
    }
  });
  (0, _utils$5.default)("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, _utils$5.validateType)("TypeAnnotation")
    }
  });
  (0, _utils$5.default)("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils$5.validateOptionalType)("FlowType")
    }
  });
  (0, _utils$5.default)("DeclareVariable", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier")
    }
  });
  (0, _utils$5.default)("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, _utils$5.validateOptionalType)("Flow"),
      specifiers: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, _utils$5.validateOptionalType)("StringLiteral"),
      default: (0, _utils$5.validateOptional)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, _utils$5.validateType)("StringLiteral"),
      exportKind: (0, _utils$5.validateOptional)((0, _utils$5.assertOneOf)("type", "value"))
    }
  });
  (0, _utils$5.default)("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["Flow", "FlowPredicate"],
    fields: {
      value: (0, _utils$5.validateType)("Flow")
    }
  });
  (0, _utils$5.default)("ExistsTypeAnnotation", {
    aliases: ["Flow", "FlowType"]
  });
  (0, _utils$5.default)("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils$5.validate)((0, _utils$5.arrayOfType)("FunctionTypeParam")),
      rest: (0, _utils$5.validateOptionalType)("FunctionTypeParam"),
      this: (0, _utils$5.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    aliases: ["Flow"],
    fields: {
      name: (0, _utils$5.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils$5.validateType)("FlowType"),
      optional: (0, _utils$5.validateOptional)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow", "FlowType"],
    fields: {
      id: (0, _utils$5.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  (0, _utils$5.default)("InferredPredicate", {
    aliases: ["Flow", "FlowPredicate"]
  });
  (0, _utils$5.default)("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: (0, _utils$5.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  (0, _utils$5.default)("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["Flow", "FlowType"],
    fields: {
      extends: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)("InterfaceExtends")),
      body: (0, _utils$5.validateType)("ObjectTypeAnnotation")
    }
  });
  (0, _utils$5.default)("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: (0, _utils$5.validate)((0, _utils$5.arrayOfType)("FlowType"))
    }
  });
  (0, _utils$5.default)("MixedTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("EmptyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeAnnotation: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: (0, _utils$5.validate)((0, _utils$5.assertValueType)("number"))
    }
  });
  (0, _utils$5.default)("NumberTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["Flow", "FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, _utils$5.validate)((0, _utils$5.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)("ObjectTypeIndexer")),
      callProperties: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)("ObjectTypeCallProperty")),
      internalSlots: (0, _utils$5.validateOptional)((0, _utils$5.arrayOfType)("ObjectTypeInternalSlot")),
      exact: {
        validate: (0, _utils$5.assertValueType)("boolean"),
        default: false
      },
      inexact: (0, _utils$5.validateOptional)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      value: (0, _utils$5.validateType)("FlowType"),
      optional: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      static: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      method: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      value: (0, _utils$5.validateType)("FlowType"),
      static: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: (0, _utils$5.validateOptionalType)("Identifier"),
      key: (0, _utils$5.validateType)("FlowType"),
      value: (0, _utils$5.validateType)("FlowType"),
      static: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      variance: (0, _utils$5.validateOptionalType)("Variance")
    }
  });
  (0, _utils$5.default)("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      key: (0, _utils$5.validateType)(["Identifier", "StringLiteral"]),
      value: (0, _utils$5.validateType)("FlowType"),
      kind: (0, _utils$5.validate)((0, _utils$5.assertOneOf)("init", "get", "set")),
      static: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      proto: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      optional: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      variance: (0, _utils$5.validateOptionalType)("Variance"),
      method: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      argument: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils$5.validateOptionalType)("FlowType"),
      impltype: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    aliases: ["Flow"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      qualification: (0, _utils$5.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  (0, _utils$5.default)("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: (0, _utils$5.validate)((0, _utils$5.assertValueType)("string"))
    }
  });
  (0, _utils$5.default)("StringTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("SymbolTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("ThisTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: (0, _utils$5.validate)((0, _utils$5.arrayOfType)("FlowType"))
    }
  });
  (0, _utils$5.default)("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["Flow", "FlowType"],
    fields: {
      argument: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      typeParameters: (0, _utils$5.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("TypeAnnotation", {
    aliases: ["Flow"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["Flow", "ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils$5.validateType)("Expression"),
      typeAnnotation: (0, _utils$5.validateType)("TypeAnnotation")
    }
  });
  (0, _utils$5.default)("TypeParameter", {
    aliases: ["Flow"],
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils$5.validate)((0, _utils$5.assertValueType)("string")),
      bound: (0, _utils$5.validateOptionalType)("TypeAnnotation"),
      default: (0, _utils$5.validateOptionalType)("FlowType"),
      variance: (0, _utils$5.validateOptionalType)("Variance")
    }
  });
  (0, _utils$5.default)("TypeParameterDeclaration", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: (0, _utils$5.validate)((0, _utils$5.arrayOfType)("TypeParameter"))
    }
  });
  (0, _utils$5.default)("TypeParameterInstantiation", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: (0, _utils$5.validate)((0, _utils$5.arrayOfType)("FlowType"))
    }
  });
  (0, _utils$5.default)("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: (0, _utils$5.validate)((0, _utils$5.arrayOfType)("FlowType"))
    }
  });
  (0, _utils$5.default)("Variance", {
    aliases: ["Flow"],
    builder: ["kind"],
    fields: {
      kind: (0, _utils$5.validate)((0, _utils$5.assertOneOf)("minus", "plus"))
    }
  });
  (0, _utils$5.default)("VoidTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  (0, _utils$5.default)("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      body: (0, _utils$5.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  (0, _utils$5.default)("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      members: (0, _utils$5.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      members: (0, _utils$5.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean")),
      members: (0, _utils$5.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils$5.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });
  (0, _utils$5.default)("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      init: (0, _utils$5.validateType)("BooleanLiteral")
    }
  });
  (0, _utils$5.default)("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      init: (0, _utils$5.validateType)("NumericLiteral")
    }
  });
  (0, _utils$5.default)("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier"),
      init: (0, _utils$5.validateType)("StringLiteral")
    }
  });
  (0, _utils$5.default)("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils$5.validateType)("Identifier")
    }
  });
  (0, _utils$5.default)("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      objectType: (0, _utils$5.validateType)("FlowType"),
      indexType: (0, _utils$5.validateType)("FlowType")
    }
  });
  (0, _utils$5.default)("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      objectType: (0, _utils$5.validateType)("FlowType"),
      indexType: (0, _utils$5.validateType)("FlowType"),
      optional: (0, _utils$5.validate)((0, _utils$5.assertValueType)("boolean"))
    }
  });

  var _utils$4 = utils;

  (0, _utils$4.default)("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: (0, _utils$4.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, _utils$4.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  (0, _utils$4.default)("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: (0, _utils$4.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  (0, _utils$4.default)("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingElement: {
        validate: (0, _utils$4.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, _utils$4.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, _utils$4.chain)((0, _utils$4.assertValueType)("array"), (0, _utils$4.assertEach)((0, _utils$4.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      },
      selfClosing: {
        validate: (0, _utils$4.assertValueType)("boolean"),
        optional: true
      }
    }
  });
  (0, _utils$4.default)("JSXEmptyExpression", {
    aliases: ["JSX"]
  });
  (0, _utils$4.default)("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: (0, _utils$4.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  (0, _utils$4.default)("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: (0, _utils$4.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$4.default)("JSXIdentifier", {
    builder: ["name"],
    aliases: ["JSX"],
    fields: {
      name: {
        validate: (0, _utils$4.assertValueType)("string")
      }
    }
  });
  (0, _utils$4.default)("JSXMemberExpression", {
    visitor: ["object", "property"],
    aliases: ["JSX"],
    fields: {
      object: {
        validate: (0, _utils$4.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils$4.assertNodeType)("JSXIdentifier")
      }
    }
  });
  (0, _utils$4.default)("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    aliases: ["JSX"],
    fields: {
      namespace: {
        validate: (0, _utils$4.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils$4.assertNodeType)("JSXIdentifier")
      }
    }
  });
  (0, _utils$4.default)("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: (0, _utils$4.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: false
      },
      attributes: {
        validate: (0, _utils$4.chain)((0, _utils$4.assertValueType)("array"), (0, _utils$4.assertEach)((0, _utils$4.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, _utils$4.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  (0, _utils$4.default)("JSXSpreadAttribute", {
    visitor: ["argument"],
    aliases: ["JSX"],
    fields: {
      argument: {
        validate: (0, _utils$4.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$4.default)("JSXText", {
    aliases: ["JSX", "Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils$4.assertValueType)("string")
      }
    }
  });
  (0, _utils$4.default)("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils$4.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils$4.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, _utils$4.chain)((0, _utils$4.assertValueType)("array"), (0, _utils$4.assertEach)((0, _utils$4.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  (0, _utils$4.default)("JSXOpeningFragment", {
    aliases: ["JSX", "Immutable"]
  });
  (0, _utils$4.default)("JSXClosingFragment", {
    aliases: ["JSX", "Immutable"]
  });

  var placeholders = {};

  Object.defineProperty(placeholders, "__esModule", {
    value: true
  });
  placeholders.PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS = void 0;

  var _utils$3 = utils;

  const PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  placeholders.PLACEHOLDERS = PLACEHOLDERS;
  const PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  placeholders.PLACEHOLDERS_ALIAS = PLACEHOLDERS_ALIAS;

  for (const type of PLACEHOLDERS) {
    const alias = _utils$3.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }

  const PLACEHOLDERS_FLIPPED_ALIAS = {};
  placeholders.PLACEHOLDERS_FLIPPED_ALIAS = PLACEHOLDERS_FLIPPED_ALIAS;
  Object.keys(PLACEHOLDERS_ALIAS).forEach(type => {
    PLACEHOLDERS_ALIAS[type].forEach(alias => {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }

      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });

  var _utils$2 = utils;

  var _placeholders = placeholders;

  {
    (0, _utils$2.default)("Noop", {
      visitor: []
    });
  }
  (0, _utils$2.default)("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, _utils$2.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, _utils$2.assertOneOf)(..._placeholders.PLACEHOLDERS)
      }
    }
  });
  (0, _utils$2.default)("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils$2.assertValueType)("string")
      }
    }
  });

  var _utils$1 = utils;

  var _core$1 = core;

  (0, _utils$1.default)("ArgumentPlaceholder", {});
  (0, _utils$1.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !browser$1$1.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(() => {}, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {}, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: (0, _utils$1.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils$1.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$1.default)("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, _core$1.classMethodOrPropertyCommon, {
      value: {
        validate: (0, _utils$1.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils$1.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils$1.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils$1.chain)((0, _utils$1.assertValueType)("array"), (0, _utils$1.assertEach)((0, _utils$1.assertNodeType)("Decorator"))),
        optional: true
      },
      readonly: {
        validate: (0, _utils$1.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils$1.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  (0, _utils$1.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils$1.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$1.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _utils$1.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$1.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils$1.default)("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, _utils$1.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils$1.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils$1.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils$1.chain)((0, _utils$1.assertValueType)("array"), (0, _utils$1.assertEach)((0, _utils$1.assertNodeType)("Decorator"))),
        optional: true
      }
    }
  });
  (0, _utils$1.default)("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, _core$1.classMethodOrDeclareMethodCommon, _core$1.functionTypeAnnotationCommon, {
      key: {
        validate: (0, _utils$1.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils$1.assertNodeType)("BlockStatement")
      }
    })
  });
  (0, _utils$1.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils$1.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, _utils$1.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, _utils$1.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils$1.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils$1.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _utils$1.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _utils$1.assertValueType)("boolean"),
        default: false
      }
    }
  });
  (0, _utils$1.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils$1.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils$1.default)("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, _utils$1.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils$1.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, _utils$1.chain)((0, _utils$1.assertValueType)("array"), (0, _utils$1.assertEach)((0, _utils$1.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  });
  (0, _utils$1.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils$1.chain)((0, _utils$1.assertValueType)("array"), (0, _utils$1.assertEach)((0, _utils$1.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, _utils$1.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils$1.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, _utils$1.default)("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils$1.chain)((0, _utils$1.assertValueType)("array"), (0, _utils$1.assertEach)((0, _utils$1.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  (0, _utils$1.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils$1.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });

  var _utils = utils;

  var _core = core;

  const bool = (0, _utils.assertValueType)("boolean");
  const tSFunctionTypeAnnotationCommon = {
    returnType: {
      validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  (0, _utils.default)("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      }
    }
  });
  (0, _utils.default)("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, _core.functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
  });
  (0, _utils.default)("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, _core.classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
  });
  (0, _utils.default)("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  const signatureDeclarationCommon = {
    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, _utils.validateArrayOfType)(["Identifier", "RestElement"]),
    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
  };
  const callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon
  };
  (0, _utils.default)("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  (0, _utils.default)("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  const namedTypeElementCommon = {
    key: (0, _utils.validateType)("Expression"),
    computed: (0, _utils.validate)(bool),
    optional: (0, _utils.validateOptional)(bool)
  };
  (0, _utils.default)("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, namedTypeElementCommon, {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    })
  });
  (0, _utils.default)("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
      kind: {
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }
    })
  });
  (0, _utils.default)("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      static: (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

  for (const type of tsKeywordTypes) {
    (0, _utils.default)(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }

  (0, _utils.default)("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  (0, _utils.default)("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon
  }));
  (0, _utils.default)("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon, {
      abstract: (0, _utils.validateOptional)(bool)
    })
  }));
  (0, _utils.default)("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  (0, _utils.default)("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  });
  (0, _utils.default)("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName"],
    fields: {
      exprName: (0, _utils.validateType)(["TSEntityName", "TSImportType"])
    }
  });
  (0, _utils.default)("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  (0, _utils.default)("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  });
  (0, _utils.default)("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: {
        validate: bool,
        default: false
      },
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  const unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  (0, _utils.default)("TSUnionType", unionOrIntersection);
  (0, _utils.default)("TSIntersectionType", unionOrIntersection);
  (0, _utils.default)("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  });
  (0, _utils.default)("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      typeParameter: (0, _utils.validateType)("TSTypeParameter"),
      optional: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType")
    }
  });
  (0, _utils.default)("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: (0, _utils.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"])
    }
  });
  (0, _utils.default)("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, _utils.validateType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  (0, _utils.default)("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  });
  (0, _utils.default)("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  (0, _utils.default)("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSAsExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  (0, _utils.default)("TSTypeAssertion", {
    aliases: ["Expression"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  });
  (0, _utils.default)("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      const: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      members: (0, _utils.validateArrayOfType)("TSEnumMember"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  (0, _utils.default)("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  (0, _utils.default)("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      global: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)(["Identifier", "StringLiteral"]),
      body: (0, _utils.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  (0, _utils.default)("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent"],
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  (0, _utils.default)("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  (0, _utils.default)("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, _utils.validate)(bool),
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)(["TSEntityName", "TSExternalModuleReference"])
    }
  });
  (0, _utils.default)("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  });
  (0, _utils.default)("TSNonNullExpression", {
    aliases: ["Expression"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  (0, _utils.default)("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  (0, _utils.default)("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  (0, _utils.default)("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  });
  (0, _utils.default)("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")))
      }
    }
  });
  (0, _utils.default)("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSTypeParameter")))
      }
    }
  });
  (0, _utils.default)("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      },
      default: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      }
    }
  });

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "VISITOR_KEYS", {
    enumerable: true,
    get: function () {
      return _utils.VISITOR_KEYS;
    }
  });
  Object.defineProperty(exports, "ALIAS_KEYS", {
    enumerable: true,
    get: function () {
      return _utils.ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
    enumerable: true,
    get: function () {
      return _utils.FLIPPED_ALIAS_KEYS;
    }
  });
  Object.defineProperty(exports, "NODE_FIELDS", {
    enumerable: true,
    get: function () {
      return _utils.NODE_FIELDS;
    }
  });
  Object.defineProperty(exports, "BUILDER_KEYS", {
    enumerable: true,
    get: function () {
      return _utils.BUILDER_KEYS;
    }
  });
  Object.defineProperty(exports, "DEPRECATED_KEYS", {
    enumerable: true,
    get: function () {
      return _utils.DEPRECATED_KEYS;
    }
  });
  Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
    enumerable: true,
    get: function () {
      return _utils.NODE_PARENT_VALIDATIONS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS", {
    enumerable: true,
    get: function () {
      return _placeholders.PLACEHOLDERS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
    enumerable: true,
    get: function () {
      return _placeholders.PLACEHOLDERS_ALIAS;
    }
  });
  Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: true,
    get: function () {
      return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
    }
  });
  exports.TYPES = void 0;














  var _utils = utils;

  var _placeholders = placeholders;


  const TYPES = Object.keys(_utils.VISITOR_KEYS).concat(Object.keys(_utils.FLIPPED_ALIAS_KEYS)).concat(Object.keys(_utils.DEPRECATED_KEYS));
  exports.TYPES = TYPES;
  }(definitions));

  Object.defineProperty(builder$2, "__esModule", {
    value: true
  });
  builder$2.default = builder$1;

  var _definitions$6 = definitions;

  var _validate = validate$3;

  function builder$1(type, ...args) {
    const keys = _definitions$6.BUILDER_KEYS[type];
    const countArgs = args.length;

    if (countArgs > keys.length) {
      throw new Error(`${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${keys.length}`);
    }

    const node = {
      type
    };
    let i = 0;
    keys.forEach(key => {
      const field = _definitions$6.NODE_FIELDS[type][key];
      let arg;
      if (i < countArgs) arg = args[i];

      if (arg === undefined) {
        arg = Array.isArray(field.default) ? [] : field.default;
      }

      node[key] = arg;
      i++;
    });

    for (const key of Object.keys(node)) {
      (0, _validate.default)(node, key, node[key]);
    }

    return node;
  }

  Object.defineProperty(generated$3, "__esModule", {
    value: true
  });
  generated$3.arrayExpression = arrayExpression;
  generated$3.assignmentExpression = assignmentExpression;
  generated$3.binaryExpression = binaryExpression;
  generated$3.interpreterDirective = interpreterDirective;
  generated$3.directive = directive;
  generated$3.directiveLiteral = directiveLiteral;
  generated$3.blockStatement = blockStatement;
  generated$3.breakStatement = breakStatement;
  generated$3.callExpression = callExpression;
  generated$3.catchClause = catchClause;
  generated$3.conditionalExpression = conditionalExpression;
  generated$3.continueStatement = continueStatement;
  generated$3.debuggerStatement = debuggerStatement;
  generated$3.doWhileStatement = doWhileStatement;
  generated$3.emptyStatement = emptyStatement;
  generated$3.expressionStatement = expressionStatement;
  generated$3.file = file;
  generated$3.forInStatement = forInStatement;
  generated$3.forStatement = forStatement;
  generated$3.functionDeclaration = functionDeclaration;
  generated$3.functionExpression = functionExpression;
  generated$3.identifier = identifier;
  generated$3.ifStatement = ifStatement;
  generated$3.labeledStatement = labeledStatement;
  generated$3.stringLiteral = stringLiteral;
  generated$3.numericLiteral = numericLiteral;
  generated$3.nullLiteral = nullLiteral;
  generated$3.booleanLiteral = booleanLiteral;
  generated$3.regExpLiteral = regExpLiteral;
  generated$3.logicalExpression = logicalExpression;
  generated$3.memberExpression = memberExpression;
  generated$3.newExpression = newExpression;
  generated$3.program = program$2;
  generated$3.objectExpression = objectExpression;
  generated$3.objectMethod = objectMethod;
  generated$3.objectProperty = objectProperty;
  generated$3.restElement = restElement;
  generated$3.returnStatement = returnStatement;
  generated$3.sequenceExpression = sequenceExpression;
  generated$3.parenthesizedExpression = parenthesizedExpression;
  generated$3.switchCase = switchCase;
  generated$3.switchStatement = switchStatement;
  generated$3.thisExpression = thisExpression;
  generated$3.throwStatement = throwStatement;
  generated$3.tryStatement = tryStatement;
  generated$3.unaryExpression = unaryExpression;
  generated$3.updateExpression = updateExpression;
  generated$3.variableDeclaration = variableDeclaration;
  generated$3.variableDeclarator = variableDeclarator;
  generated$3.whileStatement = whileStatement;
  generated$3.withStatement = withStatement;
  generated$3.assignmentPattern = assignmentPattern;
  generated$3.arrayPattern = arrayPattern;
  generated$3.arrowFunctionExpression = arrowFunctionExpression;
  generated$3.classBody = classBody;
  generated$3.classExpression = classExpression;
  generated$3.classDeclaration = classDeclaration;
  generated$3.exportAllDeclaration = exportAllDeclaration;
  generated$3.exportDefaultDeclaration = exportDefaultDeclaration;
  generated$3.exportNamedDeclaration = exportNamedDeclaration;
  generated$3.exportSpecifier = exportSpecifier;
  generated$3.forOfStatement = forOfStatement;
  generated$3.importDeclaration = importDeclaration;
  generated$3.importDefaultSpecifier = importDefaultSpecifier;
  generated$3.importNamespaceSpecifier = importNamespaceSpecifier;
  generated$3.importSpecifier = importSpecifier;
  generated$3.metaProperty = metaProperty;
  generated$3.classMethod = classMethod;
  generated$3.objectPattern = objectPattern;
  generated$3.spreadElement = spreadElement;
  generated$3.super = _super;
  generated$3.taggedTemplateExpression = taggedTemplateExpression;
  generated$3.templateElement = templateElement;
  generated$3.templateLiteral = templateLiteral;
  generated$3.yieldExpression = yieldExpression;
  generated$3.awaitExpression = awaitExpression;
  generated$3.import = _import;
  generated$3.bigIntLiteral = bigIntLiteral;
  generated$3.exportNamespaceSpecifier = exportNamespaceSpecifier;
  generated$3.optionalMemberExpression = optionalMemberExpression;
  generated$3.optionalCallExpression = optionalCallExpression;
  generated$3.anyTypeAnnotation = anyTypeAnnotation;
  generated$3.arrayTypeAnnotation = arrayTypeAnnotation;
  generated$3.booleanTypeAnnotation = booleanTypeAnnotation;
  generated$3.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  generated$3.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  generated$3.classImplements = classImplements;
  generated$3.declareClass = declareClass;
  generated$3.declareFunction = declareFunction;
  generated$3.declareInterface = declareInterface;
  generated$3.declareModule = declareModule;
  generated$3.declareModuleExports = declareModuleExports;
  generated$3.declareTypeAlias = declareTypeAlias;
  generated$3.declareOpaqueType = declareOpaqueType;
  generated$3.declareVariable = declareVariable;
  generated$3.declareExportDeclaration = declareExportDeclaration;
  generated$3.declareExportAllDeclaration = declareExportAllDeclaration;
  generated$3.declaredPredicate = declaredPredicate;
  generated$3.existsTypeAnnotation = existsTypeAnnotation;
  generated$3.functionTypeAnnotation = functionTypeAnnotation;
  generated$3.functionTypeParam = functionTypeParam;
  generated$3.genericTypeAnnotation = genericTypeAnnotation;
  generated$3.inferredPredicate = inferredPredicate;
  generated$3.interfaceExtends = interfaceExtends;
  generated$3.interfaceDeclaration = interfaceDeclaration;
  generated$3.interfaceTypeAnnotation = interfaceTypeAnnotation;
  generated$3.intersectionTypeAnnotation = intersectionTypeAnnotation;
  generated$3.mixedTypeAnnotation = mixedTypeAnnotation;
  generated$3.emptyTypeAnnotation = emptyTypeAnnotation;
  generated$3.nullableTypeAnnotation = nullableTypeAnnotation;
  generated$3.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  generated$3.numberTypeAnnotation = numberTypeAnnotation;
  generated$3.objectTypeAnnotation = objectTypeAnnotation;
  generated$3.objectTypeInternalSlot = objectTypeInternalSlot;
  generated$3.objectTypeCallProperty = objectTypeCallProperty;
  generated$3.objectTypeIndexer = objectTypeIndexer;
  generated$3.objectTypeProperty = objectTypeProperty;
  generated$3.objectTypeSpreadProperty = objectTypeSpreadProperty;
  generated$3.opaqueType = opaqueType;
  generated$3.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  generated$3.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  generated$3.stringTypeAnnotation = stringTypeAnnotation;
  generated$3.symbolTypeAnnotation = symbolTypeAnnotation;
  generated$3.thisTypeAnnotation = thisTypeAnnotation;
  generated$3.tupleTypeAnnotation = tupleTypeAnnotation;
  generated$3.typeofTypeAnnotation = typeofTypeAnnotation;
  generated$3.typeAlias = typeAlias;
  generated$3.typeAnnotation = typeAnnotation;
  generated$3.typeCastExpression = typeCastExpression;
  generated$3.typeParameter = typeParameter;
  generated$3.typeParameterDeclaration = typeParameterDeclaration;
  generated$3.typeParameterInstantiation = typeParameterInstantiation;
  generated$3.unionTypeAnnotation = unionTypeAnnotation;
  generated$3.variance = variance;
  generated$3.voidTypeAnnotation = voidTypeAnnotation;
  generated$3.enumDeclaration = enumDeclaration;
  generated$3.enumBooleanBody = enumBooleanBody;
  generated$3.enumNumberBody = enumNumberBody;
  generated$3.enumStringBody = enumStringBody;
  generated$3.enumSymbolBody = enumSymbolBody;
  generated$3.enumBooleanMember = enumBooleanMember;
  generated$3.enumNumberMember = enumNumberMember;
  generated$3.enumStringMember = enumStringMember;
  generated$3.enumDefaultedMember = enumDefaultedMember;
  generated$3.indexedAccessType = indexedAccessType;
  generated$3.optionalIndexedAccessType = optionalIndexedAccessType;
  generated$3.jSXAttribute = generated$3.jsxAttribute = jsxAttribute;
  generated$3.jSXClosingElement = generated$3.jsxClosingElement = jsxClosingElement;
  generated$3.jSXElement = generated$3.jsxElement = jsxElement;
  generated$3.jSXEmptyExpression = generated$3.jsxEmptyExpression = jsxEmptyExpression;
  generated$3.jSXExpressionContainer = generated$3.jsxExpressionContainer = jsxExpressionContainer;
  generated$3.jSXSpreadChild = generated$3.jsxSpreadChild = jsxSpreadChild;
  generated$3.jSXIdentifier = generated$3.jsxIdentifier = jsxIdentifier;
  generated$3.jSXMemberExpression = generated$3.jsxMemberExpression = jsxMemberExpression;
  generated$3.jSXNamespacedName = generated$3.jsxNamespacedName = jsxNamespacedName;
  generated$3.jSXOpeningElement = generated$3.jsxOpeningElement = jsxOpeningElement;
  generated$3.jSXSpreadAttribute = generated$3.jsxSpreadAttribute = jsxSpreadAttribute;
  generated$3.jSXText = generated$3.jsxText = jsxText;
  generated$3.jSXFragment = generated$3.jsxFragment = jsxFragment;
  generated$3.jSXOpeningFragment = generated$3.jsxOpeningFragment = jsxOpeningFragment;
  generated$3.jSXClosingFragment = generated$3.jsxClosingFragment = jsxClosingFragment;
  generated$3.noop = noop;
  generated$3.placeholder = placeholder;
  generated$3.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  generated$3.argumentPlaceholder = argumentPlaceholder;
  generated$3.bindExpression = bindExpression;
  generated$3.classProperty = classProperty;
  generated$3.pipelineTopicExpression = pipelineTopicExpression;
  generated$3.pipelineBareFunction = pipelineBareFunction;
  generated$3.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  generated$3.classPrivateProperty = classPrivateProperty;
  generated$3.classPrivateMethod = classPrivateMethod;
  generated$3.importAttribute = importAttribute;
  generated$3.decorator = decorator;
  generated$3.doExpression = doExpression;
  generated$3.exportDefaultSpecifier = exportDefaultSpecifier;
  generated$3.privateName = privateName;
  generated$3.recordExpression = recordExpression;
  generated$3.tupleExpression = tupleExpression;
  generated$3.decimalLiteral = decimalLiteral;
  generated$3.staticBlock = staticBlock;
  generated$3.moduleExpression = moduleExpression;
  generated$3.tSParameterProperty = generated$3.tsParameterProperty = tsParameterProperty;
  generated$3.tSDeclareFunction = generated$3.tsDeclareFunction = tsDeclareFunction;
  generated$3.tSDeclareMethod = generated$3.tsDeclareMethod = tsDeclareMethod;
  generated$3.tSQualifiedName = generated$3.tsQualifiedName = tsQualifiedName;
  generated$3.tSCallSignatureDeclaration = generated$3.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  generated$3.tSConstructSignatureDeclaration = generated$3.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
  generated$3.tSPropertySignature = generated$3.tsPropertySignature = tsPropertySignature;
  generated$3.tSMethodSignature = generated$3.tsMethodSignature = tsMethodSignature;
  generated$3.tSIndexSignature = generated$3.tsIndexSignature = tsIndexSignature;
  generated$3.tSAnyKeyword = generated$3.tsAnyKeyword = tsAnyKeyword;
  generated$3.tSBooleanKeyword = generated$3.tsBooleanKeyword = tsBooleanKeyword;
  generated$3.tSBigIntKeyword = generated$3.tsBigIntKeyword = tsBigIntKeyword;
  generated$3.tSIntrinsicKeyword = generated$3.tsIntrinsicKeyword = tsIntrinsicKeyword;
  generated$3.tSNeverKeyword = generated$3.tsNeverKeyword = tsNeverKeyword;
  generated$3.tSNullKeyword = generated$3.tsNullKeyword = tsNullKeyword;
  generated$3.tSNumberKeyword = generated$3.tsNumberKeyword = tsNumberKeyword;
  generated$3.tSObjectKeyword = generated$3.tsObjectKeyword = tsObjectKeyword;
  generated$3.tSStringKeyword = generated$3.tsStringKeyword = tsStringKeyword;
  generated$3.tSSymbolKeyword = generated$3.tsSymbolKeyword = tsSymbolKeyword;
  generated$3.tSUndefinedKeyword = generated$3.tsUndefinedKeyword = tsUndefinedKeyword;
  generated$3.tSUnknownKeyword = generated$3.tsUnknownKeyword = tsUnknownKeyword;
  generated$3.tSVoidKeyword = generated$3.tsVoidKeyword = tsVoidKeyword;
  generated$3.tSThisType = generated$3.tsThisType = tsThisType;
  generated$3.tSFunctionType = generated$3.tsFunctionType = tsFunctionType;
  generated$3.tSConstructorType = generated$3.tsConstructorType = tsConstructorType;
  generated$3.tSTypeReference = generated$3.tsTypeReference = tsTypeReference;
  generated$3.tSTypePredicate = generated$3.tsTypePredicate = tsTypePredicate;
  generated$3.tSTypeQuery = generated$3.tsTypeQuery = tsTypeQuery;
  generated$3.tSTypeLiteral = generated$3.tsTypeLiteral = tsTypeLiteral;
  generated$3.tSArrayType = generated$3.tsArrayType = tsArrayType;
  generated$3.tSTupleType = generated$3.tsTupleType = tsTupleType;
  generated$3.tSOptionalType = generated$3.tsOptionalType = tsOptionalType;
  generated$3.tSRestType = generated$3.tsRestType = tsRestType;
  generated$3.tSNamedTupleMember = generated$3.tsNamedTupleMember = tsNamedTupleMember;
  generated$3.tSUnionType = generated$3.tsUnionType = tsUnionType;
  generated$3.tSIntersectionType = generated$3.tsIntersectionType = tsIntersectionType;
  generated$3.tSConditionalType = generated$3.tsConditionalType = tsConditionalType;
  generated$3.tSInferType = generated$3.tsInferType = tsInferType;
  generated$3.tSParenthesizedType = generated$3.tsParenthesizedType = tsParenthesizedType;
  generated$3.tSTypeOperator = generated$3.tsTypeOperator = tsTypeOperator;
  generated$3.tSIndexedAccessType = generated$3.tsIndexedAccessType = tsIndexedAccessType;
  generated$3.tSMappedType = generated$3.tsMappedType = tsMappedType;
  generated$3.tSLiteralType = generated$3.tsLiteralType = tsLiteralType;
  generated$3.tSExpressionWithTypeArguments = generated$3.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  generated$3.tSInterfaceDeclaration = generated$3.tsInterfaceDeclaration = tsInterfaceDeclaration;
  generated$3.tSInterfaceBody = generated$3.tsInterfaceBody = tsInterfaceBody;
  generated$3.tSTypeAliasDeclaration = generated$3.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
  generated$3.tSAsExpression = generated$3.tsAsExpression = tsAsExpression;
  generated$3.tSTypeAssertion = generated$3.tsTypeAssertion = tsTypeAssertion;
  generated$3.tSEnumDeclaration = generated$3.tsEnumDeclaration = tsEnumDeclaration;
  generated$3.tSEnumMember = generated$3.tsEnumMember = tsEnumMember;
  generated$3.tSModuleDeclaration = generated$3.tsModuleDeclaration = tsModuleDeclaration;
  generated$3.tSModuleBlock = generated$3.tsModuleBlock = tsModuleBlock;
  generated$3.tSImportType = generated$3.tsImportType = tsImportType;
  generated$3.tSImportEqualsDeclaration = generated$3.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  generated$3.tSExternalModuleReference = generated$3.tsExternalModuleReference = tsExternalModuleReference;
  generated$3.tSNonNullExpression = generated$3.tsNonNullExpression = tsNonNullExpression;
  generated$3.tSExportAssignment = generated$3.tsExportAssignment = tsExportAssignment;
  generated$3.tSNamespaceExportDeclaration = generated$3.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  generated$3.tSTypeAnnotation = generated$3.tsTypeAnnotation = tsTypeAnnotation;
  generated$3.tSTypeParameterInstantiation = generated$3.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  generated$3.tSTypeParameterDeclaration = generated$3.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  generated$3.tSTypeParameter = generated$3.tsTypeParameter = tsTypeParameter;
  generated$3.numberLiteral = NumberLiteral;
  generated$3.regexLiteral = RegexLiteral;
  generated$3.restProperty = RestProperty$1;
  generated$3.spreadProperty = SpreadProperty$1;

  var _builder$1 = builder$2;

  function arrayExpression(elements) {
    return (0, _builder$1.default)("ArrayExpression", ...arguments);
  }

  function assignmentExpression(operator, left, right) {
    return (0, _builder$1.default)("AssignmentExpression", ...arguments);
  }

  function binaryExpression(operator, left, right) {
    return (0, _builder$1.default)("BinaryExpression", ...arguments);
  }

  function interpreterDirective(value) {
    return (0, _builder$1.default)("InterpreterDirective", ...arguments);
  }

  function directive(value) {
    return (0, _builder$1.default)("Directive", ...arguments);
  }

  function directiveLiteral(value) {
    return (0, _builder$1.default)("DirectiveLiteral", ...arguments);
  }

  function blockStatement(body, directives) {
    return (0, _builder$1.default)("BlockStatement", ...arguments);
  }

  function breakStatement(label) {
    return (0, _builder$1.default)("BreakStatement", ...arguments);
  }

  function callExpression(callee, _arguments) {
    return (0, _builder$1.default)("CallExpression", ...arguments);
  }

  function catchClause(param, body) {
    return (0, _builder$1.default)("CatchClause", ...arguments);
  }

  function conditionalExpression(test, consequent, alternate) {
    return (0, _builder$1.default)("ConditionalExpression", ...arguments);
  }

  function continueStatement(label) {
    return (0, _builder$1.default)("ContinueStatement", ...arguments);
  }

  function debuggerStatement() {
    return (0, _builder$1.default)("DebuggerStatement", ...arguments);
  }

  function doWhileStatement(test, body) {
    return (0, _builder$1.default)("DoWhileStatement", ...arguments);
  }

  function emptyStatement() {
    return (0, _builder$1.default)("EmptyStatement", ...arguments);
  }

  function expressionStatement(expression) {
    return (0, _builder$1.default)("ExpressionStatement", ...arguments);
  }

  function file(program, comments, tokens) {
    return (0, _builder$1.default)("File", ...arguments);
  }

  function forInStatement(left, right, body) {
    return (0, _builder$1.default)("ForInStatement", ...arguments);
  }

  function forStatement(init, test, update, body) {
    return (0, _builder$1.default)("ForStatement", ...arguments);
  }

  function functionDeclaration(id, params, body, generator, async) {
    return (0, _builder$1.default)("FunctionDeclaration", ...arguments);
  }

  function functionExpression(id, params, body, generator, async) {
    return (0, _builder$1.default)("FunctionExpression", ...arguments);
  }

  function identifier(name) {
    return (0, _builder$1.default)("Identifier", ...arguments);
  }

  function ifStatement(test, consequent, alternate) {
    return (0, _builder$1.default)("IfStatement", ...arguments);
  }

  function labeledStatement(label, body) {
    return (0, _builder$1.default)("LabeledStatement", ...arguments);
  }

  function stringLiteral(value) {
    return (0, _builder$1.default)("StringLiteral", ...arguments);
  }

  function numericLiteral(value) {
    return (0, _builder$1.default)("NumericLiteral", ...arguments);
  }

  function nullLiteral() {
    return (0, _builder$1.default)("NullLiteral", ...arguments);
  }

  function booleanLiteral(value) {
    return (0, _builder$1.default)("BooleanLiteral", ...arguments);
  }

  function regExpLiteral(pattern, flags) {
    return (0, _builder$1.default)("RegExpLiteral", ...arguments);
  }

  function logicalExpression(operator, left, right) {
    return (0, _builder$1.default)("LogicalExpression", ...arguments);
  }

  function memberExpression(object, property, computed, optional) {
    return (0, _builder$1.default)("MemberExpression", ...arguments);
  }

  function newExpression(callee, _arguments) {
    return (0, _builder$1.default)("NewExpression", ...arguments);
  }

  function program$2(body, directives, sourceType, interpreter) {
    return (0, _builder$1.default)("Program", ...arguments);
  }

  function objectExpression(properties) {
    return (0, _builder$1.default)("ObjectExpression", ...arguments);
  }

  function objectMethod(kind, key, params, body, computed, generator, async) {
    return (0, _builder$1.default)("ObjectMethod", ...arguments);
  }

  function objectProperty(key, value, computed, shorthand, decorators) {
    return (0, _builder$1.default)("ObjectProperty", ...arguments);
  }

  function restElement(argument) {
    return (0, _builder$1.default)("RestElement", ...arguments);
  }

  function returnStatement(argument) {
    return (0, _builder$1.default)("ReturnStatement", ...arguments);
  }

  function sequenceExpression(expressions) {
    return (0, _builder$1.default)("SequenceExpression", ...arguments);
  }

  function parenthesizedExpression(expression) {
    return (0, _builder$1.default)("ParenthesizedExpression", ...arguments);
  }

  function switchCase(test, consequent) {
    return (0, _builder$1.default)("SwitchCase", ...arguments);
  }

  function switchStatement(discriminant, cases) {
    return (0, _builder$1.default)("SwitchStatement", ...arguments);
  }

  function thisExpression() {
    return (0, _builder$1.default)("ThisExpression", ...arguments);
  }

  function throwStatement(argument) {
    return (0, _builder$1.default)("ThrowStatement", ...arguments);
  }

  function tryStatement(block, handler, finalizer) {
    return (0, _builder$1.default)("TryStatement", ...arguments);
  }

  function unaryExpression(operator, argument, prefix) {
    return (0, _builder$1.default)("UnaryExpression", ...arguments);
  }

  function updateExpression(operator, argument, prefix) {
    return (0, _builder$1.default)("UpdateExpression", ...arguments);
  }

  function variableDeclaration(kind, declarations) {
    return (0, _builder$1.default)("VariableDeclaration", ...arguments);
  }

  function variableDeclarator(id, init) {
    return (0, _builder$1.default)("VariableDeclarator", ...arguments);
  }

  function whileStatement(test, body) {
    return (0, _builder$1.default)("WhileStatement", ...arguments);
  }

  function withStatement(object, body) {
    return (0, _builder$1.default)("WithStatement", ...arguments);
  }

  function assignmentPattern(left, right) {
    return (0, _builder$1.default)("AssignmentPattern", ...arguments);
  }

  function arrayPattern(elements) {
    return (0, _builder$1.default)("ArrayPattern", ...arguments);
  }

  function arrowFunctionExpression(params, body, async) {
    return (0, _builder$1.default)("ArrowFunctionExpression", ...arguments);
  }

  function classBody(body) {
    return (0, _builder$1.default)("ClassBody", ...arguments);
  }

  function classExpression(id, superClass, body, decorators) {
    return (0, _builder$1.default)("ClassExpression", ...arguments);
  }

  function classDeclaration(id, superClass, body, decorators) {
    return (0, _builder$1.default)("ClassDeclaration", ...arguments);
  }

  function exportAllDeclaration(source) {
    return (0, _builder$1.default)("ExportAllDeclaration", ...arguments);
  }

  function exportDefaultDeclaration(declaration) {
    return (0, _builder$1.default)("ExportDefaultDeclaration", ...arguments);
  }

  function exportNamedDeclaration(declaration, specifiers, source) {
    return (0, _builder$1.default)("ExportNamedDeclaration", ...arguments);
  }

  function exportSpecifier(local, exported) {
    return (0, _builder$1.default)("ExportSpecifier", ...arguments);
  }

  function forOfStatement(left, right, body, _await) {
    return (0, _builder$1.default)("ForOfStatement", ...arguments);
  }

  function importDeclaration(specifiers, source) {
    return (0, _builder$1.default)("ImportDeclaration", ...arguments);
  }

  function importDefaultSpecifier(local) {
    return (0, _builder$1.default)("ImportDefaultSpecifier", ...arguments);
  }

  function importNamespaceSpecifier(local) {
    return (0, _builder$1.default)("ImportNamespaceSpecifier", ...arguments);
  }

  function importSpecifier(local, imported) {
    return (0, _builder$1.default)("ImportSpecifier", ...arguments);
  }

  function metaProperty(meta, property) {
    return (0, _builder$1.default)("MetaProperty", ...arguments);
  }

  function classMethod(kind, key, params, body, computed, _static, generator, async) {
    return (0, _builder$1.default)("ClassMethod", ...arguments);
  }

  function objectPattern(properties) {
    return (0, _builder$1.default)("ObjectPattern", ...arguments);
  }

  function spreadElement(argument) {
    return (0, _builder$1.default)("SpreadElement", ...arguments);
  }

  function _super() {
    return (0, _builder$1.default)("Super", ...arguments);
  }

  function taggedTemplateExpression(tag, quasi) {
    return (0, _builder$1.default)("TaggedTemplateExpression", ...arguments);
  }

  function templateElement(value, tail) {
    return (0, _builder$1.default)("TemplateElement", ...arguments);
  }

  function templateLiteral(quasis, expressions) {
    return (0, _builder$1.default)("TemplateLiteral", ...arguments);
  }

  function yieldExpression(argument, delegate) {
    return (0, _builder$1.default)("YieldExpression", ...arguments);
  }

  function awaitExpression(argument) {
    return (0, _builder$1.default)("AwaitExpression", ...arguments);
  }

  function _import() {
    return (0, _builder$1.default)("Import", ...arguments);
  }

  function bigIntLiteral(value) {
    return (0, _builder$1.default)("BigIntLiteral", ...arguments);
  }

  function exportNamespaceSpecifier(exported) {
    return (0, _builder$1.default)("ExportNamespaceSpecifier", ...arguments);
  }

  function optionalMemberExpression(object, property, computed, optional) {
    return (0, _builder$1.default)("OptionalMemberExpression", ...arguments);
  }

  function optionalCallExpression(callee, _arguments, optional) {
    return (0, _builder$1.default)("OptionalCallExpression", ...arguments);
  }

  function anyTypeAnnotation() {
    return (0, _builder$1.default)("AnyTypeAnnotation", ...arguments);
  }

  function arrayTypeAnnotation(elementType) {
    return (0, _builder$1.default)("ArrayTypeAnnotation", ...arguments);
  }

  function booleanTypeAnnotation() {
    return (0, _builder$1.default)("BooleanTypeAnnotation", ...arguments);
  }

  function booleanLiteralTypeAnnotation(value) {
    return (0, _builder$1.default)("BooleanLiteralTypeAnnotation", ...arguments);
  }

  function nullLiteralTypeAnnotation() {
    return (0, _builder$1.default)("NullLiteralTypeAnnotation", ...arguments);
  }

  function classImplements(id, typeParameters) {
    return (0, _builder$1.default)("ClassImplements", ...arguments);
  }

  function declareClass(id, typeParameters, _extends, body) {
    return (0, _builder$1.default)("DeclareClass", ...arguments);
  }

  function declareFunction(id) {
    return (0, _builder$1.default)("DeclareFunction", ...arguments);
  }

  function declareInterface(id, typeParameters, _extends, body) {
    return (0, _builder$1.default)("DeclareInterface", ...arguments);
  }

  function declareModule(id, body, kind) {
    return (0, _builder$1.default)("DeclareModule", ...arguments);
  }

  function declareModuleExports(typeAnnotation) {
    return (0, _builder$1.default)("DeclareModuleExports", ...arguments);
  }

  function declareTypeAlias(id, typeParameters, right) {
    return (0, _builder$1.default)("DeclareTypeAlias", ...arguments);
  }

  function declareOpaqueType(id, typeParameters, supertype) {
    return (0, _builder$1.default)("DeclareOpaqueType", ...arguments);
  }

  function declareVariable(id) {
    return (0, _builder$1.default)("DeclareVariable", ...arguments);
  }

  function declareExportDeclaration(declaration, specifiers, source) {
    return (0, _builder$1.default)("DeclareExportDeclaration", ...arguments);
  }

  function declareExportAllDeclaration(source) {
    return (0, _builder$1.default)("DeclareExportAllDeclaration", ...arguments);
  }

  function declaredPredicate(value) {
    return (0, _builder$1.default)("DeclaredPredicate", ...arguments);
  }

  function existsTypeAnnotation() {
    return (0, _builder$1.default)("ExistsTypeAnnotation", ...arguments);
  }

  function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    return (0, _builder$1.default)("FunctionTypeAnnotation", ...arguments);
  }

  function functionTypeParam(name, typeAnnotation) {
    return (0, _builder$1.default)("FunctionTypeParam", ...arguments);
  }

  function genericTypeAnnotation(id, typeParameters) {
    return (0, _builder$1.default)("GenericTypeAnnotation", ...arguments);
  }

  function inferredPredicate() {
    return (0, _builder$1.default)("InferredPredicate", ...arguments);
  }

  function interfaceExtends(id, typeParameters) {
    return (0, _builder$1.default)("InterfaceExtends", ...arguments);
  }

  function interfaceDeclaration(id, typeParameters, _extends, body) {
    return (0, _builder$1.default)("InterfaceDeclaration", ...arguments);
  }

  function interfaceTypeAnnotation(_extends, body) {
    return (0, _builder$1.default)("InterfaceTypeAnnotation", ...arguments);
  }

  function intersectionTypeAnnotation(types) {
    return (0, _builder$1.default)("IntersectionTypeAnnotation", ...arguments);
  }

  function mixedTypeAnnotation() {
    return (0, _builder$1.default)("MixedTypeAnnotation", ...arguments);
  }

  function emptyTypeAnnotation() {
    return (0, _builder$1.default)("EmptyTypeAnnotation", ...arguments);
  }

  function nullableTypeAnnotation(typeAnnotation) {
    return (0, _builder$1.default)("NullableTypeAnnotation", ...arguments);
  }

  function numberLiteralTypeAnnotation(value) {
    return (0, _builder$1.default)("NumberLiteralTypeAnnotation", ...arguments);
  }

  function numberTypeAnnotation() {
    return (0, _builder$1.default)("NumberTypeAnnotation", ...arguments);
  }

  function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    return (0, _builder$1.default)("ObjectTypeAnnotation", ...arguments);
  }

  function objectTypeInternalSlot(id, value, optional, _static, method) {
    return (0, _builder$1.default)("ObjectTypeInternalSlot", ...arguments);
  }

  function objectTypeCallProperty(value) {
    return (0, _builder$1.default)("ObjectTypeCallProperty", ...arguments);
  }

  function objectTypeIndexer(id, key, value, variance) {
    return (0, _builder$1.default)("ObjectTypeIndexer", ...arguments);
  }

  function objectTypeProperty(key, value, variance) {
    return (0, _builder$1.default)("ObjectTypeProperty", ...arguments);
  }

  function objectTypeSpreadProperty(argument) {
    return (0, _builder$1.default)("ObjectTypeSpreadProperty", ...arguments);
  }

  function opaqueType(id, typeParameters, supertype, impltype) {
    return (0, _builder$1.default)("OpaqueType", ...arguments);
  }

  function qualifiedTypeIdentifier(id, qualification) {
    return (0, _builder$1.default)("QualifiedTypeIdentifier", ...arguments);
  }

  function stringLiteralTypeAnnotation(value) {
    return (0, _builder$1.default)("StringLiteralTypeAnnotation", ...arguments);
  }

  function stringTypeAnnotation() {
    return (0, _builder$1.default)("StringTypeAnnotation", ...arguments);
  }

  function symbolTypeAnnotation() {
    return (0, _builder$1.default)("SymbolTypeAnnotation", ...arguments);
  }

  function thisTypeAnnotation() {
    return (0, _builder$1.default)("ThisTypeAnnotation", ...arguments);
  }

  function tupleTypeAnnotation(types) {
    return (0, _builder$1.default)("TupleTypeAnnotation", ...arguments);
  }

  function typeofTypeAnnotation(argument) {
    return (0, _builder$1.default)("TypeofTypeAnnotation", ...arguments);
  }

  function typeAlias(id, typeParameters, right) {
    return (0, _builder$1.default)("TypeAlias", ...arguments);
  }

  function typeAnnotation(typeAnnotation) {
    return (0, _builder$1.default)("TypeAnnotation", ...arguments);
  }

  function typeCastExpression(expression, typeAnnotation) {
    return (0, _builder$1.default)("TypeCastExpression", ...arguments);
  }

  function typeParameter(bound, _default, variance) {
    return (0, _builder$1.default)("TypeParameter", ...arguments);
  }

  function typeParameterDeclaration(params) {
    return (0, _builder$1.default)("TypeParameterDeclaration", ...arguments);
  }

  function typeParameterInstantiation(params) {
    return (0, _builder$1.default)("TypeParameterInstantiation", ...arguments);
  }

  function unionTypeAnnotation(types) {
    return (0, _builder$1.default)("UnionTypeAnnotation", ...arguments);
  }

  function variance(kind) {
    return (0, _builder$1.default)("Variance", ...arguments);
  }

  function voidTypeAnnotation() {
    return (0, _builder$1.default)("VoidTypeAnnotation", ...arguments);
  }

  function enumDeclaration(id, body) {
    return (0, _builder$1.default)("EnumDeclaration", ...arguments);
  }

  function enumBooleanBody(members) {
    return (0, _builder$1.default)("EnumBooleanBody", ...arguments);
  }

  function enumNumberBody(members) {
    return (0, _builder$1.default)("EnumNumberBody", ...arguments);
  }

  function enumStringBody(members) {
    return (0, _builder$1.default)("EnumStringBody", ...arguments);
  }

  function enumSymbolBody(members) {
    return (0, _builder$1.default)("EnumSymbolBody", ...arguments);
  }

  function enumBooleanMember(id) {
    return (0, _builder$1.default)("EnumBooleanMember", ...arguments);
  }

  function enumNumberMember(id, init) {
    return (0, _builder$1.default)("EnumNumberMember", ...arguments);
  }

  function enumStringMember(id, init) {
    return (0, _builder$1.default)("EnumStringMember", ...arguments);
  }

  function enumDefaultedMember(id) {
    return (0, _builder$1.default)("EnumDefaultedMember", ...arguments);
  }

  function indexedAccessType(objectType, indexType) {
    return (0, _builder$1.default)("IndexedAccessType", ...arguments);
  }

  function optionalIndexedAccessType(objectType, indexType) {
    return (0, _builder$1.default)("OptionalIndexedAccessType", ...arguments);
  }

  function jsxAttribute(name, value) {
    return (0, _builder$1.default)("JSXAttribute", ...arguments);
  }

  function jsxClosingElement(name) {
    return (0, _builder$1.default)("JSXClosingElement", ...arguments);
  }

  function jsxElement(openingElement, closingElement, children, selfClosing) {
    return (0, _builder$1.default)("JSXElement", ...arguments);
  }

  function jsxEmptyExpression() {
    return (0, _builder$1.default)("JSXEmptyExpression", ...arguments);
  }

  function jsxExpressionContainer(expression) {
    return (0, _builder$1.default)("JSXExpressionContainer", ...arguments);
  }

  function jsxSpreadChild(expression) {
    return (0, _builder$1.default)("JSXSpreadChild", ...arguments);
  }

  function jsxIdentifier(name) {
    return (0, _builder$1.default)("JSXIdentifier", ...arguments);
  }

  function jsxMemberExpression(object, property) {
    return (0, _builder$1.default)("JSXMemberExpression", ...arguments);
  }

  function jsxNamespacedName(namespace, name) {
    return (0, _builder$1.default)("JSXNamespacedName", ...arguments);
  }

  function jsxOpeningElement(name, attributes, selfClosing) {
    return (0, _builder$1.default)("JSXOpeningElement", ...arguments);
  }

  function jsxSpreadAttribute(argument) {
    return (0, _builder$1.default)("JSXSpreadAttribute", ...arguments);
  }

  function jsxText(value) {
    return (0, _builder$1.default)("JSXText", ...arguments);
  }

  function jsxFragment(openingFragment, closingFragment, children) {
    return (0, _builder$1.default)("JSXFragment", ...arguments);
  }

  function jsxOpeningFragment() {
    return (0, _builder$1.default)("JSXOpeningFragment", ...arguments);
  }

  function jsxClosingFragment() {
    return (0, _builder$1.default)("JSXClosingFragment", ...arguments);
  }

  function noop() {
    return (0, _builder$1.default)("Noop", ...arguments);
  }

  function placeholder(expectedNode, name) {
    return (0, _builder$1.default)("Placeholder", ...arguments);
  }

  function v8IntrinsicIdentifier(name) {
    return (0, _builder$1.default)("V8IntrinsicIdentifier", ...arguments);
  }

  function argumentPlaceholder() {
    return (0, _builder$1.default)("ArgumentPlaceholder", ...arguments);
  }

  function bindExpression(object, callee) {
    return (0, _builder$1.default)("BindExpression", ...arguments);
  }

  function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return (0, _builder$1.default)("ClassProperty", ...arguments);
  }

  function pipelineTopicExpression(expression) {
    return (0, _builder$1.default)("PipelineTopicExpression", ...arguments);
  }

  function pipelineBareFunction(callee) {
    return (0, _builder$1.default)("PipelineBareFunction", ...arguments);
  }

  function pipelinePrimaryTopicReference() {
    return (0, _builder$1.default)("PipelinePrimaryTopicReference", ...arguments);
  }

  function classPrivateProperty(key, value, decorators, _static) {
    return (0, _builder$1.default)("ClassPrivateProperty", ...arguments);
  }

  function classPrivateMethod(kind, key, params, body, _static) {
    return (0, _builder$1.default)("ClassPrivateMethod", ...arguments);
  }

  function importAttribute(key, value) {
    return (0, _builder$1.default)("ImportAttribute", ...arguments);
  }

  function decorator(expression) {
    return (0, _builder$1.default)("Decorator", ...arguments);
  }

  function doExpression(body, async) {
    return (0, _builder$1.default)("DoExpression", ...arguments);
  }

  function exportDefaultSpecifier(exported) {
    return (0, _builder$1.default)("ExportDefaultSpecifier", ...arguments);
  }

  function privateName(id) {
    return (0, _builder$1.default)("PrivateName", ...arguments);
  }

  function recordExpression(properties) {
    return (0, _builder$1.default)("RecordExpression", ...arguments);
  }

  function tupleExpression(elements) {
    return (0, _builder$1.default)("TupleExpression", ...arguments);
  }

  function decimalLiteral(value) {
    return (0, _builder$1.default)("DecimalLiteral", ...arguments);
  }

  function staticBlock(body) {
    return (0, _builder$1.default)("StaticBlock", ...arguments);
  }

  function moduleExpression(body) {
    return (0, _builder$1.default)("ModuleExpression", ...arguments);
  }

  function tsParameterProperty(parameter) {
    return (0, _builder$1.default)("TSParameterProperty", ...arguments);
  }

  function tsDeclareFunction(id, typeParameters, params, returnType) {
    return (0, _builder$1.default)("TSDeclareFunction", ...arguments);
  }

  function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    return (0, _builder$1.default)("TSDeclareMethod", ...arguments);
  }

  function tsQualifiedName(left, right) {
    return (0, _builder$1.default)("TSQualifiedName", ...arguments);
  }

  function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return (0, _builder$1.default)("TSCallSignatureDeclaration", ...arguments);
  }

  function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return (0, _builder$1.default)("TSConstructSignatureDeclaration", ...arguments);
  }

  function tsPropertySignature(key, typeAnnotation, initializer) {
    return (0, _builder$1.default)("TSPropertySignature", ...arguments);
  }

  function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    return (0, _builder$1.default)("TSMethodSignature", ...arguments);
  }

  function tsIndexSignature(parameters, typeAnnotation) {
    return (0, _builder$1.default)("TSIndexSignature", ...arguments);
  }

  function tsAnyKeyword() {
    return (0, _builder$1.default)("TSAnyKeyword", ...arguments);
  }

  function tsBooleanKeyword() {
    return (0, _builder$1.default)("TSBooleanKeyword", ...arguments);
  }

  function tsBigIntKeyword() {
    return (0, _builder$1.default)("TSBigIntKeyword", ...arguments);
  }

  function tsIntrinsicKeyword() {
    return (0, _builder$1.default)("TSIntrinsicKeyword", ...arguments);
  }

  function tsNeverKeyword() {
    return (0, _builder$1.default)("TSNeverKeyword", ...arguments);
  }

  function tsNullKeyword() {
    return (0, _builder$1.default)("TSNullKeyword", ...arguments);
  }

  function tsNumberKeyword() {
    return (0, _builder$1.default)("TSNumberKeyword", ...arguments);
  }

  function tsObjectKeyword() {
    return (0, _builder$1.default)("TSObjectKeyword", ...arguments);
  }

  function tsStringKeyword() {
    return (0, _builder$1.default)("TSStringKeyword", ...arguments);
  }

  function tsSymbolKeyword() {
    return (0, _builder$1.default)("TSSymbolKeyword", ...arguments);
  }

  function tsUndefinedKeyword() {
    return (0, _builder$1.default)("TSUndefinedKeyword", ...arguments);
  }

  function tsUnknownKeyword() {
    return (0, _builder$1.default)("TSUnknownKeyword", ...arguments);
  }

  function tsVoidKeyword() {
    return (0, _builder$1.default)("TSVoidKeyword", ...arguments);
  }

  function tsThisType() {
    return (0, _builder$1.default)("TSThisType", ...arguments);
  }

  function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    return (0, _builder$1.default)("TSFunctionType", ...arguments);
  }

  function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    return (0, _builder$1.default)("TSConstructorType", ...arguments);
  }

  function tsTypeReference(typeName, typeParameters) {
    return (0, _builder$1.default)("TSTypeReference", ...arguments);
  }

  function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    return (0, _builder$1.default)("TSTypePredicate", ...arguments);
  }

  function tsTypeQuery(exprName) {
    return (0, _builder$1.default)("TSTypeQuery", ...arguments);
  }

  function tsTypeLiteral(members) {
    return (0, _builder$1.default)("TSTypeLiteral", ...arguments);
  }

  function tsArrayType(elementType) {
    return (0, _builder$1.default)("TSArrayType", ...arguments);
  }

  function tsTupleType(elementTypes) {
    return (0, _builder$1.default)("TSTupleType", ...arguments);
  }

  function tsOptionalType(typeAnnotation) {
    return (0, _builder$1.default)("TSOptionalType", ...arguments);
  }

  function tsRestType(typeAnnotation) {
    return (0, _builder$1.default)("TSRestType", ...arguments);
  }

  function tsNamedTupleMember(label, elementType, optional) {
    return (0, _builder$1.default)("TSNamedTupleMember", ...arguments);
  }

  function tsUnionType(types) {
    return (0, _builder$1.default)("TSUnionType", ...arguments);
  }

  function tsIntersectionType(types) {
    return (0, _builder$1.default)("TSIntersectionType", ...arguments);
  }

  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return (0, _builder$1.default)("TSConditionalType", ...arguments);
  }

  function tsInferType(typeParameter) {
    return (0, _builder$1.default)("TSInferType", ...arguments);
  }

  function tsParenthesizedType(typeAnnotation) {
    return (0, _builder$1.default)("TSParenthesizedType", ...arguments);
  }

  function tsTypeOperator(typeAnnotation) {
    return (0, _builder$1.default)("TSTypeOperator", ...arguments);
  }

  function tsIndexedAccessType(objectType, indexType) {
    return (0, _builder$1.default)("TSIndexedAccessType", ...arguments);
  }

  function tsMappedType(typeParameter, typeAnnotation, nameType) {
    return (0, _builder$1.default)("TSMappedType", ...arguments);
  }

  function tsLiteralType(literal) {
    return (0, _builder$1.default)("TSLiteralType", ...arguments);
  }

  function tsExpressionWithTypeArguments(expression, typeParameters) {
    return (0, _builder$1.default)("TSExpressionWithTypeArguments", ...arguments);
  }

  function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    return (0, _builder$1.default)("TSInterfaceDeclaration", ...arguments);
  }

  function tsInterfaceBody(body) {
    return (0, _builder$1.default)("TSInterfaceBody", ...arguments);
  }

  function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    return (0, _builder$1.default)("TSTypeAliasDeclaration", ...arguments);
  }

  function tsAsExpression(expression, typeAnnotation) {
    return (0, _builder$1.default)("TSAsExpression", ...arguments);
  }

  function tsTypeAssertion(typeAnnotation, expression) {
    return (0, _builder$1.default)("TSTypeAssertion", ...arguments);
  }

  function tsEnumDeclaration(id, members) {
    return (0, _builder$1.default)("TSEnumDeclaration", ...arguments);
  }

  function tsEnumMember(id, initializer) {
    return (0, _builder$1.default)("TSEnumMember", ...arguments);
  }

  function tsModuleDeclaration(id, body) {
    return (0, _builder$1.default)("TSModuleDeclaration", ...arguments);
  }

  function tsModuleBlock(body) {
    return (0, _builder$1.default)("TSModuleBlock", ...arguments);
  }

  function tsImportType(argument, qualifier, typeParameters) {
    return (0, _builder$1.default)("TSImportType", ...arguments);
  }

  function tsImportEqualsDeclaration(id, moduleReference) {
    return (0, _builder$1.default)("TSImportEqualsDeclaration", ...arguments);
  }

  function tsExternalModuleReference(expression) {
    return (0, _builder$1.default)("TSExternalModuleReference", ...arguments);
  }

  function tsNonNullExpression(expression) {
    return (0, _builder$1.default)("TSNonNullExpression", ...arguments);
  }

  function tsExportAssignment(expression) {
    return (0, _builder$1.default)("TSExportAssignment", ...arguments);
  }

  function tsNamespaceExportDeclaration(id) {
    return (0, _builder$1.default)("TSNamespaceExportDeclaration", ...arguments);
  }

  function tsTypeAnnotation(typeAnnotation) {
    return (0, _builder$1.default)("TSTypeAnnotation", ...arguments);
  }

  function tsTypeParameterInstantiation(params) {
    return (0, _builder$1.default)("TSTypeParameterInstantiation", ...arguments);
  }

  function tsTypeParameterDeclaration(params) {
    return (0, _builder$1.default)("TSTypeParameterDeclaration", ...arguments);
  }

  function tsTypeParameter(constraint, _default, name) {
    return (0, _builder$1.default)("TSTypeParameter", ...arguments);
  }

  function NumberLiteral(...args) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    return (0, _builder$1.default)("NumberLiteral", ...args);
  }

  function RegexLiteral(...args) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    return (0, _builder$1.default)("RegexLiteral", ...args);
  }

  function RestProperty$1(...args) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    return (0, _builder$1.default)("RestProperty", ...args);
  }

  function SpreadProperty$1(...args) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    return (0, _builder$1.default)("SpreadProperty", ...args);
  }

  Object.defineProperty(cleanJSXElementLiteralChild$1, "__esModule", {
    value: true
  });
  cleanJSXElementLiteralChild$1.default = cleanJSXElementLiteralChild;

  var _generated$n = generated$3;

  function cleanJSXElementLiteralChild(child, args) {
    const lines = child.value.split(/\r\n|\n|\r/);
    let lastNonEmptyLine = 0;

    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    let str = "";

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isFirstLine = i === 0;
      const isLastLine = i === lines.length - 1;
      const isLastNonEmptyLine = i === lastNonEmptyLine;
      let trimmedLine = line.replace(/\t/g, " ");

      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }

      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }

        str += trimmedLine;
      }
    }

    if (str) args.push((0, _generated$n.stringLiteral)(str));
  }

  Object.defineProperty(buildChildren$1, "__esModule", {
    value: true
  });
  buildChildren$1.default = buildChildren;

  var _generated$m = generated$4;

  var _cleanJSXElementLiteralChild = cleanJSXElementLiteralChild$1;

  function buildChildren(node) {
    const elements = [];

    for (let i = 0; i < node.children.length; i++) {
      let child = node.children[i];

      if ((0, _generated$m.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild.default)(child, elements);
        continue;
      }

      if ((0, _generated$m.isJSXExpressionContainer)(child)) child = child.expression;
      if ((0, _generated$m.isJSXEmptyExpression)(child)) continue;
      elements.push(child);
    }

    return elements;
  }

  var assertNode$1 = {};

  var isNode$1 = {};

  Object.defineProperty(isNode$1, "__esModule", {
    value: true
  });
  isNode$1.default = isNode;

  var _definitions$5 = definitions;

  function isNode(node) {
    return !!(node && _definitions$5.VISITOR_KEYS[node.type]);
  }

  Object.defineProperty(assertNode$1, "__esModule", {
    value: true
  });
  assertNode$1.default = assertNode;

  var _isNode = isNode$1;

  function assertNode(node) {
    if (!(0, _isNode.default)(node)) {
      var _node$type;

      const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
      throw new TypeError(`Not a valid node of type "${type}"`);
    }
  }

  var generated$2 = {};

  Object.defineProperty(generated$2, "__esModule", {
    value: true
  });
  generated$2.assertArrayExpression = assertArrayExpression;
  generated$2.assertAssignmentExpression = assertAssignmentExpression;
  generated$2.assertBinaryExpression = assertBinaryExpression;
  generated$2.assertInterpreterDirective = assertInterpreterDirective;
  generated$2.assertDirective = assertDirective;
  generated$2.assertDirectiveLiteral = assertDirectiveLiteral;
  generated$2.assertBlockStatement = assertBlockStatement;
  generated$2.assertBreakStatement = assertBreakStatement;
  generated$2.assertCallExpression = assertCallExpression;
  generated$2.assertCatchClause = assertCatchClause;
  generated$2.assertConditionalExpression = assertConditionalExpression;
  generated$2.assertContinueStatement = assertContinueStatement;
  generated$2.assertDebuggerStatement = assertDebuggerStatement;
  generated$2.assertDoWhileStatement = assertDoWhileStatement;
  generated$2.assertEmptyStatement = assertEmptyStatement;
  generated$2.assertExpressionStatement = assertExpressionStatement;
  generated$2.assertFile = assertFile;
  generated$2.assertForInStatement = assertForInStatement;
  generated$2.assertForStatement = assertForStatement;
  generated$2.assertFunctionDeclaration = assertFunctionDeclaration;
  generated$2.assertFunctionExpression = assertFunctionExpression;
  generated$2.assertIdentifier = assertIdentifier;
  generated$2.assertIfStatement = assertIfStatement;
  generated$2.assertLabeledStatement = assertLabeledStatement;
  generated$2.assertStringLiteral = assertStringLiteral;
  generated$2.assertNumericLiteral = assertNumericLiteral;
  generated$2.assertNullLiteral = assertNullLiteral;
  generated$2.assertBooleanLiteral = assertBooleanLiteral;
  generated$2.assertRegExpLiteral = assertRegExpLiteral;
  generated$2.assertLogicalExpression = assertLogicalExpression;
  generated$2.assertMemberExpression = assertMemberExpression;
  generated$2.assertNewExpression = assertNewExpression;
  generated$2.assertProgram = assertProgram;
  generated$2.assertObjectExpression = assertObjectExpression;
  generated$2.assertObjectMethod = assertObjectMethod;
  generated$2.assertObjectProperty = assertObjectProperty;
  generated$2.assertRestElement = assertRestElement;
  generated$2.assertReturnStatement = assertReturnStatement;
  generated$2.assertSequenceExpression = assertSequenceExpression;
  generated$2.assertParenthesizedExpression = assertParenthesizedExpression;
  generated$2.assertSwitchCase = assertSwitchCase;
  generated$2.assertSwitchStatement = assertSwitchStatement;
  generated$2.assertThisExpression = assertThisExpression;
  generated$2.assertThrowStatement = assertThrowStatement;
  generated$2.assertTryStatement = assertTryStatement;
  generated$2.assertUnaryExpression = assertUnaryExpression;
  generated$2.assertUpdateExpression = assertUpdateExpression;
  generated$2.assertVariableDeclaration = assertVariableDeclaration;
  generated$2.assertVariableDeclarator = assertVariableDeclarator;
  generated$2.assertWhileStatement = assertWhileStatement;
  generated$2.assertWithStatement = assertWithStatement;
  generated$2.assertAssignmentPattern = assertAssignmentPattern;
  generated$2.assertArrayPattern = assertArrayPattern;
  generated$2.assertArrowFunctionExpression = assertArrowFunctionExpression;
  generated$2.assertClassBody = assertClassBody;
  generated$2.assertClassExpression = assertClassExpression;
  generated$2.assertClassDeclaration = assertClassDeclaration;
  generated$2.assertExportAllDeclaration = assertExportAllDeclaration;
  generated$2.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  generated$2.assertExportNamedDeclaration = assertExportNamedDeclaration;
  generated$2.assertExportSpecifier = assertExportSpecifier;
  generated$2.assertForOfStatement = assertForOfStatement;
  generated$2.assertImportDeclaration = assertImportDeclaration;
  generated$2.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  generated$2.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  generated$2.assertImportSpecifier = assertImportSpecifier;
  generated$2.assertMetaProperty = assertMetaProperty;
  generated$2.assertClassMethod = assertClassMethod;
  generated$2.assertObjectPattern = assertObjectPattern;
  generated$2.assertSpreadElement = assertSpreadElement;
  generated$2.assertSuper = assertSuper;
  generated$2.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  generated$2.assertTemplateElement = assertTemplateElement;
  generated$2.assertTemplateLiteral = assertTemplateLiteral;
  generated$2.assertYieldExpression = assertYieldExpression;
  generated$2.assertAwaitExpression = assertAwaitExpression;
  generated$2.assertImport = assertImport;
  generated$2.assertBigIntLiteral = assertBigIntLiteral;
  generated$2.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  generated$2.assertOptionalMemberExpression = assertOptionalMemberExpression;
  generated$2.assertOptionalCallExpression = assertOptionalCallExpression;
  generated$2.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  generated$2.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  generated$2.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  generated$2.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
  generated$2.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  generated$2.assertClassImplements = assertClassImplements;
  generated$2.assertDeclareClass = assertDeclareClass;
  generated$2.assertDeclareFunction = assertDeclareFunction;
  generated$2.assertDeclareInterface = assertDeclareInterface;
  generated$2.assertDeclareModule = assertDeclareModule;
  generated$2.assertDeclareModuleExports = assertDeclareModuleExports;
  generated$2.assertDeclareTypeAlias = assertDeclareTypeAlias;
  generated$2.assertDeclareOpaqueType = assertDeclareOpaqueType;
  generated$2.assertDeclareVariable = assertDeclareVariable;
  generated$2.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  generated$2.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
  generated$2.assertDeclaredPredicate = assertDeclaredPredicate;
  generated$2.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  generated$2.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  generated$2.assertFunctionTypeParam = assertFunctionTypeParam;
  generated$2.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  generated$2.assertInferredPredicate = assertInferredPredicate;
  generated$2.assertInterfaceExtends = assertInterfaceExtends;
  generated$2.assertInterfaceDeclaration = assertInterfaceDeclaration;
  generated$2.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  generated$2.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
  generated$2.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  generated$2.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  generated$2.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  generated$2.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
  generated$2.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  generated$2.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  generated$2.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  generated$2.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  generated$2.assertObjectTypeIndexer = assertObjectTypeIndexer;
  generated$2.assertObjectTypeProperty = assertObjectTypeProperty;
  generated$2.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  generated$2.assertOpaqueType = assertOpaqueType;
  generated$2.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  generated$2.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
  generated$2.assertStringTypeAnnotation = assertStringTypeAnnotation;
  generated$2.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  generated$2.assertThisTypeAnnotation = assertThisTypeAnnotation;
  generated$2.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  generated$2.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  generated$2.assertTypeAlias = assertTypeAlias;
  generated$2.assertTypeAnnotation = assertTypeAnnotation;
  generated$2.assertTypeCastExpression = assertTypeCastExpression;
  generated$2.assertTypeParameter = assertTypeParameter;
  generated$2.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  generated$2.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
  generated$2.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  generated$2.assertVariance = assertVariance;
  generated$2.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  generated$2.assertEnumDeclaration = assertEnumDeclaration;
  generated$2.assertEnumBooleanBody = assertEnumBooleanBody;
  generated$2.assertEnumNumberBody = assertEnumNumberBody;
  generated$2.assertEnumStringBody = assertEnumStringBody;
  generated$2.assertEnumSymbolBody = assertEnumSymbolBody;
  generated$2.assertEnumBooleanMember = assertEnumBooleanMember;
  generated$2.assertEnumNumberMember = assertEnumNumberMember;
  generated$2.assertEnumStringMember = assertEnumStringMember;
  generated$2.assertEnumDefaultedMember = assertEnumDefaultedMember;
  generated$2.assertIndexedAccessType = assertIndexedAccessType;
  generated$2.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  generated$2.assertJSXAttribute = assertJSXAttribute;
  generated$2.assertJSXClosingElement = assertJSXClosingElement;
  generated$2.assertJSXElement = assertJSXElement;
  generated$2.assertJSXEmptyExpression = assertJSXEmptyExpression;
  generated$2.assertJSXExpressionContainer = assertJSXExpressionContainer;
  generated$2.assertJSXSpreadChild = assertJSXSpreadChild;
  generated$2.assertJSXIdentifier = assertJSXIdentifier;
  generated$2.assertJSXMemberExpression = assertJSXMemberExpression;
  generated$2.assertJSXNamespacedName = assertJSXNamespacedName;
  generated$2.assertJSXOpeningElement = assertJSXOpeningElement;
  generated$2.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  generated$2.assertJSXText = assertJSXText;
  generated$2.assertJSXFragment = assertJSXFragment;
  generated$2.assertJSXOpeningFragment = assertJSXOpeningFragment;
  generated$2.assertJSXClosingFragment = assertJSXClosingFragment;
  generated$2.assertNoop = assertNoop;
  generated$2.assertPlaceholder = assertPlaceholder;
  generated$2.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  generated$2.assertArgumentPlaceholder = assertArgumentPlaceholder;
  generated$2.assertBindExpression = assertBindExpression;
  generated$2.assertClassProperty = assertClassProperty;
  generated$2.assertPipelineTopicExpression = assertPipelineTopicExpression;
  generated$2.assertPipelineBareFunction = assertPipelineBareFunction;
  generated$2.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
  generated$2.assertClassPrivateProperty = assertClassPrivateProperty;
  generated$2.assertClassPrivateMethod = assertClassPrivateMethod;
  generated$2.assertImportAttribute = assertImportAttribute;
  generated$2.assertDecorator = assertDecorator;
  generated$2.assertDoExpression = assertDoExpression;
  generated$2.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  generated$2.assertPrivateName = assertPrivateName;
  generated$2.assertRecordExpression = assertRecordExpression;
  generated$2.assertTupleExpression = assertTupleExpression;
  generated$2.assertDecimalLiteral = assertDecimalLiteral;
  generated$2.assertStaticBlock = assertStaticBlock;
  generated$2.assertModuleExpression = assertModuleExpression;
  generated$2.assertTSParameterProperty = assertTSParameterProperty;
  generated$2.assertTSDeclareFunction = assertTSDeclareFunction;
  generated$2.assertTSDeclareMethod = assertTSDeclareMethod;
  generated$2.assertTSQualifiedName = assertTSQualifiedName;
  generated$2.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
  generated$2.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
  generated$2.assertTSPropertySignature = assertTSPropertySignature;
  generated$2.assertTSMethodSignature = assertTSMethodSignature;
  generated$2.assertTSIndexSignature = assertTSIndexSignature;
  generated$2.assertTSAnyKeyword = assertTSAnyKeyword;
  generated$2.assertTSBooleanKeyword = assertTSBooleanKeyword;
  generated$2.assertTSBigIntKeyword = assertTSBigIntKeyword;
  generated$2.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  generated$2.assertTSNeverKeyword = assertTSNeverKeyword;
  generated$2.assertTSNullKeyword = assertTSNullKeyword;
  generated$2.assertTSNumberKeyword = assertTSNumberKeyword;
  generated$2.assertTSObjectKeyword = assertTSObjectKeyword;
  generated$2.assertTSStringKeyword = assertTSStringKeyword;
  generated$2.assertTSSymbolKeyword = assertTSSymbolKeyword;
  generated$2.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  generated$2.assertTSUnknownKeyword = assertTSUnknownKeyword;
  generated$2.assertTSVoidKeyword = assertTSVoidKeyword;
  generated$2.assertTSThisType = assertTSThisType;
  generated$2.assertTSFunctionType = assertTSFunctionType;
  generated$2.assertTSConstructorType = assertTSConstructorType;
  generated$2.assertTSTypeReference = assertTSTypeReference;
  generated$2.assertTSTypePredicate = assertTSTypePredicate;
  generated$2.assertTSTypeQuery = assertTSTypeQuery;
  generated$2.assertTSTypeLiteral = assertTSTypeLiteral;
  generated$2.assertTSArrayType = assertTSArrayType;
  generated$2.assertTSTupleType = assertTSTupleType;
  generated$2.assertTSOptionalType = assertTSOptionalType;
  generated$2.assertTSRestType = assertTSRestType;
  generated$2.assertTSNamedTupleMember = assertTSNamedTupleMember;
  generated$2.assertTSUnionType = assertTSUnionType;
  generated$2.assertTSIntersectionType = assertTSIntersectionType;
  generated$2.assertTSConditionalType = assertTSConditionalType;
  generated$2.assertTSInferType = assertTSInferType;
  generated$2.assertTSParenthesizedType = assertTSParenthesizedType;
  generated$2.assertTSTypeOperator = assertTSTypeOperator;
  generated$2.assertTSIndexedAccessType = assertTSIndexedAccessType;
  generated$2.assertTSMappedType = assertTSMappedType;
  generated$2.assertTSLiteralType = assertTSLiteralType;
  generated$2.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
  generated$2.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  generated$2.assertTSInterfaceBody = assertTSInterfaceBody;
  generated$2.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  generated$2.assertTSAsExpression = assertTSAsExpression;
  generated$2.assertTSTypeAssertion = assertTSTypeAssertion;
  generated$2.assertTSEnumDeclaration = assertTSEnumDeclaration;
  generated$2.assertTSEnumMember = assertTSEnumMember;
  generated$2.assertTSModuleDeclaration = assertTSModuleDeclaration;
  generated$2.assertTSModuleBlock = assertTSModuleBlock;
  generated$2.assertTSImportType = assertTSImportType;
  generated$2.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  generated$2.assertTSExternalModuleReference = assertTSExternalModuleReference;
  generated$2.assertTSNonNullExpression = assertTSNonNullExpression;
  generated$2.assertTSExportAssignment = assertTSExportAssignment;
  generated$2.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
  generated$2.assertTSTypeAnnotation = assertTSTypeAnnotation;
  generated$2.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
  generated$2.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
  generated$2.assertTSTypeParameter = assertTSTypeParameter;
  generated$2.assertExpression = assertExpression;
  generated$2.assertBinary = assertBinary;
  generated$2.assertScopable = assertScopable;
  generated$2.assertBlockParent = assertBlockParent;
  generated$2.assertBlock = assertBlock;
  generated$2.assertStatement = assertStatement;
  generated$2.assertTerminatorless = assertTerminatorless;
  generated$2.assertCompletionStatement = assertCompletionStatement;
  generated$2.assertConditional = assertConditional;
  generated$2.assertLoop = assertLoop;
  generated$2.assertWhile = assertWhile;
  generated$2.assertExpressionWrapper = assertExpressionWrapper;
  generated$2.assertFor = assertFor;
  generated$2.assertForXStatement = assertForXStatement;
  generated$2.assertFunction = assertFunction;
  generated$2.assertFunctionParent = assertFunctionParent;
  generated$2.assertPureish = assertPureish;
  generated$2.assertDeclaration = assertDeclaration;
  generated$2.assertPatternLike = assertPatternLike;
  generated$2.assertLVal = assertLVal;
  generated$2.assertTSEntityName = assertTSEntityName;
  generated$2.assertLiteral = assertLiteral;
  generated$2.assertImmutable = assertImmutable;
  generated$2.assertUserWhitespacable = assertUserWhitespacable;
  generated$2.assertMethod = assertMethod;
  generated$2.assertObjectMember = assertObjectMember;
  generated$2.assertProperty = assertProperty;
  generated$2.assertUnaryLike = assertUnaryLike;
  generated$2.assertPattern = assertPattern;
  generated$2.assertClass = assertClass;
  generated$2.assertModuleDeclaration = assertModuleDeclaration;
  generated$2.assertExportDeclaration = assertExportDeclaration;
  generated$2.assertModuleSpecifier = assertModuleSpecifier;
  generated$2.assertFlow = assertFlow;
  generated$2.assertFlowType = assertFlowType;
  generated$2.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  generated$2.assertFlowDeclaration = assertFlowDeclaration;
  generated$2.assertFlowPredicate = assertFlowPredicate;
  generated$2.assertEnumBody = assertEnumBody;
  generated$2.assertEnumMember = assertEnumMember;
  generated$2.assertJSX = assertJSX;
  generated$2.assertPrivate = assertPrivate;
  generated$2.assertTSTypeElement = assertTSTypeElement;
  generated$2.assertTSType = assertTSType;
  generated$2.assertTSBaseType = assertTSBaseType;
  generated$2.assertNumberLiteral = assertNumberLiteral;
  generated$2.assertRegexLiteral = assertRegexLiteral;
  generated$2.assertRestProperty = assertRestProperty;
  generated$2.assertSpreadProperty = assertSpreadProperty;

  var _is = is$2;

  function assert(type, node, opts) {
    if (!(0, _is.default)(type, node, opts)) {
      throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);
    }
  }

  function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
  }

  function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
  }

  function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
  }

  function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
  }

  function assertDirective(node, opts) {
    assert("Directive", node, opts);
  }

  function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
  }

  function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
  }

  function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
  }

  function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
  }

  function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
  }

  function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
  }

  function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
  }

  function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
  }

  function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
  }

  function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
  }

  function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
  }

  function assertFile(node, opts) {
    assert("File", node, opts);
  }

  function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
  }

  function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
  }

  function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
  }

  function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
  }

  function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
  }

  function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
  }

  function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
  }

  function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
  }

  function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
  }

  function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
  }

  function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
  }

  function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
  }

  function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
  }

  function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
  }

  function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
  }

  function assertProgram(node, opts) {
    assert("Program", node, opts);
  }

  function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
  }

  function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
  }

  function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
  }

  function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
  }

  function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
  }

  function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
  }

  function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
  }

  function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
  }

  function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
  }

  function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
  }

  function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
  }

  function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
  }

  function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
  }

  function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
  }

  function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
  }

  function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
  }

  function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
  }

  function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
  }

  function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
  }

  function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
  }

  function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
  }

  function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
  }

  function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
  }

  function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
  }

  function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
  }

  function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
  }

  function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
  }

  function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
  }

  function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
  }

  function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
  }

  function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
  }

  function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
  }

  function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
  }

  function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
  }

  function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
  }

  function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
  }

  function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
  }

  function assertSuper(node, opts) {
    assert("Super", node, opts);
  }

  function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
  }

  function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
  }

  function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
  }

  function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
  }

  function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
  }

  function assertImport(node, opts) {
    assert("Import", node, opts);
  }

  function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
  }

  function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
  }

  function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
  }

  function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
  }

  function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
  }

  function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
  }

  function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
  }

  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
  }

  function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
  }

  function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
  }

  function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
  }

  function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
  }

  function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
  }

  function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
  }

  function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
  }

  function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
  }

  function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
  }

  function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
  }

  function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
  }

  function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
  }

  function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
  }

  function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
  }

  function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
  }

  function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
  }

  function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
  }

  function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
  }

  function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
  }

  function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
  }

  function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
  }

  function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
  }

  function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
  }

  function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
  }

  function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
  }

  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
  }

  function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
  }

  function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
  }

  function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
  }

  function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
  }

  function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
  }

  function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
  }

  function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
  }

  function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
  }

  function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
  }

  function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
  }

  function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
  }

  function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
  }

  function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
  }

  function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
  }

  function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
  }

  function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
  }

  function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
  }

  function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
  }

  function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
  }

  function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
  }

  function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
  }

  function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
  }

  function assertVariance(node, opts) {
    assert("Variance", node, opts);
  }

  function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
  }

  function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
  }

  function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
  }

  function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
  }

  function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
  }

  function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
  }

  function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
  }

  function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
  }

  function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
  }

  function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
  }

  function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
  }

  function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
  }

  function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
  }

  function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
  }

  function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
  }

  function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
  }

  function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
  }

  function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
  }

  function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
  }

  function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
  }

  function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
  }

  function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
  }

  function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
  }

  function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
  }

  function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
  }

  function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
  }

  function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
  }

  function assertNoop(node, opts) {
    assert("Noop", node, opts);
  }

  function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
  }

  function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
  }

  function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
  }

  function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
  }

  function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
  }

  function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
  }

  function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
  }

  function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
  }

  function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
  }

  function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
  }

  function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
  }

  function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
  }

  function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
  }

  function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
  }

  function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
  }

  function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
  }

  function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
  }

  function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
  }

  function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
  }

  function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
  }

  function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
  }

  function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
  }

  function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
  }

  function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
  }

  function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
  }

  function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
  }

  function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
  }

  function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
  }

  function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
  }

  function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
  }

  function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
  }

  function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
  }

  function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
  }

  function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
  }

  function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
  }

  function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
  }

  function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
  }

  function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
  }

  function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
  }

  function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
  }

  function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
  }

  function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
  }

  function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
  }

  function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
  }

  function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
  }

  function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
  }

  function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
  }

  function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
  }

  function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
  }

  function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
  }

  function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
  }

  function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
  }

  function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
  }

  function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
  }

  function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
  }

  function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
  }

  function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
  }

  function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
  }

  function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
  }

  function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
  }

  function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
  }

  function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
  }

  function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
  }

  function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
  }

  function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
  }

  function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
  }

  function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
  }

  function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
  }

  function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
  }

  function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
  }

  function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
  }

  function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
  }

  function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
  }

  function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
  }

  function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
  }

  function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
  }

  function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
  }

  function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
  }

  function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
  }

  function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
  }

  function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
  }

  function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
  }

  function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
  }

  function assertExpression(node, opts) {
    assert("Expression", node, opts);
  }

  function assertBinary(node, opts) {
    assert("Binary", node, opts);
  }

  function assertScopable(node, opts) {
    assert("Scopable", node, opts);
  }

  function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
  }

  function assertBlock(node, opts) {
    assert("Block", node, opts);
  }

  function assertStatement(node, opts) {
    assert("Statement", node, opts);
  }

  function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
  }

  function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
  }

  function assertConditional(node, opts) {
    assert("Conditional", node, opts);
  }

  function assertLoop(node, opts) {
    assert("Loop", node, opts);
  }

  function assertWhile(node, opts) {
    assert("While", node, opts);
  }

  function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
  }

  function assertFor(node, opts) {
    assert("For", node, opts);
  }

  function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
  }

  function assertFunction(node, opts) {
    assert("Function", node, opts);
  }

  function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
  }

  function assertPureish(node, opts) {
    assert("Pureish", node, opts);
  }

  function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
  }

  function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
  }

  function assertLVal(node, opts) {
    assert("LVal", node, opts);
  }

  function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
  }

  function assertLiteral(node, opts) {
    assert("Literal", node, opts);
  }

  function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
  }

  function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
  }

  function assertMethod(node, opts) {
    assert("Method", node, opts);
  }

  function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
  }

  function assertProperty(node, opts) {
    assert("Property", node, opts);
  }

  function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
  }

  function assertPattern(node, opts) {
    assert("Pattern", node, opts);
  }

  function assertClass(node, opts) {
    assert("Class", node, opts);
  }

  function assertModuleDeclaration(node, opts) {
    assert("ModuleDeclaration", node, opts);
  }

  function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
  }

  function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
  }

  function assertFlow(node, opts) {
    assert("Flow", node, opts);
  }

  function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
  }

  function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
  }

  function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
  }

  function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
  }

  function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
  }

  function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
  }

  function assertJSX(node, opts) {
    assert("JSX", node, opts);
  }

  function assertPrivate(node, opts) {
    assert("Private", node, opts);
  }

  function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
  }

  function assertTSType(node, opts) {
    assert("TSType", node, opts);
  }

  function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
  }

  function assertNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    assert("NumberLiteral", node, opts);
  }

  function assertRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    assert("RegexLiteral", node, opts);
  }

  function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert("RestProperty", node, opts);
  }

  function assertSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    assert("SpreadProperty", node, opts);
  }

  var createTypeAnnotationBasedOnTypeof$1 = {};

  Object.defineProperty(createTypeAnnotationBasedOnTypeof$1, "__esModule", {
    value: true
  });
  createTypeAnnotationBasedOnTypeof$1.default = createTypeAnnotationBasedOnTypeof;

  var _generated$l = generated$3;

  function createTypeAnnotationBasedOnTypeof(type) {
    if (type === "string") {
      return (0, _generated$l.stringTypeAnnotation)();
    } else if (type === "number") {
      return (0, _generated$l.numberTypeAnnotation)();
    } else if (type === "undefined") {
      return (0, _generated$l.voidTypeAnnotation)();
    } else if (type === "boolean") {
      return (0, _generated$l.booleanTypeAnnotation)();
    } else if (type === "function") {
      return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)("Function"));
    } else if (type === "object") {
      return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)("Object"));
    } else if (type === "symbol") {
      return (0, _generated$l.genericTypeAnnotation)((0, _generated$l.identifier)("Symbol"));
    } else if (type === "bigint") {
      return (0, _generated$l.anyTypeAnnotation)();
    } else {
      throw new Error("Invalid typeof value: " + type);
    }
  }

  var createFlowUnionType$1 = {};

  var removeTypeDuplicates$3 = {};

  Object.defineProperty(removeTypeDuplicates$3, "__esModule", {
    value: true
  });
  removeTypeDuplicates$3.default = removeTypeDuplicates$2;

  var _generated$k = generated$4;

  function getQualifiedName(node) {
    return (0, _generated$k.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;
  }

  function removeTypeDuplicates$2(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = [];
    const types = [];

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if ((0, _generated$k.isAnyTypeAnnotation)(node)) {
        return [node];
      }

      if ((0, _generated$k.isFlowBaseAnnotation)(node)) {
        bases[node.type] = node;
        continue;
      }

      if ((0, _generated$k.isUnionTypeAnnotation)(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      if ((0, _generated$k.isGenericTypeAnnotation)(node)) {
        const name = getQualifiedName(node.id);

        if (generics[name]) {
          let existing = generics[name];

          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates$2(existing.typeParameters.params.concat(node.typeParameters.params));
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics[name] = node;
        }

        continue;
      }

      types.push(node);
    }

    for (const type of Object.keys(bases)) {
      types.push(bases[type]);
    }

    for (const name of Object.keys(generics)) {
      types.push(generics[name]);
    }

    return types;
  }

  Object.defineProperty(createFlowUnionType$1, "__esModule", {
    value: true
  });
  createFlowUnionType$1.default = createFlowUnionType;

  var _generated$j = generated$3;

  var _removeTypeDuplicates$1 = removeTypeDuplicates$3;

  function createFlowUnionType(types) {
    const flattened = (0, _removeTypeDuplicates$1.default)(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _generated$j.unionTypeAnnotation)(flattened);
    }
  }

  var createTSUnionType$1 = {};

  var removeTypeDuplicates$1 = {};

  Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
    value: true
  });
  removeTypeDuplicates$1.default = removeTypeDuplicates;

  var _generated$i = generated$4;

  function removeTypeDuplicates(nodes) {
    const generics = {};
    const bases = {};
    const typeGroups = [];
    const types = [];

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if ((0, _generated$i.isTSAnyKeyword)(node)) {
        return [node];
      }

      if ((0, _generated$i.isTSBaseType)(node)) {
        bases[node.type] = node;
        continue;
      }

      if ((0, _generated$i.isTSUnionType)(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      types.push(node);
    }

    for (const type of Object.keys(bases)) {
      types.push(bases[type]);
    }

    for (const name of Object.keys(generics)) {
      types.push(generics[name]);
    }

    return types;
  }

  Object.defineProperty(createTSUnionType$1, "__esModule", {
    value: true
  });
  createTSUnionType$1.default = createTSUnionType;

  var _generated$h = generated$3;

  var _removeTypeDuplicates = removeTypeDuplicates$1;

  function createTSUnionType(typeAnnotations) {
    const types = typeAnnotations.map(type => type.typeAnnotation);
    const flattened = (0, _removeTypeDuplicates.default)(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _generated$h.tsUnionType)(flattened);
    }
  }

  var uppercase = {};

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ArrayExpression", {
    enumerable: true,
    get: function () {
      return _index.arrayExpression;
    }
  });
  Object.defineProperty(exports, "AssignmentExpression", {
    enumerable: true,
    get: function () {
      return _index.assignmentExpression;
    }
  });
  Object.defineProperty(exports, "BinaryExpression", {
    enumerable: true,
    get: function () {
      return _index.binaryExpression;
    }
  });
  Object.defineProperty(exports, "InterpreterDirective", {
    enumerable: true,
    get: function () {
      return _index.interpreterDirective;
    }
  });
  Object.defineProperty(exports, "Directive", {
    enumerable: true,
    get: function () {
      return _index.directive;
    }
  });
  Object.defineProperty(exports, "DirectiveLiteral", {
    enumerable: true,
    get: function () {
      return _index.directiveLiteral;
    }
  });
  Object.defineProperty(exports, "BlockStatement", {
    enumerable: true,
    get: function () {
      return _index.blockStatement;
    }
  });
  Object.defineProperty(exports, "BreakStatement", {
    enumerable: true,
    get: function () {
      return _index.breakStatement;
    }
  });
  Object.defineProperty(exports, "CallExpression", {
    enumerable: true,
    get: function () {
      return _index.callExpression;
    }
  });
  Object.defineProperty(exports, "CatchClause", {
    enumerable: true,
    get: function () {
      return _index.catchClause;
    }
  });
  Object.defineProperty(exports, "ConditionalExpression", {
    enumerable: true,
    get: function () {
      return _index.conditionalExpression;
    }
  });
  Object.defineProperty(exports, "ContinueStatement", {
    enumerable: true,
    get: function () {
      return _index.continueStatement;
    }
  });
  Object.defineProperty(exports, "DebuggerStatement", {
    enumerable: true,
    get: function () {
      return _index.debuggerStatement;
    }
  });
  Object.defineProperty(exports, "DoWhileStatement", {
    enumerable: true,
    get: function () {
      return _index.doWhileStatement;
    }
  });
  Object.defineProperty(exports, "EmptyStatement", {
    enumerable: true,
    get: function () {
      return _index.emptyStatement;
    }
  });
  Object.defineProperty(exports, "ExpressionStatement", {
    enumerable: true,
    get: function () {
      return _index.expressionStatement;
    }
  });
  Object.defineProperty(exports, "File", {
    enumerable: true,
    get: function () {
      return _index.file;
    }
  });
  Object.defineProperty(exports, "ForInStatement", {
    enumerable: true,
    get: function () {
      return _index.forInStatement;
    }
  });
  Object.defineProperty(exports, "ForStatement", {
    enumerable: true,
    get: function () {
      return _index.forStatement;
    }
  });
  Object.defineProperty(exports, "FunctionDeclaration", {
    enumerable: true,
    get: function () {
      return _index.functionDeclaration;
    }
  });
  Object.defineProperty(exports, "FunctionExpression", {
    enumerable: true,
    get: function () {
      return _index.functionExpression;
    }
  });
  Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function () {
      return _index.identifier;
    }
  });
  Object.defineProperty(exports, "IfStatement", {
    enumerable: true,
    get: function () {
      return _index.ifStatement;
    }
  });
  Object.defineProperty(exports, "LabeledStatement", {
    enumerable: true,
    get: function () {
      return _index.labeledStatement;
    }
  });
  Object.defineProperty(exports, "StringLiteral", {
    enumerable: true,
    get: function () {
      return _index.stringLiteral;
    }
  });
  Object.defineProperty(exports, "NumericLiteral", {
    enumerable: true,
    get: function () {
      return _index.numericLiteral;
    }
  });
  Object.defineProperty(exports, "NullLiteral", {
    enumerable: true,
    get: function () {
      return _index.nullLiteral;
    }
  });
  Object.defineProperty(exports, "BooleanLiteral", {
    enumerable: true,
    get: function () {
      return _index.booleanLiteral;
    }
  });
  Object.defineProperty(exports, "RegExpLiteral", {
    enumerable: true,
    get: function () {
      return _index.regExpLiteral;
    }
  });
  Object.defineProperty(exports, "LogicalExpression", {
    enumerable: true,
    get: function () {
      return _index.logicalExpression;
    }
  });
  Object.defineProperty(exports, "MemberExpression", {
    enumerable: true,
    get: function () {
      return _index.memberExpression;
    }
  });
  Object.defineProperty(exports, "NewExpression", {
    enumerable: true,
    get: function () {
      return _index.newExpression;
    }
  });
  Object.defineProperty(exports, "Program", {
    enumerable: true,
    get: function () {
      return _index.program;
    }
  });
  Object.defineProperty(exports, "ObjectExpression", {
    enumerable: true,
    get: function () {
      return _index.objectExpression;
    }
  });
  Object.defineProperty(exports, "ObjectMethod", {
    enumerable: true,
    get: function () {
      return _index.objectMethod;
    }
  });
  Object.defineProperty(exports, "ObjectProperty", {
    enumerable: true,
    get: function () {
      return _index.objectProperty;
    }
  });
  Object.defineProperty(exports, "RestElement", {
    enumerable: true,
    get: function () {
      return _index.restElement;
    }
  });
  Object.defineProperty(exports, "ReturnStatement", {
    enumerable: true,
    get: function () {
      return _index.returnStatement;
    }
  });
  Object.defineProperty(exports, "SequenceExpression", {
    enumerable: true,
    get: function () {
      return _index.sequenceExpression;
    }
  });
  Object.defineProperty(exports, "ParenthesizedExpression", {
    enumerable: true,
    get: function () {
      return _index.parenthesizedExpression;
    }
  });
  Object.defineProperty(exports, "SwitchCase", {
    enumerable: true,
    get: function () {
      return _index.switchCase;
    }
  });
  Object.defineProperty(exports, "SwitchStatement", {
    enumerable: true,
    get: function () {
      return _index.switchStatement;
    }
  });
  Object.defineProperty(exports, "ThisExpression", {
    enumerable: true,
    get: function () {
      return _index.thisExpression;
    }
  });
  Object.defineProperty(exports, "ThrowStatement", {
    enumerable: true,
    get: function () {
      return _index.throwStatement;
    }
  });
  Object.defineProperty(exports, "TryStatement", {
    enumerable: true,
    get: function () {
      return _index.tryStatement;
    }
  });
  Object.defineProperty(exports, "UnaryExpression", {
    enumerable: true,
    get: function () {
      return _index.unaryExpression;
    }
  });
  Object.defineProperty(exports, "UpdateExpression", {
    enumerable: true,
    get: function () {
      return _index.updateExpression;
    }
  });
  Object.defineProperty(exports, "VariableDeclaration", {
    enumerable: true,
    get: function () {
      return _index.variableDeclaration;
    }
  });
  Object.defineProperty(exports, "VariableDeclarator", {
    enumerable: true,
    get: function () {
      return _index.variableDeclarator;
    }
  });
  Object.defineProperty(exports, "WhileStatement", {
    enumerable: true,
    get: function () {
      return _index.whileStatement;
    }
  });
  Object.defineProperty(exports, "WithStatement", {
    enumerable: true,
    get: function () {
      return _index.withStatement;
    }
  });
  Object.defineProperty(exports, "AssignmentPattern", {
    enumerable: true,
    get: function () {
      return _index.assignmentPattern;
    }
  });
  Object.defineProperty(exports, "ArrayPattern", {
    enumerable: true,
    get: function () {
      return _index.arrayPattern;
    }
  });
  Object.defineProperty(exports, "ArrowFunctionExpression", {
    enumerable: true,
    get: function () {
      return _index.arrowFunctionExpression;
    }
  });
  Object.defineProperty(exports, "ClassBody", {
    enumerable: true,
    get: function () {
      return _index.classBody;
    }
  });
  Object.defineProperty(exports, "ClassExpression", {
    enumerable: true,
    get: function () {
      return _index.classExpression;
    }
  });
  Object.defineProperty(exports, "ClassDeclaration", {
    enumerable: true,
    get: function () {
      return _index.classDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportAllDeclaration", {
    enumerable: true,
    get: function () {
      return _index.exportAllDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportDefaultDeclaration", {
    enumerable: true,
    get: function () {
      return _index.exportDefaultDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportNamedDeclaration", {
    enumerable: true,
    get: function () {
      return _index.exportNamedDeclaration;
    }
  });
  Object.defineProperty(exports, "ExportSpecifier", {
    enumerable: true,
    get: function () {
      return _index.exportSpecifier;
    }
  });
  Object.defineProperty(exports, "ForOfStatement", {
    enumerable: true,
    get: function () {
      return _index.forOfStatement;
    }
  });
  Object.defineProperty(exports, "ImportDeclaration", {
    enumerable: true,
    get: function () {
      return _index.importDeclaration;
    }
  });
  Object.defineProperty(exports, "ImportDefaultSpecifier", {
    enumerable: true,
    get: function () {
      return _index.importDefaultSpecifier;
    }
  });
  Object.defineProperty(exports, "ImportNamespaceSpecifier", {
    enumerable: true,
    get: function () {
      return _index.importNamespaceSpecifier;
    }
  });
  Object.defineProperty(exports, "ImportSpecifier", {
    enumerable: true,
    get: function () {
      return _index.importSpecifier;
    }
  });
  Object.defineProperty(exports, "MetaProperty", {
    enumerable: true,
    get: function () {
      return _index.metaProperty;
    }
  });
  Object.defineProperty(exports, "ClassMethod", {
    enumerable: true,
    get: function () {
      return _index.classMethod;
    }
  });
  Object.defineProperty(exports, "ObjectPattern", {
    enumerable: true,
    get: function () {
      return _index.objectPattern;
    }
  });
  Object.defineProperty(exports, "SpreadElement", {
    enumerable: true,
    get: function () {
      return _index.spreadElement;
    }
  });
  Object.defineProperty(exports, "Super", {
    enumerable: true,
    get: function () {
      return _index.super;
    }
  });
  Object.defineProperty(exports, "TaggedTemplateExpression", {
    enumerable: true,
    get: function () {
      return _index.taggedTemplateExpression;
    }
  });
  Object.defineProperty(exports, "TemplateElement", {
    enumerable: true,
    get: function () {
      return _index.templateElement;
    }
  });
  Object.defineProperty(exports, "TemplateLiteral", {
    enumerable: true,
    get: function () {
      return _index.templateLiteral;
    }
  });
  Object.defineProperty(exports, "YieldExpression", {
    enumerable: true,
    get: function () {
      return _index.yieldExpression;
    }
  });
  Object.defineProperty(exports, "AwaitExpression", {
    enumerable: true,
    get: function () {
      return _index.awaitExpression;
    }
  });
  Object.defineProperty(exports, "Import", {
    enumerable: true,
    get: function () {
      return _index.import;
    }
  });
  Object.defineProperty(exports, "BigIntLiteral", {
    enumerable: true,
    get: function () {
      return _index.bigIntLiteral;
    }
  });
  Object.defineProperty(exports, "ExportNamespaceSpecifier", {
    enumerable: true,
    get: function () {
      return _index.exportNamespaceSpecifier;
    }
  });
  Object.defineProperty(exports, "OptionalMemberExpression", {
    enumerable: true,
    get: function () {
      return _index.optionalMemberExpression;
    }
  });
  Object.defineProperty(exports, "OptionalCallExpression", {
    enumerable: true,
    get: function () {
      return _index.optionalCallExpression;
    }
  });
  Object.defineProperty(exports, "AnyTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.anyTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ArrayTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.arrayTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "BooleanTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.booleanTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.booleanLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.nullLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ClassImplements", {
    enumerable: true,
    get: function () {
      return _index.classImplements;
    }
  });
  Object.defineProperty(exports, "DeclareClass", {
    enumerable: true,
    get: function () {
      return _index.declareClass;
    }
  });
  Object.defineProperty(exports, "DeclareFunction", {
    enumerable: true,
    get: function () {
      return _index.declareFunction;
    }
  });
  Object.defineProperty(exports, "DeclareInterface", {
    enumerable: true,
    get: function () {
      return _index.declareInterface;
    }
  });
  Object.defineProperty(exports, "DeclareModule", {
    enumerable: true,
    get: function () {
      return _index.declareModule;
    }
  });
  Object.defineProperty(exports, "DeclareModuleExports", {
    enumerable: true,
    get: function () {
      return _index.declareModuleExports;
    }
  });
  Object.defineProperty(exports, "DeclareTypeAlias", {
    enumerable: true,
    get: function () {
      return _index.declareTypeAlias;
    }
  });
  Object.defineProperty(exports, "DeclareOpaqueType", {
    enumerable: true,
    get: function () {
      return _index.declareOpaqueType;
    }
  });
  Object.defineProperty(exports, "DeclareVariable", {
    enumerable: true,
    get: function () {
      return _index.declareVariable;
    }
  });
  Object.defineProperty(exports, "DeclareExportDeclaration", {
    enumerable: true,
    get: function () {
      return _index.declareExportDeclaration;
    }
  });
  Object.defineProperty(exports, "DeclareExportAllDeclaration", {
    enumerable: true,
    get: function () {
      return _index.declareExportAllDeclaration;
    }
  });
  Object.defineProperty(exports, "DeclaredPredicate", {
    enumerable: true,
    get: function () {
      return _index.declaredPredicate;
    }
  });
  Object.defineProperty(exports, "ExistsTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.existsTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "FunctionTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.functionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "FunctionTypeParam", {
    enumerable: true,
    get: function () {
      return _index.functionTypeParam;
    }
  });
  Object.defineProperty(exports, "GenericTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.genericTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "InferredPredicate", {
    enumerable: true,
    get: function () {
      return _index.inferredPredicate;
    }
  });
  Object.defineProperty(exports, "InterfaceExtends", {
    enumerable: true,
    get: function () {
      return _index.interfaceExtends;
    }
  });
  Object.defineProperty(exports, "InterfaceDeclaration", {
    enumerable: true,
    get: function () {
      return _index.interfaceDeclaration;
    }
  });
  Object.defineProperty(exports, "InterfaceTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.interfaceTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "IntersectionTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.intersectionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "MixedTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.mixedTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "EmptyTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.emptyTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NullableTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.nullableTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.numberLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "NumberTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.numberTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ObjectTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.objectTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ObjectTypeInternalSlot", {
    enumerable: true,
    get: function () {
      return _index.objectTypeInternalSlot;
    }
  });
  Object.defineProperty(exports, "ObjectTypeCallProperty", {
    enumerable: true,
    get: function () {
      return _index.objectTypeCallProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeIndexer", {
    enumerable: true,
    get: function () {
      return _index.objectTypeIndexer;
    }
  });
  Object.defineProperty(exports, "ObjectTypeProperty", {
    enumerable: true,
    get: function () {
      return _index.objectTypeProperty;
    }
  });
  Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
    enumerable: true,
    get: function () {
      return _index.objectTypeSpreadProperty;
    }
  });
  Object.defineProperty(exports, "OpaqueType", {
    enumerable: true,
    get: function () {
      return _index.opaqueType;
    }
  });
  Object.defineProperty(exports, "QualifiedTypeIdentifier", {
    enumerable: true,
    get: function () {
      return _index.qualifiedTypeIdentifier;
    }
  });
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.stringLiteralTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "StringTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.stringTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "SymbolTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.symbolTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "ThisTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.thisTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TupleTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.tupleTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TypeofTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.typeofTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TypeAlias", {
    enumerable: true,
    get: function () {
      return _index.typeAlias;
    }
  });
  Object.defineProperty(exports, "TypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.typeAnnotation;
    }
  });
  Object.defineProperty(exports, "TypeCastExpression", {
    enumerable: true,
    get: function () {
      return _index.typeCastExpression;
    }
  });
  Object.defineProperty(exports, "TypeParameter", {
    enumerable: true,
    get: function () {
      return _index.typeParameter;
    }
  });
  Object.defineProperty(exports, "TypeParameterDeclaration", {
    enumerable: true,
    get: function () {
      return _index.typeParameterDeclaration;
    }
  });
  Object.defineProperty(exports, "TypeParameterInstantiation", {
    enumerable: true,
    get: function () {
      return _index.typeParameterInstantiation;
    }
  });
  Object.defineProperty(exports, "UnionTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.unionTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "Variance", {
    enumerable: true,
    get: function () {
      return _index.variance;
    }
  });
  Object.defineProperty(exports, "VoidTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.voidTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "EnumDeclaration", {
    enumerable: true,
    get: function () {
      return _index.enumDeclaration;
    }
  });
  Object.defineProperty(exports, "EnumBooleanBody", {
    enumerable: true,
    get: function () {
      return _index.enumBooleanBody;
    }
  });
  Object.defineProperty(exports, "EnumNumberBody", {
    enumerable: true,
    get: function () {
      return _index.enumNumberBody;
    }
  });
  Object.defineProperty(exports, "EnumStringBody", {
    enumerable: true,
    get: function () {
      return _index.enumStringBody;
    }
  });
  Object.defineProperty(exports, "EnumSymbolBody", {
    enumerable: true,
    get: function () {
      return _index.enumSymbolBody;
    }
  });
  Object.defineProperty(exports, "EnumBooleanMember", {
    enumerable: true,
    get: function () {
      return _index.enumBooleanMember;
    }
  });
  Object.defineProperty(exports, "EnumNumberMember", {
    enumerable: true,
    get: function () {
      return _index.enumNumberMember;
    }
  });
  Object.defineProperty(exports, "EnumStringMember", {
    enumerable: true,
    get: function () {
      return _index.enumStringMember;
    }
  });
  Object.defineProperty(exports, "EnumDefaultedMember", {
    enumerable: true,
    get: function () {
      return _index.enumDefaultedMember;
    }
  });
  Object.defineProperty(exports, "IndexedAccessType", {
    enumerable: true,
    get: function () {
      return _index.indexedAccessType;
    }
  });
  Object.defineProperty(exports, "OptionalIndexedAccessType", {
    enumerable: true,
    get: function () {
      return _index.optionalIndexedAccessType;
    }
  });
  Object.defineProperty(exports, "JSXAttribute", {
    enumerable: true,
    get: function () {
      return _index.jsxAttribute;
    }
  });
  Object.defineProperty(exports, "JSXClosingElement", {
    enumerable: true,
    get: function () {
      return _index.jsxClosingElement;
    }
  });
  Object.defineProperty(exports, "JSXElement", {
    enumerable: true,
    get: function () {
      return _index.jsxElement;
    }
  });
  Object.defineProperty(exports, "JSXEmptyExpression", {
    enumerable: true,
    get: function () {
      return _index.jsxEmptyExpression;
    }
  });
  Object.defineProperty(exports, "JSXExpressionContainer", {
    enumerable: true,
    get: function () {
      return _index.jsxExpressionContainer;
    }
  });
  Object.defineProperty(exports, "JSXSpreadChild", {
    enumerable: true,
    get: function () {
      return _index.jsxSpreadChild;
    }
  });
  Object.defineProperty(exports, "JSXIdentifier", {
    enumerable: true,
    get: function () {
      return _index.jsxIdentifier;
    }
  });
  Object.defineProperty(exports, "JSXMemberExpression", {
    enumerable: true,
    get: function () {
      return _index.jsxMemberExpression;
    }
  });
  Object.defineProperty(exports, "JSXNamespacedName", {
    enumerable: true,
    get: function () {
      return _index.jsxNamespacedName;
    }
  });
  Object.defineProperty(exports, "JSXOpeningElement", {
    enumerable: true,
    get: function () {
      return _index.jsxOpeningElement;
    }
  });
  Object.defineProperty(exports, "JSXSpreadAttribute", {
    enumerable: true,
    get: function () {
      return _index.jsxSpreadAttribute;
    }
  });
  Object.defineProperty(exports, "JSXText", {
    enumerable: true,
    get: function () {
      return _index.jsxText;
    }
  });
  Object.defineProperty(exports, "JSXFragment", {
    enumerable: true,
    get: function () {
      return _index.jsxFragment;
    }
  });
  Object.defineProperty(exports, "JSXOpeningFragment", {
    enumerable: true,
    get: function () {
      return _index.jsxOpeningFragment;
    }
  });
  Object.defineProperty(exports, "JSXClosingFragment", {
    enumerable: true,
    get: function () {
      return _index.jsxClosingFragment;
    }
  });
  Object.defineProperty(exports, "Noop", {
    enumerable: true,
    get: function () {
      return _index.noop;
    }
  });
  Object.defineProperty(exports, "Placeholder", {
    enumerable: true,
    get: function () {
      return _index.placeholder;
    }
  });
  Object.defineProperty(exports, "V8IntrinsicIdentifier", {
    enumerable: true,
    get: function () {
      return _index.v8IntrinsicIdentifier;
    }
  });
  Object.defineProperty(exports, "ArgumentPlaceholder", {
    enumerable: true,
    get: function () {
      return _index.argumentPlaceholder;
    }
  });
  Object.defineProperty(exports, "BindExpression", {
    enumerable: true,
    get: function () {
      return _index.bindExpression;
    }
  });
  Object.defineProperty(exports, "ClassProperty", {
    enumerable: true,
    get: function () {
      return _index.classProperty;
    }
  });
  Object.defineProperty(exports, "PipelineTopicExpression", {
    enumerable: true,
    get: function () {
      return _index.pipelineTopicExpression;
    }
  });
  Object.defineProperty(exports, "PipelineBareFunction", {
    enumerable: true,
    get: function () {
      return _index.pipelineBareFunction;
    }
  });
  Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
    enumerable: true,
    get: function () {
      return _index.pipelinePrimaryTopicReference;
    }
  });
  Object.defineProperty(exports, "ClassPrivateProperty", {
    enumerable: true,
    get: function () {
      return _index.classPrivateProperty;
    }
  });
  Object.defineProperty(exports, "ClassPrivateMethod", {
    enumerable: true,
    get: function () {
      return _index.classPrivateMethod;
    }
  });
  Object.defineProperty(exports, "ImportAttribute", {
    enumerable: true,
    get: function () {
      return _index.importAttribute;
    }
  });
  Object.defineProperty(exports, "Decorator", {
    enumerable: true,
    get: function () {
      return _index.decorator;
    }
  });
  Object.defineProperty(exports, "DoExpression", {
    enumerable: true,
    get: function () {
      return _index.doExpression;
    }
  });
  Object.defineProperty(exports, "ExportDefaultSpecifier", {
    enumerable: true,
    get: function () {
      return _index.exportDefaultSpecifier;
    }
  });
  Object.defineProperty(exports, "PrivateName", {
    enumerable: true,
    get: function () {
      return _index.privateName;
    }
  });
  Object.defineProperty(exports, "RecordExpression", {
    enumerable: true,
    get: function () {
      return _index.recordExpression;
    }
  });
  Object.defineProperty(exports, "TupleExpression", {
    enumerable: true,
    get: function () {
      return _index.tupleExpression;
    }
  });
  Object.defineProperty(exports, "DecimalLiteral", {
    enumerable: true,
    get: function () {
      return _index.decimalLiteral;
    }
  });
  Object.defineProperty(exports, "StaticBlock", {
    enumerable: true,
    get: function () {
      return _index.staticBlock;
    }
  });
  Object.defineProperty(exports, "ModuleExpression", {
    enumerable: true,
    get: function () {
      return _index.moduleExpression;
    }
  });
  Object.defineProperty(exports, "TSParameterProperty", {
    enumerable: true,
    get: function () {
      return _index.tsParameterProperty;
    }
  });
  Object.defineProperty(exports, "TSDeclareFunction", {
    enumerable: true,
    get: function () {
      return _index.tsDeclareFunction;
    }
  });
  Object.defineProperty(exports, "TSDeclareMethod", {
    enumerable: true,
    get: function () {
      return _index.tsDeclareMethod;
    }
  });
  Object.defineProperty(exports, "TSQualifiedName", {
    enumerable: true,
    get: function () {
      return _index.tsQualifiedName;
    }
  });
  Object.defineProperty(exports, "TSCallSignatureDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsCallSignatureDeclaration;
    }
  });
  Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsConstructSignatureDeclaration;
    }
  });
  Object.defineProperty(exports, "TSPropertySignature", {
    enumerable: true,
    get: function () {
      return _index.tsPropertySignature;
    }
  });
  Object.defineProperty(exports, "TSMethodSignature", {
    enumerable: true,
    get: function () {
      return _index.tsMethodSignature;
    }
  });
  Object.defineProperty(exports, "TSIndexSignature", {
    enumerable: true,
    get: function () {
      return _index.tsIndexSignature;
    }
  });
  Object.defineProperty(exports, "TSAnyKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsAnyKeyword;
    }
  });
  Object.defineProperty(exports, "TSBooleanKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsBooleanKeyword;
    }
  });
  Object.defineProperty(exports, "TSBigIntKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsBigIntKeyword;
    }
  });
  Object.defineProperty(exports, "TSIntrinsicKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsIntrinsicKeyword;
    }
  });
  Object.defineProperty(exports, "TSNeverKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsNeverKeyword;
    }
  });
  Object.defineProperty(exports, "TSNullKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsNullKeyword;
    }
  });
  Object.defineProperty(exports, "TSNumberKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsNumberKeyword;
    }
  });
  Object.defineProperty(exports, "TSObjectKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsObjectKeyword;
    }
  });
  Object.defineProperty(exports, "TSStringKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsStringKeyword;
    }
  });
  Object.defineProperty(exports, "TSSymbolKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsSymbolKeyword;
    }
  });
  Object.defineProperty(exports, "TSUndefinedKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsUndefinedKeyword;
    }
  });
  Object.defineProperty(exports, "TSUnknownKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsUnknownKeyword;
    }
  });
  Object.defineProperty(exports, "TSVoidKeyword", {
    enumerable: true,
    get: function () {
      return _index.tsVoidKeyword;
    }
  });
  Object.defineProperty(exports, "TSThisType", {
    enumerable: true,
    get: function () {
      return _index.tsThisType;
    }
  });
  Object.defineProperty(exports, "TSFunctionType", {
    enumerable: true,
    get: function () {
      return _index.tsFunctionType;
    }
  });
  Object.defineProperty(exports, "TSConstructorType", {
    enumerable: true,
    get: function () {
      return _index.tsConstructorType;
    }
  });
  Object.defineProperty(exports, "TSTypeReference", {
    enumerable: true,
    get: function () {
      return _index.tsTypeReference;
    }
  });
  Object.defineProperty(exports, "TSTypePredicate", {
    enumerable: true,
    get: function () {
      return _index.tsTypePredicate;
    }
  });
  Object.defineProperty(exports, "TSTypeQuery", {
    enumerable: true,
    get: function () {
      return _index.tsTypeQuery;
    }
  });
  Object.defineProperty(exports, "TSTypeLiteral", {
    enumerable: true,
    get: function () {
      return _index.tsTypeLiteral;
    }
  });
  Object.defineProperty(exports, "TSArrayType", {
    enumerable: true,
    get: function () {
      return _index.tsArrayType;
    }
  });
  Object.defineProperty(exports, "TSTupleType", {
    enumerable: true,
    get: function () {
      return _index.tsTupleType;
    }
  });
  Object.defineProperty(exports, "TSOptionalType", {
    enumerable: true,
    get: function () {
      return _index.tsOptionalType;
    }
  });
  Object.defineProperty(exports, "TSRestType", {
    enumerable: true,
    get: function () {
      return _index.tsRestType;
    }
  });
  Object.defineProperty(exports, "TSNamedTupleMember", {
    enumerable: true,
    get: function () {
      return _index.tsNamedTupleMember;
    }
  });
  Object.defineProperty(exports, "TSUnionType", {
    enumerable: true,
    get: function () {
      return _index.tsUnionType;
    }
  });
  Object.defineProperty(exports, "TSIntersectionType", {
    enumerable: true,
    get: function () {
      return _index.tsIntersectionType;
    }
  });
  Object.defineProperty(exports, "TSConditionalType", {
    enumerable: true,
    get: function () {
      return _index.tsConditionalType;
    }
  });
  Object.defineProperty(exports, "TSInferType", {
    enumerable: true,
    get: function () {
      return _index.tsInferType;
    }
  });
  Object.defineProperty(exports, "TSParenthesizedType", {
    enumerable: true,
    get: function () {
      return _index.tsParenthesizedType;
    }
  });
  Object.defineProperty(exports, "TSTypeOperator", {
    enumerable: true,
    get: function () {
      return _index.tsTypeOperator;
    }
  });
  Object.defineProperty(exports, "TSIndexedAccessType", {
    enumerable: true,
    get: function () {
      return _index.tsIndexedAccessType;
    }
  });
  Object.defineProperty(exports, "TSMappedType", {
    enumerable: true,
    get: function () {
      return _index.tsMappedType;
    }
  });
  Object.defineProperty(exports, "TSLiteralType", {
    enumerable: true,
    get: function () {
      return _index.tsLiteralType;
    }
  });
  Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
    enumerable: true,
    get: function () {
      return _index.tsExpressionWithTypeArguments;
    }
  });
  Object.defineProperty(exports, "TSInterfaceDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsInterfaceDeclaration;
    }
  });
  Object.defineProperty(exports, "TSInterfaceBody", {
    enumerable: true,
    get: function () {
      return _index.tsInterfaceBody;
    }
  });
  Object.defineProperty(exports, "TSTypeAliasDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsTypeAliasDeclaration;
    }
  });
  Object.defineProperty(exports, "TSAsExpression", {
    enumerable: true,
    get: function () {
      return _index.tsAsExpression;
    }
  });
  Object.defineProperty(exports, "TSTypeAssertion", {
    enumerable: true,
    get: function () {
      return _index.tsTypeAssertion;
    }
  });
  Object.defineProperty(exports, "TSEnumDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsEnumDeclaration;
    }
  });
  Object.defineProperty(exports, "TSEnumMember", {
    enumerable: true,
    get: function () {
      return _index.tsEnumMember;
    }
  });
  Object.defineProperty(exports, "TSModuleDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsModuleDeclaration;
    }
  });
  Object.defineProperty(exports, "TSModuleBlock", {
    enumerable: true,
    get: function () {
      return _index.tsModuleBlock;
    }
  });
  Object.defineProperty(exports, "TSImportType", {
    enumerable: true,
    get: function () {
      return _index.tsImportType;
    }
  });
  Object.defineProperty(exports, "TSImportEqualsDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsImportEqualsDeclaration;
    }
  });
  Object.defineProperty(exports, "TSExternalModuleReference", {
    enumerable: true,
    get: function () {
      return _index.tsExternalModuleReference;
    }
  });
  Object.defineProperty(exports, "TSNonNullExpression", {
    enumerable: true,
    get: function () {
      return _index.tsNonNullExpression;
    }
  });
  Object.defineProperty(exports, "TSExportAssignment", {
    enumerable: true,
    get: function () {
      return _index.tsExportAssignment;
    }
  });
  Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsNamespaceExportDeclaration;
    }
  });
  Object.defineProperty(exports, "TSTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _index.tsTypeAnnotation;
    }
  });
  Object.defineProperty(exports, "TSTypeParameterInstantiation", {
    enumerable: true,
    get: function () {
      return _index.tsTypeParameterInstantiation;
    }
  });
  Object.defineProperty(exports, "TSTypeParameterDeclaration", {
    enumerable: true,
    get: function () {
      return _index.tsTypeParameterDeclaration;
    }
  });
  Object.defineProperty(exports, "TSTypeParameter", {
    enumerable: true,
    get: function () {
      return _index.tsTypeParameter;
    }
  });
  Object.defineProperty(exports, "NumberLiteral", {
    enumerable: true,
    get: function () {
      return _index.numberLiteral;
    }
  });
  Object.defineProperty(exports, "RegexLiteral", {
    enumerable: true,
    get: function () {
      return _index.regexLiteral;
    }
  });
  Object.defineProperty(exports, "RestProperty", {
    enumerable: true,
    get: function () {
      return _index.restProperty;
    }
  });
  Object.defineProperty(exports, "SpreadProperty", {
    enumerable: true,
    get: function () {
      return _index.spreadProperty;
    }
  });

  var _index = generated$3;
  }(uppercase));

  var cloneNode$1 = {};

  Object.defineProperty(cloneNode$1, "__esModule", {
    value: true
  });
  cloneNode$1.default = cloneNode;

  var _definitions$4 = definitions;

  var _generated$g = generated$4;

  const has$2 = Function.call.bind(Object.prototype.hasOwnProperty);

  function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === "string") {
      return cloneNode(obj, deep, withoutLoc);
    }

    return obj;
  }

  function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) {
      return obj.map(node => cloneIfNode(node, deep, withoutLoc));
    }

    return cloneIfNode(obj, deep, withoutLoc);
  }

  function cloneNode(node, deep = true, withoutLoc = false) {
    if (!node) return node;
    const {
      type
    } = node;
    const newNode = {
      type: node.type
    };

    if ((0, _generated$g.isIdentifier)(node)) {
      newNode.name = node.name;

      if (has$2(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }

      if (has$2(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
      }
    } else if (!has$2(_definitions$4.NODE_FIELDS, type)) {
      throw new Error(`Unknown node type: "${type}"`);
    } else {
      for (const field of Object.keys(_definitions$4.NODE_FIELDS[type])) {
        if (has$2(node, field)) {
          if (deep) {
            newNode[field] = (0, _generated$g.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }

    if (has$2(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }

    if (has$2(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
    }

    if (has$2(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
    }

    if (has$2(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
    }

    if (has$2(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }

    return newNode;
  }

  function maybeCloneComments(comments, deep, withoutLoc) {
    if (!comments || !deep) {
      return comments;
    }

    return comments.map(({
      type,
      value,
      loc
    }) => {
      if (withoutLoc) {
        return {
          type,
          value,
          loc: null
        };
      }

      return {
        type,
        value,
        loc
      };
    });
  }

  var clone$1 = {};

  Object.defineProperty(clone$1, "__esModule", {
    value: true
  });
  clone$1.default = clone;

  var _cloneNode$5 = cloneNode$1;

  function clone(node) {
    return (0, _cloneNode$5.default)(node, false);
  }

  var cloneDeep$1 = {};

  Object.defineProperty(cloneDeep$1, "__esModule", {
    value: true
  });
  cloneDeep$1.default = cloneDeep;

  var _cloneNode$4 = cloneNode$1;

  function cloneDeep(node) {
    return (0, _cloneNode$4.default)(node);
  }

  var cloneDeepWithoutLoc$1 = {};

  Object.defineProperty(cloneDeepWithoutLoc$1, "__esModule", {
    value: true
  });
  cloneDeepWithoutLoc$1.default = cloneDeepWithoutLoc;

  var _cloneNode$3 = cloneNode$1;

  function cloneDeepWithoutLoc(node) {
    return (0, _cloneNode$3.default)(node, true, true);
  }

  var cloneWithoutLoc$1 = {};

  Object.defineProperty(cloneWithoutLoc$1, "__esModule", {
    value: true
  });
  cloneWithoutLoc$1.default = cloneWithoutLoc;

  var _cloneNode$2 = cloneNode$1;

  function cloneWithoutLoc(node) {
    return (0, _cloneNode$2.default)(node, false, true);
  }

  var addComment$2 = {};

  var addComments$2 = {};

  Object.defineProperty(addComments$2, "__esModule", {
    value: true
  });
  addComments$2.default = addComments$1;

  function addComments$1(node, type, comments) {
    if (!comments || !node) return node;
    const key = `${type}Comments`;

    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        node[key] = node[key].concat(comments);
      }
    } else {
      node[key] = comments;
    }

    return node;
  }

  Object.defineProperty(addComment$2, "__esModule", {
    value: true
  });
  addComment$2.default = addComment$1;

  var _addComments = addComments$2;

  function addComment$1(node, type, content, line) {
    return (0, _addComments.default)(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }

  var inheritInnerComments$1 = {};

  var inherit$1 = {};

  Object.defineProperty(inherit$1, "__esModule", {
    value: true
  });
  inherit$1.default = inherit;

  function inherit(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }

  Object.defineProperty(inheritInnerComments$1, "__esModule", {
    value: true
  });
  inheritInnerComments$1.default = inheritInnerComments;

  var _inherit$2 = inherit$1;

  function inheritInnerComments(child, parent) {
    (0, _inherit$2.default)("innerComments", child, parent);
  }

  var inheritLeadingComments$1 = {};

  Object.defineProperty(inheritLeadingComments$1, "__esModule", {
    value: true
  });
  inheritLeadingComments$1.default = inheritLeadingComments;

  var _inherit$1 = inherit$1;

  function inheritLeadingComments(child, parent) {
    (0, _inherit$1.default)("leadingComments", child, parent);
  }

  var inheritsComments$1 = {};

  var inheritTrailingComments$1 = {};

  Object.defineProperty(inheritTrailingComments$1, "__esModule", {
    value: true
  });
  inheritTrailingComments$1.default = inheritTrailingComments;

  var _inherit = inherit$1;

  function inheritTrailingComments(child, parent) {
    (0, _inherit.default)("trailingComments", child, parent);
  }

  Object.defineProperty(inheritsComments$1, "__esModule", {
    value: true
  });
  inheritsComments$1.default = inheritsComments;

  var _inheritTrailingComments = inheritTrailingComments$1;

  var _inheritLeadingComments = inheritLeadingComments$1;

  var _inheritInnerComments = inheritInnerComments$1;

  function inheritsComments(child, parent) {
    (0, _inheritTrailingComments.default)(child, parent);
    (0, _inheritLeadingComments.default)(child, parent);
    (0, _inheritInnerComments.default)(child, parent);
    return child;
  }

  var removeComments$1 = {};

  Object.defineProperty(removeComments$1, "__esModule", {
    value: true
  });
  removeComments$1.default = removeComments;

  var _constants$4 = constants;

  function removeComments(node) {
    _constants$4.COMMENT_KEYS.forEach(key => {
      node[key] = null;
    });

    return node;
  }

  var generated$1 = {};

  Object.defineProperty(generated$1, "__esModule", {
    value: true
  });
  generated$1.TSBASETYPE_TYPES = generated$1.TSTYPE_TYPES = generated$1.TSTYPEELEMENT_TYPES = generated$1.PRIVATE_TYPES = generated$1.JSX_TYPES = generated$1.ENUMMEMBER_TYPES = generated$1.ENUMBODY_TYPES = generated$1.FLOWPREDICATE_TYPES = generated$1.FLOWDECLARATION_TYPES = generated$1.FLOWBASEANNOTATION_TYPES = generated$1.FLOWTYPE_TYPES = generated$1.FLOW_TYPES = generated$1.MODULESPECIFIER_TYPES = generated$1.EXPORTDECLARATION_TYPES = generated$1.MODULEDECLARATION_TYPES = generated$1.CLASS_TYPES = generated$1.PATTERN_TYPES = generated$1.UNARYLIKE_TYPES = generated$1.PROPERTY_TYPES = generated$1.OBJECTMEMBER_TYPES = generated$1.METHOD_TYPES = generated$1.USERWHITESPACABLE_TYPES = generated$1.IMMUTABLE_TYPES = generated$1.LITERAL_TYPES = generated$1.TSENTITYNAME_TYPES = generated$1.LVAL_TYPES = generated$1.PATTERNLIKE_TYPES = generated$1.DECLARATION_TYPES = generated$1.PUREISH_TYPES = generated$1.FUNCTIONPARENT_TYPES = generated$1.FUNCTION_TYPES = generated$1.FORXSTATEMENT_TYPES = generated$1.FOR_TYPES = generated$1.EXPRESSIONWRAPPER_TYPES = generated$1.WHILE_TYPES = generated$1.LOOP_TYPES = generated$1.CONDITIONAL_TYPES = generated$1.COMPLETIONSTATEMENT_TYPES = generated$1.TERMINATORLESS_TYPES = generated$1.STATEMENT_TYPES = generated$1.BLOCK_TYPES = generated$1.BLOCKPARENT_TYPES = generated$1.SCOPABLE_TYPES = generated$1.BINARY_TYPES = generated$1.EXPRESSION_TYPES = void 0;

  var _definitions$3 = definitions;

  const EXPRESSION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Expression"];
  generated$1.EXPRESSION_TYPES = EXPRESSION_TYPES;
  const BINARY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Binary"];
  generated$1.BINARY_TYPES = BINARY_TYPES;
  const SCOPABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Scopable"];
  generated$1.SCOPABLE_TYPES = SCOPABLE_TYPES;
  const BLOCKPARENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["BlockParent"];
  generated$1.BLOCKPARENT_TYPES = BLOCKPARENT_TYPES;
  const BLOCK_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Block"];
  generated$1.BLOCK_TYPES = BLOCK_TYPES;
  const STATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Statement"];
  generated$1.STATEMENT_TYPES = STATEMENT_TYPES;
  const TERMINATORLESS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Terminatorless"];
  generated$1.TERMINATORLESS_TYPES = TERMINATORLESS_TYPES;
  const COMPLETIONSTATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  generated$1.COMPLETIONSTATEMENT_TYPES = COMPLETIONSTATEMENT_TYPES;
  const CONDITIONAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Conditional"];
  generated$1.CONDITIONAL_TYPES = CONDITIONAL_TYPES;
  const LOOP_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Loop"];
  generated$1.LOOP_TYPES = LOOP_TYPES;
  const WHILE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["While"];
  generated$1.WHILE_TYPES = WHILE_TYPES;
  const EXPRESSIONWRAPPER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  generated$1.EXPRESSIONWRAPPER_TYPES = EXPRESSIONWRAPPER_TYPES;
  const FOR_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["For"];
  generated$1.FOR_TYPES = FOR_TYPES;
  const FORXSTATEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ForXStatement"];
  generated$1.FORXSTATEMENT_TYPES = FORXSTATEMENT_TYPES;
  const FUNCTION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Function"];
  generated$1.FUNCTION_TYPES = FUNCTION_TYPES;
  const FUNCTIONPARENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["FunctionParent"];
  generated$1.FUNCTIONPARENT_TYPES = FUNCTIONPARENT_TYPES;
  const PUREISH_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Pureish"];
  generated$1.PUREISH_TYPES = PUREISH_TYPES;
  const DECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Declaration"];
  generated$1.DECLARATION_TYPES = DECLARATION_TYPES;
  const PATTERNLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["PatternLike"];
  generated$1.PATTERNLIKE_TYPES = PATTERNLIKE_TYPES;
  const LVAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["LVal"];
  generated$1.LVAL_TYPES = LVAL_TYPES;
  const TSENTITYNAME_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSEntityName"];
  generated$1.TSENTITYNAME_TYPES = TSENTITYNAME_TYPES;
  const LITERAL_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Literal"];
  generated$1.LITERAL_TYPES = LITERAL_TYPES;
  const IMMUTABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Immutable"];
  generated$1.IMMUTABLE_TYPES = IMMUTABLE_TYPES;
  const USERWHITESPACABLE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  generated$1.USERWHITESPACABLE_TYPES = USERWHITESPACABLE_TYPES;
  const METHOD_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Method"];
  generated$1.METHOD_TYPES = METHOD_TYPES;
  const OBJECTMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ObjectMember"];
  generated$1.OBJECTMEMBER_TYPES = OBJECTMEMBER_TYPES;
  const PROPERTY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Property"];
  generated$1.PROPERTY_TYPES = PROPERTY_TYPES;
  const UNARYLIKE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["UnaryLike"];
  generated$1.UNARYLIKE_TYPES = UNARYLIKE_TYPES;
  const PATTERN_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Pattern"];
  generated$1.PATTERN_TYPES = PATTERN_TYPES;
  const CLASS_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Class"];
  generated$1.CLASS_TYPES = CLASS_TYPES;
  const MODULEDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
  generated$1.MODULEDECLARATION_TYPES = MODULEDECLARATION_TYPES;
  const EXPORTDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  generated$1.EXPORTDECLARATION_TYPES = EXPORTDECLARATION_TYPES;
  const MODULESPECIFIER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  generated$1.MODULESPECIFIER_TYPES = MODULESPECIFIER_TYPES;
  const FLOW_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Flow"];
  generated$1.FLOW_TYPES = FLOW_TYPES;
  const FLOWTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["FlowType"];
  generated$1.FLOWTYPE_TYPES = FLOWTYPE_TYPES;
  const FLOWBASEANNOTATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  generated$1.FLOWBASEANNOTATION_TYPES = FLOWBASEANNOTATION_TYPES;
  const FLOWDECLARATION_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  generated$1.FLOWDECLARATION_TYPES = FLOWDECLARATION_TYPES;
  const FLOWPREDICATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  generated$1.FLOWPREDICATE_TYPES = FLOWPREDICATE_TYPES;
  const ENUMBODY_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["EnumBody"];
  generated$1.ENUMBODY_TYPES = ENUMBODY_TYPES;
  const ENUMMEMBER_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["EnumMember"];
  generated$1.ENUMMEMBER_TYPES = ENUMMEMBER_TYPES;
  const JSX_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["JSX"];
  generated$1.JSX_TYPES = JSX_TYPES;
  const PRIVATE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["Private"];
  generated$1.PRIVATE_TYPES = PRIVATE_TYPES;
  const TSTYPEELEMENT_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  generated$1.TSTYPEELEMENT_TYPES = TSTYPEELEMENT_TYPES;
  const TSTYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSType"];
  generated$1.TSTYPE_TYPES = TSTYPE_TYPES;
  const TSBASETYPE_TYPES = _definitions$3.FLIPPED_ALIAS_KEYS["TSBaseType"];
  generated$1.TSBASETYPE_TYPES = TSBASETYPE_TYPES;

  var ensureBlock$2 = {};

  var toBlock$1 = {};

  Object.defineProperty(toBlock$1, "__esModule", {
    value: true
  });
  toBlock$1.default = toBlock;

  var _generated$f = generated$4;

  var _generated2$3 = generated$3;

  function toBlock(node, parent) {
    if ((0, _generated$f.isBlockStatement)(node)) {
      return node;
    }

    let blockNodes = [];

    if ((0, _generated$f.isEmptyStatement)(node)) {
      blockNodes = [];
    } else {
      if (!(0, _generated$f.isStatement)(node)) {
        if ((0, _generated$f.isFunction)(parent)) {
          node = (0, _generated2$3.returnStatement)(node);
        } else {
          node = (0, _generated2$3.expressionStatement)(node);
        }
      }

      blockNodes = [node];
    }

    return (0, _generated2$3.blockStatement)(blockNodes);
  }

  Object.defineProperty(ensureBlock$2, "__esModule", {
    value: true
  });
  ensureBlock$2.default = ensureBlock$1;

  var _toBlock = toBlock$1;

  function ensureBlock$1(node, key = "body") {
    return node[key] = (0, _toBlock.default)(node[key], node);
  }

  var toBindingIdentifierName$1 = {};

  var toIdentifier$1 = {};

  Object.defineProperty(toIdentifier$1, "__esModule", {
    value: true
  });
  toIdentifier$1.default = toIdentifier;

  var _isValidIdentifier$2 = isValidIdentifier$1;

  var _helperValidatorIdentifier$1 = lib$8;

  function toIdentifier(input) {
    input = input + "";
    let name = "";

    for (const c of input) {
      name += (0, _helperValidatorIdentifier$1.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
    }

    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });

    if (!(0, _isValidIdentifier$2.default)(name)) {
      name = `_${name}`;
    }

    return name || "_";
  }

  Object.defineProperty(toBindingIdentifierName$1, "__esModule", {
    value: true
  });
  toBindingIdentifierName$1.default = toBindingIdentifierName;

  var _toIdentifier = toIdentifier$1;

  function toBindingIdentifierName(name) {
    name = (0, _toIdentifier.default)(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }

  var toComputedKey$2 = {};

  Object.defineProperty(toComputedKey$2, "__esModule", {
    value: true
  });
  toComputedKey$2.default = toComputedKey$1;

  var _generated$e = generated$4;

  var _generated2$2 = generated$3;

  function toComputedKey$1(node, key = node.key || node.property) {
    if (!node.computed && (0, _generated$e.isIdentifier)(key)) key = (0, _generated2$2.stringLiteral)(key.name);
    return key;
  }

  var toExpression$1 = {};

  Object.defineProperty(toExpression$1, "__esModule", {
    value: true
  });
  toExpression$1.default = void 0;

  var _generated$d = generated$4;

  var _default$b = toExpression;
  toExpression$1.default = _default$b;

  function toExpression(node) {
    if ((0, _generated$d.isExpressionStatement)(node)) {
      node = node.expression;
    }

    if ((0, _generated$d.isExpression)(node)) {
      return node;
    }

    if ((0, _generated$d.isClass)(node)) {
      node.type = "ClassExpression";
    } else if ((0, _generated$d.isFunction)(node)) {
      node.type = "FunctionExpression";
    }

    if (!(0, _generated$d.isExpression)(node)) {
      throw new Error(`cannot turn ${node.type} to an expression`);
    }

    return node;
  }

  var toKeyAlias$1 = {};

  var removePropertiesDeep$1 = {};

  var traverseFast$1 = {};

  Object.defineProperty(traverseFast$1, "__esModule", {
    value: true
  });
  traverseFast$1.default = traverseFast;

  var _definitions$2 = definitions;

  function traverseFast(node, enter, opts) {
    if (!node) return;
    const keys = _definitions$2.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);

    for (const key of keys) {
      const subNode = node[key];

      if (Array.isArray(subNode)) {
        for (const node of subNode) {
          traverseFast(node, enter, opts);
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  }

  var removeProperties$1 = {};

  Object.defineProperty(removeProperties$1, "__esModule", {
    value: true
  });
  removeProperties$1.default = removeProperties;

  var _constants$3 = constants;

  const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];

  const CLEAR_KEYS_PLUS_COMMENTS = _constants$3.COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);

  function removeProperties(node, opts = {}) {
    const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

    for (const key of map) {
      if (node[key] != null) node[key] = undefined;
    }

    for (const key of Object.keys(node)) {
      if (key[0] === "_" && node[key] != null) node[key] = undefined;
    }

    const symbols = Object.getOwnPropertySymbols(node);

    for (const sym of symbols) {
      node[sym] = null;
    }
  }

  Object.defineProperty(removePropertiesDeep$1, "__esModule", {
    value: true
  });
  removePropertiesDeep$1.default = removePropertiesDeep;

  var _traverseFast = traverseFast$1;

  var _removeProperties = removeProperties$1;

  function removePropertiesDeep(tree, opts) {
    (0, _traverseFast.default)(tree, _removeProperties.default, opts);
    return tree;
  }

  Object.defineProperty(toKeyAlias$1, "__esModule", {
    value: true
  });
  toKeyAlias$1.default = toKeyAlias;

  var _generated$c = generated$4;

  var _cloneNode$1 = cloneNode$1;

  var _removePropertiesDeep = removePropertiesDeep$1;

  function toKeyAlias(node, key = node.key) {
    let alias;

    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if ((0, _generated$c.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _generated$c.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode$1.default)(key)));
    }

    if (node.computed) {
      alias = `[${alias}]`;
    }

    if (node.static) {
      alias = `static:${alias}`;
    }

    return alias;
  }

  toKeyAlias.uid = 0;

  toKeyAlias.increment = function () {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };

  var toSequenceExpression$1 = {};

  var gatherSequenceExpressions$1 = {};

  var getBindingIdentifiers$2 = {};

  Object.defineProperty(getBindingIdentifiers$2, "__esModule", {
    value: true
  });
  getBindingIdentifiers$2.default = getBindingIdentifiers$1;

  var _generated$b = generated$4;

  function getBindingIdentifiers$1(node, duplicates, outerOnly) {
    let search = [].concat(node);
    const ids = Object.create(null);

    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      const keys = getBindingIdentifiers$1.keys[id.type];

      if ((0, _generated$b.isIdentifier)(id)) {
        if (duplicates) {
          const _ids = ids[id.name] = ids[id.name] || [];

          _ids.push(id);
        } else {
          ids[id.name] = id;
        }

        continue;
      }

      if ((0, _generated$b.isExportDeclaration)(id) && !(0, _generated$b.isExportAllDeclaration)(id)) {
        if ((0, _generated$b.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }

        continue;
      }

      if (outerOnly) {
        if ((0, _generated$b.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }

        if ((0, _generated$b.isFunctionExpression)(id)) {
          continue;
        }
      }

      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];

          if (id[key]) {
            search = search.concat(id[key]);
          }
        }
      }
    }

    return ids;
  }

  getBindingIdentifiers$1.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };

  Object.defineProperty(gatherSequenceExpressions$1, "__esModule", {
    value: true
  });
  gatherSequenceExpressions$1.default = gatherSequenceExpressions;

  var _getBindingIdentifiers$2 = getBindingIdentifiers$2;

  var _generated$a = generated$4;

  var _generated2$1 = generated$3;

  var _cloneNode = cloneNode$1;

  function gatherSequenceExpressions(nodes, scope, declars) {
    const exprs = [];
    let ensureLastUndefined = true;

    for (const node of nodes) {
      if (!(0, _generated$a.isEmptyStatement)(node)) {
        ensureLastUndefined = false;
      }

      if ((0, _generated$a.isExpression)(node)) {
        exprs.push(node);
      } else if ((0, _generated$a.isExpressionStatement)(node)) {
        exprs.push(node.expression);
      } else if ((0, _generated$a.isVariableDeclaration)(node)) {
        if (node.kind !== "var") return;

        for (const declar of node.declarations) {
          const bindings = (0, _getBindingIdentifiers$2.default)(declar);

          for (const key of Object.keys(bindings)) {
            declars.push({
              kind: node.kind,
              id: (0, _cloneNode.default)(bindings[key])
            });
          }

          if (declar.init) {
            exprs.push((0, _generated2$1.assignmentExpression)("=", declar.id, declar.init));
          }
        }

        ensureLastUndefined = true;
      } else if ((0, _generated$a.isIfStatement)(node)) {
        const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
        const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push((0, _generated2$1.conditionalExpression)(node.test, consequent, alternate));
      } else if ((0, _generated$a.isBlockStatement)(node)) {
        const body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if ((0, _generated$a.isEmptyStatement)(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }

    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }

    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _generated2$1.sequenceExpression)(exprs);
    }
  }

  Object.defineProperty(toSequenceExpression$1, "__esModule", {
    value: true
  });
  toSequenceExpression$1.default = toSequenceExpression;

  var _gatherSequenceExpressions = gatherSequenceExpressions$1;

  function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    const declars = [];
    const result = (0, _gatherSequenceExpressions.default)(nodes, scope, declars);
    if (!result) return;

    for (const declar of declars) {
      scope.push(declar);
    }

    return result;
  }

  var toStatement$1 = {};

  Object.defineProperty(toStatement$1, "__esModule", {
    value: true
  });
  toStatement$1.default = void 0;

  var _generated$9 = generated$4;

  var _generated2 = generated$3;

  var _default$a = toStatement;
  toStatement$1.default = _default$a;

  function toStatement(node, ignore) {
    if ((0, _generated$9.isStatement)(node)) {
      return node;
    }

    let mustHaveId = false;
    let newType;

    if ((0, _generated$9.isClass)(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _generated$9.isFunction)(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _generated$9.isAssignmentExpression)(node)) {
      return (0, _generated2.expressionStatement)(node);
    }

    if (mustHaveId && !node.id) {
      newType = false;
    }

    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error(`cannot turn ${node.type} to a statement`);
      }
    }

    node.type = newType;
    return node;
  }

  var valueToNode$1 = {};

  Object.defineProperty(valueToNode$1, "__esModule", {
    value: true
  });
  valueToNode$1.default = void 0;

  var _isValidIdentifier$1 = isValidIdentifier$1;

  var _generated$8 = generated$3;

  var _default$9 = valueToNode;
  valueToNode$1.default = _default$9;
  const objectToString$1 = Function.call.bind(Object.prototype.toString);

  function isRegExp$1(value) {
    return objectToString$1(value) === "[object RegExp]";
  }

  function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }

    const proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }

  function valueToNode(value) {
    if (value === undefined) {
      return (0, _generated$8.identifier)("undefined");
    }

    if (value === true || value === false) {
      return (0, _generated$8.booleanLiteral)(value);
    }

    if (value === null) {
      return (0, _generated$8.nullLiteral)();
    }

    if (typeof value === "string") {
      return (0, _generated$8.stringLiteral)(value);
    }

    if (typeof value === "number") {
      let result;

      if (Number.isFinite(value)) {
        result = (0, _generated$8.numericLiteral)(Math.abs(value));
      } else {
        let numerator;

        if (Number.isNaN(value)) {
          numerator = (0, _generated$8.numericLiteral)(0);
        } else {
          numerator = (0, _generated$8.numericLiteral)(1);
        }

        result = (0, _generated$8.binaryExpression)("/", numerator, (0, _generated$8.numericLiteral)(0));
      }

      if (value < 0 || Object.is(value, -0)) {
        result = (0, _generated$8.unaryExpression)("-", result);
      }

      return result;
    }

    if (isRegExp$1(value)) {
      const pattern = value.source;
      const flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return (0, _generated$8.regExpLiteral)(pattern, flags);
    }

    if (Array.isArray(value)) {
      return (0, _generated$8.arrayExpression)(value.map(valueToNode));
    }

    if (isPlainObject(value)) {
      const props = [];

      for (const key of Object.keys(value)) {
        let nodeKey;

        if ((0, _isValidIdentifier$1.default)(key)) {
          nodeKey = (0, _generated$8.identifier)(key);
        } else {
          nodeKey = (0, _generated$8.stringLiteral)(key);
        }

        props.push((0, _generated$8.objectProperty)(nodeKey, valueToNode(value[key])));
      }

      return (0, _generated$8.objectExpression)(props);
    }

    throw new Error("don't know how to turn this value into a node");
  }

  var appendToMemberExpression$1 = {};

  Object.defineProperty(appendToMemberExpression$1, "__esModule", {
    value: true
  });
  appendToMemberExpression$1.default = appendToMemberExpression;

  var _generated$7 = generated$3;

  function appendToMemberExpression(member, append, computed = false) {
    member.object = (0, _generated$7.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }

  var inherits$3 = {};

  Object.defineProperty(inherits$3, "__esModule", {
    value: true
  });
  inherits$3.default = inherits$2;

  var _constants$2 = constants;

  var _inheritsComments = inheritsComments$1;

  function inherits$2(child, parent) {
    if (!child || !parent) return child;

    for (const key of _constants$2.INHERIT_KEYS.optional) {
      if (child[key] == null) {
        child[key] = parent[key];
      }
    }

    for (const key of Object.keys(parent)) {
      if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
    }

    for (const key of _constants$2.INHERIT_KEYS.force) {
      child[key] = parent[key];
    }

    (0, _inheritsComments.default)(child, parent);
    return child;
  }

  var prependToMemberExpression$1 = {};

  Object.defineProperty(prependToMemberExpression$1, "__esModule", {
    value: true
  });
  prependToMemberExpression$1.default = prependToMemberExpression;

  var _generated$6 = generated$3;

  function prependToMemberExpression(member, prepend) {
    member.object = (0, _generated$6.memberExpression)(prepend, member.object);
    return member;
  }

  var getOuterBindingIdentifiers$2 = {};

  Object.defineProperty(getOuterBindingIdentifiers$2, "__esModule", {
    value: true
  });
  getOuterBindingIdentifiers$2.default = void 0;

  var _getBindingIdentifiers$1 = getBindingIdentifiers$2;

  var _default$8 = getOuterBindingIdentifiers$1;
  getOuterBindingIdentifiers$2.default = _default$8;

  function getOuterBindingIdentifiers$1(node, duplicates) {
    return (0, _getBindingIdentifiers$1.default)(node, duplicates, true);
  }

  var traverse$2 = {};

  Object.defineProperty(traverse$2, "__esModule", {
    value: true
  });
  traverse$2.default = traverse$1;

  var _definitions$1 = definitions;

  function traverse$1(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }

    const {
      enter,
      exit
    } = handlers;
    traverseSimpleImpl(node, enter, exit, state, []);
  }

  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    const keys = _definitions$1.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);

    for (const key of keys) {
      const subNode = node[key];

      if (Array.isArray(subNode)) {
        for (let i = 0; i < subNode.length; i++) {
          const child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node,
            key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node,
          key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }

    if (exit) exit(node, ancestors, state);
  }

  var isBinding$1 = {};

  Object.defineProperty(isBinding$1, "__esModule", {
    value: true
  });
  isBinding$1.default = isBinding;

  var _getBindingIdentifiers = getBindingIdentifiers$2;

  function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }

    const keys = _getBindingIdentifiers.default.keys[parent.type];

    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const val = parent[key];

        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0) return true;
        } else {
          if (val === node) return true;
        }
      }
    }

    return false;
  }

  var isBlockScoped$1 = {};

  var isLet$1 = {};

  Object.defineProperty(isLet$1, "__esModule", {
    value: true
  });
  isLet$1.default = isLet;

  var _generated$5 = generated$4;

  var _constants$1 = constants;

  function isLet(node) {
    return (0, _generated$5.isVariableDeclaration)(node) && (node.kind !== "var" || node[_constants$1.BLOCK_SCOPED_SYMBOL]);
  }

  Object.defineProperty(isBlockScoped$1, "__esModule", {
    value: true
  });
  isBlockScoped$1.default = isBlockScoped;

  var _generated$4 = generated$4;

  var _isLet = isLet$1;

  function isBlockScoped(node) {
    return (0, _generated$4.isFunctionDeclaration)(node) || (0, _generated$4.isClassDeclaration)(node) || (0, _isLet.default)(node);
  }

  var isImmutable$1 = {};

  Object.defineProperty(isImmutable$1, "__esModule", {
    value: true
  });
  isImmutable$1.default = isImmutable;

  var _isType = isType$2;

  var _generated$3 = generated$4;

  function isImmutable(node) {
    if ((0, _isType.default)(node.type, "Immutable")) return true;

    if ((0, _generated$3.isIdentifier)(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }

    return false;
  }

  var isNodesEquivalent$1 = {};

  Object.defineProperty(isNodesEquivalent$1, "__esModule", {
    value: true
  });
  isNodesEquivalent$1.default = isNodesEquivalent;

  var _definitions = definitions;

  function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }

    if (a.type !== b.type) {
      return false;
    }

    const fields = Object.keys(_definitions.NODE_FIELDS[a.type] || a.type);
    const visitorKeys = _definitions.VISITOR_KEYS[a.type];

    for (const field of fields) {
      if (typeof a[field] !== typeof b[field]) {
        return false;
      }

      if (a[field] == null && b[field] == null) {
        continue;
      } else if (a[field] == null || b[field] == null) {
        return false;
      }

      if (Array.isArray(a[field])) {
        if (!Array.isArray(b[field])) {
          return false;
        }

        if (a[field].length !== b[field].length) {
          return false;
        }

        for (let i = 0; i < a[field].length; i++) {
          if (!isNodesEquivalent(a[field][i], b[field][i])) {
            return false;
          }
        }

        continue;
      }

      if (typeof a[field] === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (const key of Object.keys(a[field])) {
          if (a[field][key] !== b[field][key]) {
            return false;
          }
        }

        continue;
      }

      if (!isNodesEquivalent(a[field], b[field])) {
        return false;
      }
    }

    return true;
  }

  var isReferenced$1 = {};

  Object.defineProperty(isReferenced$1, "__esModule", {
    value: true
  });
  isReferenced$1.default = isReferenced;

  function isReferenced(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "JSXMemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }

        return parent.object === node;

      case "VariableDeclarator":
        return parent.init === node;

      case "ArrowFunctionExpression":
        return parent.body === node;

      case "PrivateName":
        return false;

      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.params.includes(node)) {
          return false;
        }

      case "ObjectProperty":
      case "ClassProperty":
      case "ClassPrivateProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }

        if (parent.value === node) {
          return !grandparent || grandparent.type !== "ObjectPattern";
        }

        return true;

      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;

      case "AssignmentExpression":
        return parent.right === node;

      case "AssignmentPattern":
        return parent.right === node;

      case "LabeledStatement":
        return false;

      case "CatchClause":
        return false;

      case "RestElement":
        return false;

      case "BreakStatement":
      case "ContinueStatement":
        return false;

      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;

      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;

      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }

        return parent.local === node;

      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;

      case "JSXAttribute":
        return false;

      case "ObjectPattern":
      case "ArrayPattern":
        return false;

      case "MetaProperty":
        return false;

      case "ObjectTypeProperty":
        return parent.key !== node;

      case "TSEnumMember":
        return parent.id !== node;

      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }

        return true;
    }

    return true;
  }

  var isScope$1 = {};

  Object.defineProperty(isScope$1, "__esModule", {
    value: true
  });
  isScope$1.default = isScope;

  var _generated$2 = generated$4;

  function isScope(node, parent) {
    if ((0, _generated$2.isBlockStatement)(node) && ((0, _generated$2.isFunction)(parent) || (0, _generated$2.isCatchClause)(parent))) {
      return false;
    }

    if ((0, _generated$2.isPattern)(node) && ((0, _generated$2.isFunction)(parent) || (0, _generated$2.isCatchClause)(parent))) {
      return true;
    }

    return (0, _generated$2.isScopable)(node);
  }

  var isSpecifierDefault$1 = {};

  Object.defineProperty(isSpecifierDefault$1, "__esModule", {
    value: true
  });
  isSpecifierDefault$1.default = isSpecifierDefault;

  var _generated$1 = generated$4;

  function isSpecifierDefault(specifier) {
    return (0, _generated$1.isImportDefaultSpecifier)(specifier) || (0, _generated$1.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  }

  var isValidES3Identifier$1 = {};

  Object.defineProperty(isValidES3Identifier$1, "__esModule", {
    value: true
  });
  isValidES3Identifier$1.default = isValidES3Identifier;

  var _isValidIdentifier = isValidIdentifier$1;

  const RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);

  function isValidES3Identifier(name) {
    return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }

  var isVar$1 = {};

  Object.defineProperty(isVar$1, "__esModule", {
    value: true
  });
  isVar$1.default = isVar;

  var _generated = generated$4;

  var _constants = constants;

  function isVar(node) {
    return (0, _generated.isVariableDeclaration)(node, {
      kind: "var"
    }) && !node[_constants.BLOCK_SCOPED_SYMBOL];
  }

  var generated = /*#__PURE__*/Object.freeze({
    __proto__: null
  });

  var require$$65 = /*@__PURE__*/getAugmentedNamespace(generated);

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    react: true,
    assertNode: true,
    createTypeAnnotationBasedOnTypeof: true,
    createUnionTypeAnnotation: true,
    createFlowUnionType: true,
    createTSUnionType: true,
    cloneNode: true,
    clone: true,
    cloneDeep: true,
    cloneDeepWithoutLoc: true,
    cloneWithoutLoc: true,
    addComment: true,
    addComments: true,
    inheritInnerComments: true,
    inheritLeadingComments: true,
    inheritsComments: true,
    inheritTrailingComments: true,
    removeComments: true,
    ensureBlock: true,
    toBindingIdentifierName: true,
    toBlock: true,
    toComputedKey: true,
    toExpression: true,
    toIdentifier: true,
    toKeyAlias: true,
    toSequenceExpression: true,
    toStatement: true,
    valueToNode: true,
    appendToMemberExpression: true,
    inherits: true,
    prependToMemberExpression: true,
    removeProperties: true,
    removePropertiesDeep: true,
    removeTypeDuplicates: true,
    getBindingIdentifiers: true,
    getOuterBindingIdentifiers: true,
    traverse: true,
    traverseFast: true,
    shallowEqual: true,
    is: true,
    isBinding: true,
    isBlockScoped: true,
    isImmutable: true,
    isLet: true,
    isNode: true,
    isNodesEquivalent: true,
    isPlaceholderType: true,
    isReferenced: true,
    isScope: true,
    isSpecifierDefault: true,
    isType: true,
    isValidES3Identifier: true,
    isValidIdentifier: true,
    isVar: true,
    matchesPattern: true,
    validate: true,
    buildMatchMemberExpression: true
  };
  Object.defineProperty(exports, "assertNode", {
    enumerable: true,
    get: function () {
      return _assertNode.default;
    }
  });
  Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
    enumerable: true,
    get: function () {
      return _createTypeAnnotationBasedOnTypeof.default;
    }
  });
  Object.defineProperty(exports, "createUnionTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "createFlowUnionType", {
    enumerable: true,
    get: function () {
      return _createFlowUnionType.default;
    }
  });
  Object.defineProperty(exports, "createTSUnionType", {
    enumerable: true,
    get: function () {
      return _createTSUnionType.default;
    }
  });
  Object.defineProperty(exports, "cloneNode", {
    enumerable: true,
    get: function () {
      return _cloneNode.default;
    }
  });
  Object.defineProperty(exports, "clone", {
    enumerable: true,
    get: function () {
      return _clone.default;
    }
  });
  Object.defineProperty(exports, "cloneDeep", {
    enumerable: true,
    get: function () {
      return _cloneDeep.default;
    }
  });
  Object.defineProperty(exports, "cloneDeepWithoutLoc", {
    enumerable: true,
    get: function () {
      return _cloneDeepWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "cloneWithoutLoc", {
    enumerable: true,
    get: function () {
      return _cloneWithoutLoc.default;
    }
  });
  Object.defineProperty(exports, "addComment", {
    enumerable: true,
    get: function () {
      return _addComment.default;
    }
  });
  Object.defineProperty(exports, "addComments", {
    enumerable: true,
    get: function () {
      return _addComments.default;
    }
  });
  Object.defineProperty(exports, "inheritInnerComments", {
    enumerable: true,
    get: function () {
      return _inheritInnerComments.default;
    }
  });
  Object.defineProperty(exports, "inheritLeadingComments", {
    enumerable: true,
    get: function () {
      return _inheritLeadingComments.default;
    }
  });
  Object.defineProperty(exports, "inheritsComments", {
    enumerable: true,
    get: function () {
      return _inheritsComments.default;
    }
  });
  Object.defineProperty(exports, "inheritTrailingComments", {
    enumerable: true,
    get: function () {
      return _inheritTrailingComments.default;
    }
  });
  Object.defineProperty(exports, "removeComments", {
    enumerable: true,
    get: function () {
      return _removeComments.default;
    }
  });
  Object.defineProperty(exports, "ensureBlock", {
    enumerable: true,
    get: function () {
      return _ensureBlock.default;
    }
  });
  Object.defineProperty(exports, "toBindingIdentifierName", {
    enumerable: true,
    get: function () {
      return _toBindingIdentifierName.default;
    }
  });
  Object.defineProperty(exports, "toBlock", {
    enumerable: true,
    get: function () {
      return _toBlock.default;
    }
  });
  Object.defineProperty(exports, "toComputedKey", {
    enumerable: true,
    get: function () {
      return _toComputedKey.default;
    }
  });
  Object.defineProperty(exports, "toExpression", {
    enumerable: true,
    get: function () {
      return _toExpression.default;
    }
  });
  Object.defineProperty(exports, "toIdentifier", {
    enumerable: true,
    get: function () {
      return _toIdentifier.default;
    }
  });
  Object.defineProperty(exports, "toKeyAlias", {
    enumerable: true,
    get: function () {
      return _toKeyAlias.default;
    }
  });
  Object.defineProperty(exports, "toSequenceExpression", {
    enumerable: true,
    get: function () {
      return _toSequenceExpression.default;
    }
  });
  Object.defineProperty(exports, "toStatement", {
    enumerable: true,
    get: function () {
      return _toStatement.default;
    }
  });
  Object.defineProperty(exports, "valueToNode", {
    enumerable: true,
    get: function () {
      return _valueToNode.default;
    }
  });
  Object.defineProperty(exports, "appendToMemberExpression", {
    enumerable: true,
    get: function () {
      return _appendToMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "inherits", {
    enumerable: true,
    get: function () {
      return _inherits.default;
    }
  });
  Object.defineProperty(exports, "prependToMemberExpression", {
    enumerable: true,
    get: function () {
      return _prependToMemberExpression.default;
    }
  });
  Object.defineProperty(exports, "removeProperties", {
    enumerable: true,
    get: function () {
      return _removeProperties.default;
    }
  });
  Object.defineProperty(exports, "removePropertiesDeep", {
    enumerable: true,
    get: function () {
      return _removePropertiesDeep.default;
    }
  });
  Object.defineProperty(exports, "removeTypeDuplicates", {
    enumerable: true,
    get: function () {
      return _removeTypeDuplicates.default;
    }
  });
  Object.defineProperty(exports, "getBindingIdentifiers", {
    enumerable: true,
    get: function () {
      return _getBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "getOuterBindingIdentifiers", {
    enumerable: true,
    get: function () {
      return _getOuterBindingIdentifiers.default;
    }
  });
  Object.defineProperty(exports, "traverse", {
    enumerable: true,
    get: function () {
      return _traverse.default;
    }
  });
  Object.defineProperty(exports, "traverseFast", {
    enumerable: true,
    get: function () {
      return _traverseFast.default;
    }
  });
  Object.defineProperty(exports, "shallowEqual", {
    enumerable: true,
    get: function () {
      return _shallowEqual.default;
    }
  });
  Object.defineProperty(exports, "is", {
    enumerable: true,
    get: function () {
      return _is.default;
    }
  });
  Object.defineProperty(exports, "isBinding", {
    enumerable: true,
    get: function () {
      return _isBinding.default;
    }
  });
  Object.defineProperty(exports, "isBlockScoped", {
    enumerable: true,
    get: function () {
      return _isBlockScoped.default;
    }
  });
  Object.defineProperty(exports, "isImmutable", {
    enumerable: true,
    get: function () {
      return _isImmutable.default;
    }
  });
  Object.defineProperty(exports, "isLet", {
    enumerable: true,
    get: function () {
      return _isLet.default;
    }
  });
  Object.defineProperty(exports, "isNode", {
    enumerable: true,
    get: function () {
      return _isNode.default;
    }
  });
  Object.defineProperty(exports, "isNodesEquivalent", {
    enumerable: true,
    get: function () {
      return _isNodesEquivalent.default;
    }
  });
  Object.defineProperty(exports, "isPlaceholderType", {
    enumerable: true,
    get: function () {
      return _isPlaceholderType.default;
    }
  });
  Object.defineProperty(exports, "isReferenced", {
    enumerable: true,
    get: function () {
      return _isReferenced.default;
    }
  });
  Object.defineProperty(exports, "isScope", {
    enumerable: true,
    get: function () {
      return _isScope.default;
    }
  });
  Object.defineProperty(exports, "isSpecifierDefault", {
    enumerable: true,
    get: function () {
      return _isSpecifierDefault.default;
    }
  });
  Object.defineProperty(exports, "isType", {
    enumerable: true,
    get: function () {
      return _isType.default;
    }
  });
  Object.defineProperty(exports, "isValidES3Identifier", {
    enumerable: true,
    get: function () {
      return _isValidES3Identifier.default;
    }
  });
  Object.defineProperty(exports, "isValidIdentifier", {
    enumerable: true,
    get: function () {
      return _isValidIdentifier.default;
    }
  });
  Object.defineProperty(exports, "isVar", {
    enumerable: true,
    get: function () {
      return _isVar.default;
    }
  });
  Object.defineProperty(exports, "matchesPattern", {
    enumerable: true,
    get: function () {
      return _matchesPattern.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function () {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "buildMatchMemberExpression", {
    enumerable: true,
    get: function () {
      return _buildMatchMemberExpression.default;
    }
  });
  exports.react = void 0;

  var _isReactComponent = isReactComponent$1;

  var _isCompatTag = isCompatTag$1;

  var _buildChildren = buildChildren$1;

  var _assertNode = assertNode$1;

  var _generated = generated$2;

  Object.keys(_generated).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated[key];
      }
    });
  });

  var _createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof$1;

  var _createFlowUnionType = createFlowUnionType$1;

  var _createTSUnionType = createTSUnionType$1;

  var _generated2 = generated$3;

  Object.keys(_generated2).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated2[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated2[key];
      }
    });
  });

  var _uppercase = uppercase;

  Object.keys(_uppercase).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _uppercase[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _uppercase[key];
      }
    });
  });

  var _cloneNode = cloneNode$1;

  var _clone = clone$1;

  var _cloneDeep = cloneDeep$1;

  var _cloneDeepWithoutLoc = cloneDeepWithoutLoc$1;

  var _cloneWithoutLoc = cloneWithoutLoc$1;

  var _addComment = addComment$2;

  var _addComments = addComments$2;

  var _inheritInnerComments = inheritInnerComments$1;

  var _inheritLeadingComments = inheritLeadingComments$1;

  var _inheritsComments = inheritsComments$1;

  var _inheritTrailingComments = inheritTrailingComments$1;

  var _removeComments = removeComments$1;

  var _generated3 = generated$1;

  Object.keys(_generated3).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated3[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated3[key];
      }
    });
  });

  var _constants = constants;

  Object.keys(_constants).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _constants[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _constants[key];
      }
    });
  });

  var _ensureBlock = ensureBlock$2;

  var _toBindingIdentifierName = toBindingIdentifierName$1;

  var _toBlock = toBlock$1;

  var _toComputedKey = toComputedKey$2;

  var _toExpression = toExpression$1;

  var _toIdentifier = toIdentifier$1;

  var _toKeyAlias = toKeyAlias$1;

  var _toSequenceExpression = toSequenceExpression$1;

  var _toStatement = toStatement$1;

  var _valueToNode = valueToNode$1;

  var _definitions = definitions;

  Object.keys(_definitions).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _definitions[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _definitions[key];
      }
    });
  });

  var _appendToMemberExpression = appendToMemberExpression$1;

  var _inherits = inherits$3;

  var _prependToMemberExpression = prependToMemberExpression$1;

  var _removeProperties = removeProperties$1;

  var _removePropertiesDeep = removePropertiesDeep$1;

  var _removeTypeDuplicates = removeTypeDuplicates$3;

  var _getBindingIdentifiers = getBindingIdentifiers$2;

  var _getOuterBindingIdentifiers = getOuterBindingIdentifiers$2;

  var _traverse = traverse$2;

  Object.keys(_traverse).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _traverse[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _traverse[key];
      }
    });
  });

  var _traverseFast = traverseFast$1;

  var _shallowEqual = shallowEqual$1;

  var _is = is$2;

  var _isBinding = isBinding$1;

  var _isBlockScoped = isBlockScoped$1;

  var _isImmutable = isImmutable$1;

  var _isLet = isLet$1;

  var _isNode = isNode$1;

  var _isNodesEquivalent = isNodesEquivalent$1;

  var _isPlaceholderType = isPlaceholderType$1;

  var _isReferenced = isReferenced$1;

  var _isScope = isScope$1;

  var _isSpecifierDefault = isSpecifierDefault$1;

  var _isType = isType$2;

  var _isValidES3Identifier = isValidES3Identifier$1;

  var _isValidIdentifier = isValidIdentifier$1;

  var _isVar = isVar$1;

  var _matchesPattern = matchesPattern$2;

  var _validate = validate$3;

  var _buildMatchMemberExpression = buildMatchMemberExpression$1;

  var _generated4 = generated$4;

  Object.keys(_generated4).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated4[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated4[key];
      }
    });
  });

  var _generated5 = require$$65;

  Object.keys(_generated5).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _generated5[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _generated5[key];
      }
    });
  });
  const react = {
    isReactComponent: _isReactComponent.default,
    isCompatTag: _isCompatTag.default,
    buildChildren: _buildChildren.default
  };
  exports.react = react;
  }(lib$9));

  Object.defineProperty(virtualTypes$2, "__esModule", {
    value: true
  });
  virtualTypes$2.ForAwaitStatement = virtualTypes$2.NumericLiteralTypeAnnotation = virtualTypes$2.ExistentialTypeParam = virtualTypes$2.SpreadProperty = virtualTypes$2.RestProperty = virtualTypes$2.Flow = virtualTypes$2.Pure = virtualTypes$2.Generated = virtualTypes$2.User = virtualTypes$2.Var = virtualTypes$2.BlockScoped = virtualTypes$2.Referenced = virtualTypes$2.Scope = virtualTypes$2.Expression = virtualTypes$2.Statement = virtualTypes$2.BindingIdentifier = virtualTypes$2.ReferencedMemberExpression = virtualTypes$2.ReferencedIdentifier = void 0;

  var t$w = lib$9;

  const ReferencedIdentifier = {
    types: ["Identifier", "JSXIdentifier"],

    checkPath(path, opts) {
      const {
        node,
        parent
      } = path;

      if (!t$w.isIdentifier(node, opts) && !t$w.isJSXMemberExpression(parent, opts)) {
        if (t$w.isJSXIdentifier(node, opts)) {
          if (t$w.react.isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }

      return t$w.isReferenced(node, parent, path.parentPath.parent);
    }

  };
  virtualTypes$2.ReferencedIdentifier = ReferencedIdentifier;
  const ReferencedMemberExpression = {
    types: ["MemberExpression"],

    checkPath({
      node,
      parent
    }) {
      return t$w.isMemberExpression(node) && t$w.isReferenced(node, parent);
    }

  };
  virtualTypes$2.ReferencedMemberExpression = ReferencedMemberExpression;
  const BindingIdentifier = {
    types: ["Identifier"],

    checkPath(path) {
      const {
        node,
        parent
      } = path;
      const grandparent = path.parentPath.parent;
      return t$w.isIdentifier(node) && t$w.isBinding(node, parent, grandparent);
    }

  };
  virtualTypes$2.BindingIdentifier = BindingIdentifier;
  const Statement = {
    types: ["Statement"],

    checkPath({
      node,
      parent
    }) {
      if (t$w.isStatement(node)) {
        if (t$w.isVariableDeclaration(node)) {
          if (t$w.isForXStatement(parent, {
            left: node
          })) return false;
          if (t$w.isForStatement(parent, {
            init: node
          })) return false;
        }

        return true;
      } else {
        return false;
      }
    }

  };
  virtualTypes$2.Statement = Statement;
  const Expression = {
    types: ["Expression"],

    checkPath(path) {
      if (path.isIdentifier()) {
        return path.isReferencedIdentifier();
      } else {
        return t$w.isExpression(path.node);
      }
    }

  };
  virtualTypes$2.Expression = Expression;
  const Scope$1 = {
    types: ["Scopable", "Pattern"],

    checkPath(path) {
      return t$w.isScope(path.node, path.parent);
    }

  };
  virtualTypes$2.Scope = Scope$1;
  const Referenced = {
    checkPath(path) {
      return t$w.isReferenced(path.node, path.parent);
    }

  };
  virtualTypes$2.Referenced = Referenced;
  const BlockScoped = {
    checkPath(path) {
      return t$w.isBlockScoped(path.node);
    }

  };
  virtualTypes$2.BlockScoped = BlockScoped;
  const Var = {
    types: ["VariableDeclaration"],

    checkPath(path) {
      return t$w.isVar(path.node);
    }

  };
  virtualTypes$2.Var = Var;
  const User = {
    checkPath(path) {
      return path.node && !!path.node.loc;
    }

  };
  virtualTypes$2.User = User;
  const Generated = {
    checkPath(path) {
      return !path.isUser();
    }

  };
  virtualTypes$2.Generated = Generated;
  const Pure = {
    checkPath(path, opts) {
      return path.scope.isPure(path.node, opts);
    }

  };
  virtualTypes$2.Pure = Pure;
  const Flow = {
    types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],

    checkPath({
      node
    }) {
      if (t$w.isFlow(node)) {
        return true;
      } else if (t$w.isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (t$w.isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (t$w.isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }

  };
  virtualTypes$2.Flow = Flow;
  const RestProperty = {
    types: ["RestElement"],

    checkPath(path) {
      return path.parentPath && path.parentPath.isObjectPattern();
    }

  };
  virtualTypes$2.RestProperty = RestProperty;
  const SpreadProperty = {
    types: ["RestElement"],

    checkPath(path) {
      return path.parentPath && path.parentPath.isObjectExpression();
    }

  };
  virtualTypes$2.SpreadProperty = SpreadProperty;
  const ExistentialTypeParam = {
    types: ["ExistsTypeAnnotation"]
  };
  virtualTypes$2.ExistentialTypeParam = ExistentialTypeParam;
  const NumericLiteralTypeAnnotation = {
    types: ["NumberLiteralTypeAnnotation"]
  };
  virtualTypes$2.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
  const ForAwaitStatement = {
    types: ["ForOfStatement"],

    checkPath({
      node
    }) {
      return node.await === true;
    }

  };
  virtualTypes$2.ForAwaitStatement = ForAwaitStatement;

  var src = {exports: {}};

  var browser = {exports: {}};

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup$1(env) {
  	createDebug.debug = createDebug;
  	createDebug.default = createDebug;
  	createDebug.coerce = coerce;
  	createDebug.disable = disable;
  	createDebug.enable = enable;
  	createDebug.enabled = enabled;
  	createDebug.humanize = require$$0__default$1['default'];
  	createDebug.destroy = destroy;

  	Object.keys(env).forEach(key => {
  		createDebug[key] = env[key];
  	});

  	/**
  	* The currently active debug mode names, and names to skip.
  	*/

  	createDebug.names = [];
  	createDebug.skips = [];

  	/**
  	* Map of special "%n" handling functions, for the debug "format" argument.
  	*
  	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  	*/
  	createDebug.formatters = {};

  	/**
  	* Selects a color for a debug namespace
  	* @param {String} namespace The namespace string for the for the debug instance to be colored
  	* @return {Number|String} An ANSI color code for the given namespace
  	* @api private
  	*/
  	function selectColor(namespace) {
  		let hash = 0;

  		for (let i = 0; i < namespace.length; i++) {
  			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
  			hash |= 0; // Convert to 32bit integer
  		}

  		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  	}
  	createDebug.selectColor = selectColor;

  	/**
  	* Create a debugger with the given `namespace`.
  	*
  	* @param {String} namespace
  	* @return {Function}
  	* @api public
  	*/
  	function createDebug(namespace) {
  		let prevTime;
  		let enableOverride = null;
  		let namespacesCache;
  		let enabledCache;

  		function debug(...args) {
  			// Disabled?
  			if (!debug.enabled) {
  				return;
  			}

  			const self = debug;

  			// Set `diff` timestamp
  			const curr = Number(new Date());
  			const ms = curr - (prevTime || curr);
  			self.diff = ms;
  			self.prev = prevTime;
  			self.curr = curr;
  			prevTime = curr;

  			args[0] = createDebug.coerce(args[0]);

  			if (typeof args[0] !== 'string') {
  				// Anything else let's inspect with %O
  				args.unshift('%O');
  			}

  			// Apply any `formatters` transformations
  			let index = 0;
  			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
  				// If we encounter an escaped % then don't increase the array index
  				if (match === '%%') {
  					return '%';
  				}
  				index++;
  				const formatter = createDebug.formatters[format];
  				if (typeof formatter === 'function') {
  					const val = args[index];
  					match = formatter.call(self, val);

  					// Now we need to remove `args[index]` since it's inlined in the `format`
  					args.splice(index, 1);
  					index--;
  				}
  				return match;
  			});

  			// Apply env-specific formatting (colors, etc.)
  			createDebug.formatArgs.call(self, args);

  			const logFn = self.log || createDebug.log;
  			logFn.apply(self, args);
  		}

  		debug.namespace = namespace;
  		debug.useColors = createDebug.useColors();
  		debug.color = createDebug.selectColor(namespace);
  		debug.extend = extend;
  		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

  		Object.defineProperty(debug, 'enabled', {
  			enumerable: true,
  			configurable: false,
  			get: () => {
  				if (enableOverride !== null) {
  					return enableOverride;
  				}
  				if (namespacesCache !== createDebug.namespaces) {
  					namespacesCache = createDebug.namespaces;
  					enabledCache = createDebug.enabled(namespace);
  				}

  				return enabledCache;
  			},
  			set: v => {
  				enableOverride = v;
  			}
  		});

  		// Env-specific initialization logic for debug instances
  		if (typeof createDebug.init === 'function') {
  			createDebug.init(debug);
  		}

  		return debug;
  	}

  	function extend(namespace, delimiter) {
  		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  		newDebug.log = this.log;
  		return newDebug;
  	}

  	/**
  	* Enables a debug mode by namespaces. This can include modes
  	* separated by a colon and wildcards.
  	*
  	* @param {String} namespaces
  	* @api public
  	*/
  	function enable(namespaces) {
  		createDebug.save(namespaces);
  		createDebug.namespaces = namespaces;

  		createDebug.names = [];
  		createDebug.skips = [];

  		let i;
  		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  		const len = split.length;

  		for (i = 0; i < len; i++) {
  			if (!split[i]) {
  				// ignore empty strings
  				continue;
  			}

  			namespaces = split[i].replace(/\*/g, '.*?');

  			if (namespaces[0] === '-') {
  				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
  			} else {
  				createDebug.names.push(new RegExp('^' + namespaces + '$'));
  			}
  		}
  	}

  	/**
  	* Disable debug output.
  	*
  	* @return {String} namespaces
  	* @api public
  	*/
  	function disable() {
  		const namespaces = [
  			...createDebug.names.map(toNamespace),
  			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
  		].join(',');
  		createDebug.enable('');
  		return namespaces;
  	}

  	/**
  	* Returns true if the given mode name is enabled, false otherwise.
  	*
  	* @param {String} name
  	* @return {Boolean}
  	* @api public
  	*/
  	function enabled(name) {
  		if (name[name.length - 1] === '*') {
  			return true;
  		}

  		let i;
  		let len;

  		for (i = 0, len = createDebug.skips.length; i < len; i++) {
  			if (createDebug.skips[i].test(name)) {
  				return false;
  			}
  		}

  		for (i = 0, len = createDebug.names.length; i < len; i++) {
  			if (createDebug.names[i].test(name)) {
  				return true;
  			}
  		}

  		return false;
  	}

  	/**
  	* Convert regexp to namespace
  	*
  	* @param {RegExp} regxep
  	* @return {String} namespace
  	* @api private
  	*/
  	function toNamespace(regexp) {
  		return regexp.toString()
  			.substring(2, regexp.toString().length - 2)
  			.replace(/\.\*\?$/, '*');
  	}

  	/**
  	* Coerce `val`.
  	*
  	* @param {Mixed} val
  	* @return {Mixed}
  	* @api private
  	*/
  	function coerce(val) {
  		if (val instanceof Error) {
  			return val.stack || val.message;
  		}
  		return val;
  	}

  	/**
  	* XXX DO NOT USE. This is a temporary stub function.
  	* XXX It WILL be removed in the next major release.
  	*/
  	function destroy() {
  		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  	}

  	createDebug.enable(createDebug.load());

  	return createDebug;
  }

  var common = setup$1;

  (function (module, exports) {
  /**
   * This is the web browser implementation of `debug()`.
   */

  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
  	let warned = false;

  	return () => {
  		if (!warned) {
  			warned = true;
  			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  		}
  	};
  })();

  /**
   * Colors.
   */

  exports.colors = [
  	'#0000CC',
  	'#0000FF',
  	'#0033CC',
  	'#0033FF',
  	'#0066CC',
  	'#0066FF',
  	'#0099CC',
  	'#0099FF',
  	'#00CC00',
  	'#00CC33',
  	'#00CC66',
  	'#00CC99',
  	'#00CCCC',
  	'#00CCFF',
  	'#3300CC',
  	'#3300FF',
  	'#3333CC',
  	'#3333FF',
  	'#3366CC',
  	'#3366FF',
  	'#3399CC',
  	'#3399FF',
  	'#33CC00',
  	'#33CC33',
  	'#33CC66',
  	'#33CC99',
  	'#33CCCC',
  	'#33CCFF',
  	'#6600CC',
  	'#6600FF',
  	'#6633CC',
  	'#6633FF',
  	'#66CC00',
  	'#66CC33',
  	'#9900CC',
  	'#9900FF',
  	'#9933CC',
  	'#9933FF',
  	'#99CC00',
  	'#99CC33',
  	'#CC0000',
  	'#CC0033',
  	'#CC0066',
  	'#CC0099',
  	'#CC00CC',
  	'#CC00FF',
  	'#CC3300',
  	'#CC3333',
  	'#CC3366',
  	'#CC3399',
  	'#CC33CC',
  	'#CC33FF',
  	'#CC6600',
  	'#CC6633',
  	'#CC9900',
  	'#CC9933',
  	'#CCCC00',
  	'#CCCC33',
  	'#FF0000',
  	'#FF0033',
  	'#FF0066',
  	'#FF0099',
  	'#FF00CC',
  	'#FF00FF',
  	'#FF3300',
  	'#FF3333',
  	'#FF3366',
  	'#FF3399',
  	'#FF33CC',
  	'#FF33FF',
  	'#FF6600',
  	'#FF6633',
  	'#FF9900',
  	'#FF9933',
  	'#FFCC00',
  	'#FFCC33'
  ];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */

  // eslint-disable-next-line complexity
  function useColors() {
  	// NB: In an Electron preload script, document will be defined but not fully
  	// initialized. Since we know we're in Chrome, we'll just detect this case
  	// explicitly
  	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
  		return true;
  	}

  	// Internet Explorer and Edge do not support colors.
  	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
  		return false;
  	}

  	// Is webkit? http://stackoverflow.com/a/16459606/376773
  	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
  		// Is firebug? http://stackoverflow.com/a/398120/376773
  		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
  		// Is firefox >= v31?
  		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
  		// Double check webkit in userAgent just in case we are in a worker
  		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }

  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
  	args[0] = (this.useColors ? '%c' : '') +
  		this.namespace +
  		(this.useColors ? ' %c' : ' ') +
  		args[0] +
  		(this.useColors ? '%c ' : ' ') +
  		'+' + module.exports.humanize(this.diff);

  	if (!this.useColors) {
  		return;
  	}

  	const c = 'color: ' + this.color;
  	args.splice(1, 0, c, 'color: inherit');

  	// The final "%c" is somewhat tricky, because there could be other
  	// arguments passed either before or after the %c, so we need to
  	// figure out the correct index to insert the CSS into
  	let index = 0;
  	let lastC = 0;
  	args[0].replace(/%[a-zA-Z%]/g, match => {
  		if (match === '%%') {
  			return;
  		}
  		index++;
  		if (match === '%c') {
  			// We only are interested in the *last* %c
  			// (the user may have provided their own)
  			lastC = index;
  		}
  	});

  	args.splice(lastC, 0, c);
  }

  /**
   * Invokes `console.debug()` when available.
   * No-op when `console.debug` is not a "function".
   * If `console.debug` is not available, falls back
   * to `console.log`.
   *
   * @api public
   */
  exports.log = console.debug || console.log || (() => {});

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  function save(namespaces) {
  	try {
  		if (namespaces) {
  			exports.storage.setItem('debug', namespaces);
  		} else {
  			exports.storage.removeItem('debug');
  		}
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  function load() {
  	let r;
  	try {
  		r = exports.storage.getItem('debug');
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}

  	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  	if (!r && typeof browser$1$1 !== 'undefined' && 'env' in browser$1$1) {
  		r = browser$1$1.env.DEBUG;
  	}

  	return r;
  }

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage() {
  	try {
  		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
  		// The Browser also has localStorage in the global context.
  		return localStorage;
  	} catch (error) {
  		// Swallow
  		// XXX (@Qix-) should we be logging these?
  	}
  }

  module.exports = common(exports);

  const {formatters} = module.exports;

  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */

  formatters.j = function (v) {
  	try {
  		return JSON.stringify(v);
  	} catch (error) {
  		return '[UnexpectedJSONParseError]: ' + error.message;
  	}
  };
  }(browser, browser.exports));

  var node$1 = {exports: {}};

  // MIT lisence
  // from https://github.com/substack/tty-browserify/blob/1ba769a6429d242f36226538835b4034bf6b7886/index.js

  function isatty() {
    return false;
  }

  function ReadStream() {
    throw new Error('tty.ReadStream is not implemented');
  }

  function WriteStream() {
    throw new Error('tty.ReadStream is not implemented');
  }

  var _polyfillNode_tty = {
    isatty: isatty,
    ReadStream: ReadStream,
    WriteStream: WriteStream
  };

  var _polyfillNode_tty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isatty: isatty,
    ReadStream: ReadStream,
    WriteStream: WriteStream,
    'default': _polyfillNode_tty
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_tty$1);

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$1 = {}.toString;

  var isArray$2 = Array.isArray || function (arr) {
    return toString$1.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer$1.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer$1(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer$1 (arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer$1.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer$1._augment = function (arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer$1.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer$1.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer$1.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer$1.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$2(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer$1.isBuffer = isBuffer$2;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer$1.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer$1.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer$1.concat = function concat (list, length) {
    if (!isArray$2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer$1.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer$1.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$1.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer$1.prototype._isBuffer = true;

  function swap$1 (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer$1.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap$1(this, i, i + 1);
    }
    return this
  };

  Buffer$1.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap$1(this, i, i + 3);
      swap$1(this, i + 1, i + 2);
    }
    return this
  };

  Buffer$1.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap$1(this, i, i + 7);
      swap$1(this, i + 1, i + 6);
      swap$1(this, i + 2, i + 5);
      swap$1(this, i + 3, i + 4);
    }
    return this
  };

  Buffer$1.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer$1.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer$1.compare(this, b) === 0
  };

  Buffer$1.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer$1.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer$1.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer$1.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer$1.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer$1.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer$1(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer$2(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var inherits;
  if (typeof Object.create === 'function'){
    inherits = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  var inherits$1 = inherits;

  var formatRegExp = /%[sdj%]/g;
  function format(f) {
    if (!isString$1(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject$1(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  }

  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global$1.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  }

  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = browser$1$1.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  }

  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction$1(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString$1(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction$1(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray$1(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction$1(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString$1(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber$1(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty$1(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty$1(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray$1(ar) {
    return Array.isArray(ar);
  }

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  function isNull(arg) {
    return arg === null;
  }

  function isNullOrUndefined(arg) {
    return arg == null;
  }

  function isNumber$1(arg) {
    return typeof arg === 'number';
  }

  function isString$1(arg) {
    return typeof arg === 'string';
  }

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }

  function isUndefined(arg) {
    return arg === void 0;
  }

  function isRegExp(re) {
    return isObject$1(re) && objectToString(re) === '[object RegExp]';
  }

  function isObject$1(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isDate(d) {
    return isObject$1(d) && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return isObject$1(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  function isFunction$1(arg) {
    return typeof arg === 'function';
  }

  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }

  function isBuffer$1(maybeBuf) {
    return Buffer$1.isBuffer(maybeBuf);
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }


  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }


  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

  // 26 Feb 16:19:34
  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }


  // log is just a thin wrapper to console.log that prepends a timestamp
  function log() {
    console.log('%s - %s', timestamp(), format.apply(null, arguments));
  }

  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject$1(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  function hasOwnProperty$1(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var _polyfillNode_util = {
    inherits: inherits$1,
    _extend: _extend,
    log: log,
    isBuffer: isBuffer$1,
    isPrimitive: isPrimitive,
    isFunction: isFunction$1,
    isError: isError,
    isDate: isDate,
    isObject: isObject$1,
    isRegExp: isRegExp,
    isUndefined: isUndefined,
    isSymbol: isSymbol,
    isString: isString$1,
    isNumber: isNumber$1,
    isNullOrUndefined: isNullOrUndefined,
    isNull: isNull,
    isBoolean: isBoolean,
    isArray: isArray$1,
    inspect: inspect,
    deprecate: deprecate,
    format: format,
    debuglog: debuglog
  };

  var _polyfillNode_util$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    format: format,
    deprecate: deprecate,
    debuglog: debuglog,
    inspect: inspect,
    isArray: isArray$1,
    isBoolean: isBoolean,
    isNull: isNull,
    isNullOrUndefined: isNullOrUndefined,
    isNumber: isNumber$1,
    isString: isString$1,
    isSymbol: isSymbol,
    isUndefined: isUndefined,
    isRegExp: isRegExp,
    isObject: isObject$1,
    isDate: isDate,
    isError: isError,
    isFunction: isFunction$1,
    isPrimitive: isPrimitive,
    isBuffer: isBuffer$1,
    log: log,
    inherits: inherits$1,
    _extend: _extend,
    'default': _polyfillNode_util
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_util$1);

  (function (module, exports) {
  const tty = require$$0;
  const util = require$$1;

  /**
   * This is the Node.js implementation of `debug()`.
   */

  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(
  	() => {},
  	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
  );

  /**
   * Colors.
   */

  exports.colors = [6, 2, 3, 4, 5, 1];

  try {
  	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
  	// eslint-disable-next-line import/no-extraneous-dependencies
  	const supportsColor = require$$2__default['default'];

  	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
  		exports.colors = [
  			20,
  			21,
  			26,
  			27,
  			32,
  			33,
  			38,
  			39,
  			40,
  			41,
  			42,
  			43,
  			44,
  			45,
  			56,
  			57,
  			62,
  			63,
  			68,
  			69,
  			74,
  			75,
  			76,
  			77,
  			78,
  			79,
  			80,
  			81,
  			92,
  			93,
  			98,
  			99,
  			112,
  			113,
  			128,
  			129,
  			134,
  			135,
  			148,
  			149,
  			160,
  			161,
  			162,
  			163,
  			164,
  			165,
  			166,
  			167,
  			168,
  			169,
  			170,
  			171,
  			172,
  			173,
  			178,
  			179,
  			184,
  			185,
  			196,
  			197,
  			198,
  			199,
  			200,
  			201,
  			202,
  			203,
  			204,
  			205,
  			206,
  			207,
  			208,
  			209,
  			214,
  			215,
  			220,
  			221
  		];
  	}
  } catch (error) {
  	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
  }

  /**
   * Build up the default `inspectOpts` object from the environment variables.
   *
   *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
   */

  exports.inspectOpts = Object.keys(browser$1$1.env).filter(key => {
  	return /^debug_/i.test(key);
  }).reduce((obj, key) => {
  	// Camel-case
  	const prop = key
  		.substring(6)
  		.toLowerCase()
  		.replace(/_([a-z])/g, (_, k) => {
  			return k.toUpperCase();
  		});

  	// Coerce string value into JS value
  	let val = browser$1$1.env[key];
  	if (/^(yes|on|true|enabled)$/i.test(val)) {
  		val = true;
  	} else if (/^(no|off|false|disabled)$/i.test(val)) {
  		val = false;
  	} else if (val === 'null') {
  		val = null;
  	} else {
  		val = Number(val);
  	}

  	obj[prop] = val;
  	return obj;
  }, {});

  /**
   * Is stdout a TTY? Colored output is enabled when `true`.
   */

  function useColors() {
  	return 'colors' in exports.inspectOpts ?
  		Boolean(exports.inspectOpts.colors) :
  		tty.isatty(browser$1$1.stderr.fd);
  }

  /**
   * Adds ANSI color escape codes if enabled.
   *
   * @api public
   */

  function formatArgs(args) {
  	const {namespace: name, useColors} = this;

  	if (useColors) {
  		const c = this.color;
  		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
  		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

  		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
  		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
  	} else {
  		args[0] = getDate() + name + ' ' + args[0];
  	}
  }

  function getDate() {
  	if (exports.inspectOpts.hideDate) {
  		return '';
  	}
  	return new Date().toISOString() + ' ';
  }

  /**
   * Invokes `util.format()` with the specified arguments and writes to stderr.
   */

  function log(...args) {
  	return browser$1$1.stderr.write(util.format(...args) + '\n');
  }

  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  function save(namespaces) {
  	if (namespaces) {
  		browser$1$1.env.DEBUG = namespaces;
  	} else {
  		// If you set a process.env field to null or undefined, it gets cast to the
  		// string 'null' or 'undefined'. Just delete instead.
  		delete browser$1$1.env.DEBUG;
  	}
  }

  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */

  function load() {
  	return browser$1$1.env.DEBUG;
  }

  /**
   * Init logic for `debug` instances.
   *
   * Create a new `inspectOpts` object in case `useColors` is set
   * differently for a particular `debug` instance.
   */

  function init(debug) {
  	debug.inspectOpts = {};

  	const keys = Object.keys(exports.inspectOpts);
  	for (let i = 0; i < keys.length; i++) {
  		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  	}
  }

  module.exports = common(exports);

  const {formatters} = module.exports;

  /**
   * Map %o to `util.inspect()`, all on a single line.
   */

  formatters.o = function (v) {
  	this.inspectOpts.colors = this.useColors;
  	return util.inspect(v, this.inspectOpts)
  		.split('\n')
  		.map(str => str.trim())
  		.join(' ');
  };

  /**
   * Map %O to `util.inspect()`, allowing multiple lines if needed.
   */

  formatters.O = function (v) {
  	this.inspectOpts.colors = this.useColors;
  	return util.inspect(v, this.inspectOpts);
  };
  }(node$1, node$1.exports));

  if (typeof browser$1$1 === 'undefined' || browser$1$1.type === 'renderer' || browser$1$1.browser === true || browser$1$1.__nwjs) {
  	src.exports = browser.exports;
  } else {
  	src.exports = node$1.exports;
  }

  var scope$1 = {};

  var renamer = {};

  var binding = {};

  Object.defineProperty(binding, "__esModule", {
    value: true
  });
  binding.default = void 0;

  class Binding {
    constructor({
      identifier,
      scope,
      path,
      kind
    }) {
      this.identifier = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.kind = void 0;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path;
      this.kind = kind;
      this.clearValue();
    }

    deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    }

    setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    }

    clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    }

    reassign(path) {
      this.constant = false;

      if (this.constantViolations.indexOf(path) !== -1) {
        return;
      }

      this.constantViolations.push(path);
    }

    reference(path) {
      if (this.referencePaths.indexOf(path) !== -1) {
        return;
      }

      this.referenced = true;
      this.references++;
      this.referencePaths.push(path);
    }

    dereference() {
      this.references--;
      this.referenced = !!this.references;
    }

  }

  binding.default = Binding;

  var lib$7 = {};

  Object.defineProperty(lib$7, "__esModule", {
    value: true
  });
  lib$7.default = splitExportDeclaration;

  var t$v = lib$9;

  function splitExportDeclaration(exportDeclaration) {
    if (!exportDeclaration.isExportDeclaration()) {
      throw new Error("Only export declarations can be split.");
    }

    const isDefault = exportDeclaration.isExportDefaultDeclaration();
    const declaration = exportDeclaration.get("declaration");
    const isClassDeclaration = declaration.isClassDeclaration();

    if (isDefault) {
      const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
      const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      let id = declaration.node.id;
      let needBindingRegistration = false;

      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier("default");

        if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
          declaration.node.id = t$v.cloneNode(id);
        }
      }

      const updatedDeclaration = standaloneDeclaration ? declaration : t$v.variableDeclaration("var", [t$v.variableDeclarator(t$v.cloneNode(id), declaration.node)]);
      const updatedExportDeclaration = t$v.exportNamedDeclaration(null, [t$v.exportSpecifier(t$v.cloneNode(id), t$v.identifier("default"))]);
      exportDeclaration.insertAfter(updatedExportDeclaration);
      exportDeclaration.replaceWith(updatedDeclaration);

      if (needBindingRegistration) {
        scope.registerDeclaration(exportDeclaration);
      }

      return exportDeclaration;
    }

    if (exportDeclaration.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }

    const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    const specifiers = Object.keys(bindingIdentifiers).map(name => {
      return t$v.exportSpecifier(t$v.identifier(name), t$v.identifier(name));
    });
    const aliasDeclar = t$v.exportNamedDeclaration(null, specifiers);
    exportDeclaration.insertAfter(aliasDeclar);
    exportDeclaration.replaceWith(declaration.node);
    return exportDeclaration;
  }

  Object.defineProperty(renamer, "__esModule", {
    value: true
  });
  renamer.default = void 0;

  var _helperSplitExportDeclaration = lib$7;

  var t$u = lib$9;

  const renameVisitor = {
    ReferencedIdentifier({
      node
    }, state) {
      if (node.name === state.oldName) {
        node.name = state.newName;
      }
    },

    Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        skipAllButComputedMethodKey(path);
      }
    },

    "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {
      if (path.isVariableDeclaration()) return;
      const ids = path.getOuterBindingIdentifiers();

      for (const name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }

  };

  class Renamer {
    constructor(binding, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }

    maybeConvertFromExportDeclaration(parentDeclar) {
      const maybeExportDeclar = parentDeclar.parentPath;

      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }

      if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
        return;
      }

      (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);
    }

    maybeConvertFromClassFunctionDeclaration(path) {
      return;
    }

    maybeConvertFromClassFunctionExpression(path) {
      return;
    }

    rename(block) {
      const {
        binding,
        oldName,
        newName
      } = this;
      const {
        scope,
        path
      } = binding;
      const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());

      if (parentDeclar) {
        const bindingIds = parentDeclar.getOuterBindingIdentifiers();

        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }

      const blockToTraverse = block || scope.block;

      if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === "SwitchStatement") {
        blockToTraverse.cases.forEach(c => {
          scope.traverse(c, renameVisitor, this);
        });
      } else {
        scope.traverse(blockToTraverse, renameVisitor, this);
      }

      if (!block) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }

      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
        this.maybeConvertFromClassFunctionExpression(parentDeclar);
      }
    }

  }

  renamer.default = Renamer;

  function skipAllButComputedMethodKey(path) {
    if (!path.isMethod() || !path.node.computed) {
      path.skip();
      return;
    }

    const keys = t$u.VISITOR_KEYS[path.type];

    for (const key of keys) {
      if (key !== "key") path.skipKey(key);
    }
  }

  var cache = {};

  Object.defineProperty(cache, "__esModule", {
    value: true
  });
  cache.clear = clear;
  cache.clearPath = clearPath;
  cache.clearScope = clearScope;
  cache.scope = cache.path = void 0;
  let path = new WeakMap();
  cache.path = path;
  let scope = new WeakMap();
  cache.scope = scope;

  function clear() {
    clearPath();
    clearScope();
  }

  function clearPath() {
    cache.path = path = new WeakMap();
  }

  function clearScope() {
    cache.scope = scope = new WeakMap();
  }

  Object.defineProperty(scope$1, "__esModule", {
    value: true
  });
  scope$1.default = void 0;

  var _renamer = renamer;

  var _index$6 = lib$a;

  var _binding = binding;

  var _globals = require$$3__default['default'];

  var t$t = lib$9;

  var _cache$4 = cache;

  function gatherNodeParts(node, parts) {
    switch (node == null ? void 0 : node.type) {
      default:
        if (t$t.isModuleDeclaration(node)) {
          if ((t$t.isExportAllDeclaration(node) || t$t.isExportNamedDeclaration(node) || t$t.isImportDeclaration(node)) && node.source) {
            gatherNodeParts(node.source, parts);
          } else if ((t$t.isExportNamedDeclaration(node) || t$t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {
            for (const e of node.specifiers) gatherNodeParts(e, parts);
          } else if ((t$t.isExportDefaultDeclaration(node) || t$t.isExportNamedDeclaration(node)) && node.declaration) {
            gatherNodeParts(node.declaration, parts);
          }
        } else if (t$t.isModuleSpecifier(node)) {
          gatherNodeParts(node.local, parts);
        } else if (t$t.isLiteral(node)) {
          parts.push(node.value);
        }

        break;

      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "Identifier":
      case "JSXIdentifier":
        parts.push(node.name);
        break;

      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node.callee, parts);
        break;

      case "ObjectExpression":
      case "ObjectPattern":
        for (const e of node.properties) {
          gatherNodeParts(e, parts);
        }

        break;

      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node.argument, parts);
        break;

      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node.key, parts);
        break;

      case "ThisExpression":
        parts.push("this");
        break;

      case "Super":
        parts.push("super");
        break;

      case "Import":
        parts.push("import");
        break;

      case "DoExpression":
        parts.push("do");
        break;

      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node.argument, parts);
        break;

      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node.argument, parts);
        break;

      case "AssignmentExpression":
        gatherNodeParts(node.left, parts);
        break;

      case "VariableDeclarator":
        gatherNodeParts(node.id, parts);
        break;

      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node.id, parts);
        break;

      case "PrivateName":
        gatherNodeParts(node.id, parts);
        break;

      case "ParenthesizedExpression":
        gatherNodeParts(node.expression, parts);
        break;

      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node.argument, parts);
        break;

      case "MetaProperty":
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "JSXElement":
        gatherNodeParts(node.openingElement, parts);
        break;

      case "JSXOpeningElement":
        parts.push(node.name);
        break;

      case "JSXFragment":
        gatherNodeParts(node.openingFragment, parts);
        break;

      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;

      case "JSXNamespacedName":
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
  }

  const collectorVisitor = {
    For(path) {
      for (const key of t$t.FOR_INIT_KEYS) {
        const declar = path.get(key);

        if (declar.isVar()) {
          const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      }
    },

    Declaration(path) {
      if (path.isBlockScoped()) return;
      if (path.isExportDeclaration()) return;
      const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
      parent.registerDeclaration(path);
    },

    ReferencedIdentifier(path, state) {
      state.references.push(path);
    },

    ForXStatement(path, state) {
      const left = path.get("left");

      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path);
      }
    },

    ExportDeclaration: {
      exit(path) {
        const {
          node,
          scope
        } = path;
        if (t$t.isExportAllDeclaration(node)) return;
        const declar = node.declaration;

        if (t$t.isClassDeclaration(declar) || t$t.isFunctionDeclaration(declar)) {
          const id = declar.id;
          if (!id) return;
          const binding = scope.getBinding(id.name);
          if (binding) binding.reference(path);
        } else if (t$t.isVariableDeclaration(declar)) {
          for (const decl of declar.declarations) {
            for (const name of Object.keys(t$t.getBindingIdentifiers(decl))) {
              const binding = scope.getBinding(name);
              if (binding) binding.reference(path);
            }
          }
        }
      }

    },

    LabeledStatement(path) {
      path.scope.getBlockParent().registerDeclaration(path);
    },

    AssignmentExpression(path, state) {
      state.assignments.push(path);
    },

    UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },

    UnaryExpression(path, state) {
      if (path.node.operator === "delete") {
        state.constantViolations.push(path);
      }
    },

    BlockScoped(path) {
      let scope = path.scope;
      if (scope.path === path) scope = scope.parent;
      const parent = scope.getBlockParent();
      parent.registerDeclaration(path);

      if (path.isClassDeclaration() && path.node.id) {
        const id = path.node.id;
        const name = id.name;
        path.scope.bindings[name] = path.scope.parent.getBinding(name);
      }
    },

    CatchClause(path) {
      path.scope.registerBinding("let", path);
    },

    Function(path) {
      if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[t$t.NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }

      const params = path.get("params");

      for (const param of params) {
        path.scope.registerBinding("param", param);
      }
    },

    ClassExpression(path) {
      if (path.has("id") && !path.get("id").node[t$t.NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path);
      }
    }

  };
  let uid = 0;

  class Scope {
    constructor(path) {
      this.uid = void 0;
      this.path = void 0;
      this.block = void 0;
      this.labels = void 0;
      this.inited = void 0;
      this.bindings = void 0;
      this.references = void 0;
      this.globals = void 0;
      this.uids = void 0;
      this.data = void 0;
      this.crawling = void 0;
      const {
        node
      } = path;

      const cached = _cache$4.scope.get(node);

      if ((cached == null ? void 0 : cached.path) === path) {
        return cached;
      }

      _cache$4.scope.set(node, this);

      this.uid = uid++;
      this.block = node;
      this.path = path;
      this.labels = new Map();
      this.inited = false;
    }

    get parent() {
      var _parent;

      let parent,
          path = this.path;

      do {
        const isKey = path.key === "key";
        path = path.parentPath;
        if (isKey && path.isMethod()) path = path.parentPath;
        if (path && path.isScope()) parent = path;
      } while (path && !parent);

      return (_parent = parent) == null ? void 0 : _parent.scope;
    }

    get parentBlock() {
      return this.path.parent;
    }

    get hub() {
      return this.path.hub;
    }

    traverse(node, opts, state) {
      (0, _index$6.default)(node, opts, this, state, this.path);
    }

    generateDeclaredUidIdentifier(name) {
      const id = this.generateUidIdentifier(name);
      this.push({
        id
      });
      return t$t.cloneNode(id);
    }

    generateUidIdentifier(name) {
      return t$t.identifier(this.generateUid(name));
    }

    generateUid(name = "temp") {
      name = t$t.toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let uid;
      let i = 1;

      do {
        uid = this._generateUid(name, i);
        i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

      const program = this.getProgramParent();
      program.references[uid] = true;
      program.uids[uid] = true;
      return uid;
    }

    _generateUid(name, i) {
      let id = name;
      if (i > 1) id += i;
      return `_${id}`;
    }

    generateUidBasedOnNode(node, defaultName) {
      const parts = [];
      gatherNodeParts(node, parts);
      let id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    }

    generateUidIdentifierBasedOnNode(node, defaultName) {
      return t$t.identifier(this.generateUidBasedOnNode(node, defaultName));
    }

    isStatic(node) {
      if (t$t.isThisExpression(node) || t$t.isSuper(node)) {
        return true;
      }

      if (t$t.isIdentifier(node)) {
        const binding = this.getBinding(node.name);

        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }

      return false;
    }

    maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        const id = this.generateUidIdentifierBasedOnNode(node);

        if (!dontPush) {
          this.push({
            id
          });
          return t$t.cloneNode(id);
        }

        return id;
      }
    }

    checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

      if (duplicate) {
        throw this.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);
      }
    }

    rename(oldName, newName, block) {
      const binding = this.getBinding(oldName);

      if (binding) {
        newName = newName || this.generateUidIdentifier(oldName).name;
        return new _renamer.default(binding, oldName, newName).rename(block);
      }
    }

    _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    }

    dump() {
      const sep = "-".repeat(60);
      console.log(sep);
      let scope = this;

      do {
        console.log("#", scope.block.type);

        for (const name of Object.keys(scope.bindings)) {
          const binding = scope.bindings[name];
          console.log(" -", name, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);

      console.log(sep);
    }

    toArray(node, i, arrayLikeIsIterable) {
      if (t$t.isIdentifier(node)) {
        const binding = this.getBinding(node.name);

        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }

      if (t$t.isArrayExpression(node)) {
        return node;
      }

      if (t$t.isIdentifier(node, {
        name: "arguments"
      })) {
        return t$t.callExpression(t$t.memberExpression(t$t.memberExpression(t$t.memberExpression(t$t.identifier("Array"), t$t.identifier("prototype")), t$t.identifier("slice")), t$t.identifier("call")), [node]);
      }

      let helperName;
      const args = [node];

      if (i === true) {
        helperName = "toConsumableArray";
      } else if (i) {
        args.push(t$t.numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }

      if (arrayLikeIsIterable) {
        args.unshift(this.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }

      return t$t.callExpression(this.hub.addHelper(helperName), args);
    }

    hasLabel(name) {
      return !!this.getLabel(name);
    }

    getLabel(name) {
      return this.labels.get(name);
    }

    registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    }

    registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        const declarations = path.get("declarations");

        for (const declar of declarations) {
          this.registerBinding(path.node.kind, declar);
        }
      } else if (path.isClassDeclaration()) {
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        const specifiers = path.get("specifiers");

        for (const specifier of specifiers) {
          this.registerBinding("module", specifier);
        }
      } else if (path.isExportDeclaration()) {
        const declar = path.get("declaration");

        if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
          this.registerDeclaration(declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    }

    buildUndefinedNode() {
      return t$t.unaryExpression("void", t$t.numericLiteral(0), true);
    }

    registerConstantViolation(path) {
      const ids = path.getBindingIdentifiers();

      for (const name of Object.keys(ids)) {
        const binding = this.getBinding(name);
        if (binding) binding.reassign(path);
      }
    }

    registerBinding(kind, path, bindingPath = path) {
      if (!kind) throw new ReferenceError("no `kind`");

      if (path.isVariableDeclaration()) {
        const declarators = path.get("declarations");

        for (const declar of declarators) {
          this.registerBinding(kind, declar);
        }

        return;
      }

      const parent = this.getProgramParent();
      const ids = path.getOuterBindingIdentifiers(true);

      for (const name of Object.keys(ids)) {
        parent.references[name] = true;

        for (const id of ids[name]) {
          const local = this.getOwnBinding(name);

          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, name, id);
          }

          if (local) {
            this.registerConstantViolation(bindingPath);
          } else {
            this.bindings[name] = new _binding.default({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind: kind
            });
          }
        }
      }
    }

    addGlobal(node) {
      this.globals[node.name] = node;
    }

    hasUid(name) {
      let scope = this;

      do {
        if (scope.uids[name]) return true;
      } while (scope = scope.parent);

      return false;
    }

    hasGlobal(name) {
      let scope = this;

      do {
        if (scope.globals[name]) return true;
      } while (scope = scope.parent);

      return false;
    }

    hasReference(name) {
      return !!this.getProgramParent().references[name];
    }

    isPure(node, constantsOnly) {
      if (t$t.isIdentifier(node)) {
        const binding = this.getBinding(node.name);
        if (!binding) return false;
        if (constantsOnly) return binding.constant;
        return true;
      } else if (t$t.isClass(node)) {
        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }

        return this.isPure(node.body, constantsOnly);
      } else if (t$t.isClassBody(node)) {
        for (const method of node.body) {
          if (!this.isPure(method, constantsOnly)) return false;
        }

        return true;
      } else if (t$t.isBinary(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (t$t.isArrayExpression(node)) {
        for (const elem of node.elements) {
          if (!this.isPure(elem, constantsOnly)) return false;
        }

        return true;
      } else if (t$t.isObjectExpression(node)) {
        for (const prop of node.properties) {
          if (!this.isPure(prop, constantsOnly)) return false;
        }

        return true;
      } else if (t$t.isMethod(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        if (node.kind === "get" || node.kind === "set") return false;
        return true;
      } else if (t$t.isProperty(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        return this.isPure(node.value, constantsOnly);
      } else if (t$t.isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (t$t.isTaggedTemplateExpression(node)) {
        return t$t.matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
      } else if (t$t.isTemplateLiteral(node)) {
        for (const expression of node.expressions) {
          if (!this.isPure(expression, constantsOnly)) return false;
        }

        return true;
      } else {
        return t$t.isPureish(node);
      }
    }

    setData(key, val) {
      return this.data[key] = val;
    }

    getData(key) {
      let scope = this;

      do {
        const data = scope.data[key];
        if (data != null) return data;
      } while (scope = scope.parent);
    }

    removeData(key) {
      let scope = this;

      do {
        const data = scope.data[key];
        if (data != null) scope.data[key] = null;
      } while (scope = scope.parent);
    }

    init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    }

    crawl() {
      const path = this.path;
      this.references = Object.create(null);
      this.bindings = Object.create(null);
      this.globals = Object.create(null);
      this.uids = Object.create(null);
      this.data = Object.create(null);
      const programParent = this.getProgramParent();
      if (programParent.crawling) return;
      const state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;

      if (path.type !== "Program" && collectorVisitor._exploded) {
        for (const visit of collectorVisitor.enter) {
          visit(path, state);
        }

        const typeVisitors = collectorVisitor[path.type];

        if (typeVisitors) {
          for (const visit of typeVisitors.enter) {
            visit(path, state);
          }
        }
      }

      path.traverse(collectorVisitor, state);
      this.crawling = false;

      for (const path of state.assignments) {
        const ids = path.getBindingIdentifiers();

        for (const name of Object.keys(ids)) {
          if (path.scope.getBinding(name)) continue;
          programParent.addGlobal(ids[name]);
        }

        path.scope.registerConstantViolation(path);
      }

      for (const ref of state.references) {
        const binding = ref.scope.getBinding(ref.node.name);

        if (binding) {
          binding.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }

      for (const path of state.constantViolations) {
        path.scope.registerConstantViolation(path);
      }
    }

    push(opts) {
      let path = this.path;

      if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }

      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }

      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }

      const unique = opts.unique;
      const kind = opts.kind || "var";
      const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      const dataKey = `declaration:${kind}:${blockHoist}`;
      let declarPath = !unique && path.getData(dataKey);

      if (!declarPath) {
        const declar = t$t.variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;
        [declarPath] = path.unshiftContainer("body", [declar]);
        if (!unique) path.setData(dataKey, declarPath);
      }

      const declarator = t$t.variableDeclarator(opts.id, opts.init);
      declarPath.node.declarations.push(declarator);
      this.registerBinding(kind, declarPath.get("declarations").pop());
    }

    getProgramParent() {
      let scope = this;

      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("Couldn't find a Program");
    }

    getFunctionParent() {
      let scope = this;

      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      return null;
    }

    getBlockParent() {
      let scope = this;

      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }

    getAllBindings() {
      const ids = Object.create(null);
      let scope = this;

      do {
        for (const key of Object.keys(scope.bindings)) {
          if (key in ids === false) {
            ids[key] = scope.bindings[key];
          }
        }

        scope = scope.parent;
      } while (scope);

      return ids;
    }

    getAllBindingsOfKind(...kinds) {
      const ids = Object.create(null);

      for (const kind of kinds) {
        let scope = this;

        do {
          for (const name of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name];
            if (binding.kind === kind) ids[name] = binding;
          }

          scope = scope.parent;
        } while (scope);
      }

      return ids;
    }

    bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    }

    getBinding(name) {
      let scope = this;
      let previousPath;

      do {
        const binding = scope.getOwnBinding(name);

        if (binding) {
          var _previousPath;

          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param") ; else {
            return binding;
          }
        }

        previousPath = scope.path;
      } while (scope = scope.parent);
    }

    getOwnBinding(name) {
      return this.bindings[name];
    }

    getBindingIdentifier(name) {
      var _this$getBinding;

      return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
    }

    getOwnBindingIdentifier(name) {
      const binding = this.bindings[name];
      return binding == null ? void 0 : binding.identifier;
    }

    hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    }

    hasBinding(name, noGlobals) {
      if (!name) return false;
      if (this.hasOwnBinding(name)) return true;
      if (this.parentHasBinding(name, noGlobals)) return true;
      if (this.hasUid(name)) return true;
      if (!noGlobals && Scope.globals.includes(name)) return true;
      if (!noGlobals && Scope.contextVariables.includes(name)) return true;
      return false;
    }

    parentHasBinding(name, noGlobals) {
      var _this$parent;

      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
    }

    moveBindingTo(name, scope) {
      const info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    }

    removeOwnBinding(name) {
      delete this.bindings[name];
    }

    removeBinding(name) {
      var _this$getBinding2;

      (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);
      let scope = this;

      do {
        if (scope.uids[name]) {
          scope.uids[name] = false;
        }
      } while (scope = scope.parent);
    }

  }

  scope$1.default = Scope;
  
  Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

  var lib$6 = {};

  var sourceMap$1 = {};

  var sourceMap = {};

  var sourceMapGenerator = {};

  var base64Vlq = {};

  var base64$1 = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  base64$1.encode = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  base64$1.decode = function (charCode) {
    var bigA = 65;     // 'A'
    var bigZ = 90;     // 'Z'

    var littleA = 97;  // 'a'
    var littleZ = 122; // 'z'

    var zero = 48;     // '0'
    var nine = 57;     // '9'

    var plus = 43;     // '+'
    var slash = 47;    // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */

  var base64 = base64$1;

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var util$5 = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  (function (exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = (function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }());

  function identity (s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
      return false;
    }

    if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
        s.charCodeAt(length - 2) !== 95  /* '_' */ ||
        s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 4) !== 116 /* 't' */ ||
        s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
        s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
        s.charCodeAt(length - 8) !== 95  /* '_' */ ||
        s.charCodeAt(length - 9) !== 95  /* '_' */) {
      return false;
    }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = mappingA.source - mappingB.source;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return mappingA.name - mappingB.name;
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }(util$5));

  var arraySet = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util$4 = util$5;
  var has$1 = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet$2() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$2();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet$2.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has$1.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet$2.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util$4.toSetString(aStr);
      return has$1.call(this._set, sStr);
    }
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
          return idx;
      }
    } else {
      var sStr = util$4.toSetString(aStr);
      if (has$1.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet$2.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  arraySet.ArraySet = ArraySet$2;

  var mappingList = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util$3 = util$5;

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util$3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList$1() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList$1.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList$1.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList$1.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util$3.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  mappingList.MappingList = MappingList$1;

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var base64VLQ$1 = base64Vlq;
  var util$2 = util$5;
  var ArraySet$1 = arraySet.ArraySet;
  var MappingList = mappingList.MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator$1(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util$2.getArg(aArgs, 'file', null);
    this._sourceRoot = util$2.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util$2.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator$1.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator$1.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator$1({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util$2.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator$1.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util$2.getArg(aArgs, 'generated');
      var original = util$2.getArg(aArgs, 'original', null);
      var source = util$2.getArg(aArgs, 'source', null);
      var name = util$2.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }

      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator$1.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util$2.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util$2.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util$2.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator$1.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util$2.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet$1();
      var newNames = new ArraySet$1();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util$2.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util$2.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util$2.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util$2.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator$1.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      // When aOriginal is truthy but has empty values for .line and .column,
      // it is most likely a programmer error. In this case we throw a very
      // specific error message to try to guide them the right way.
      // For example: https://github.com/Polymer/polymer-bundler/pull/519
      if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
          throw new Error(
              'original.line and original.column are not numbers -- you probably meant to omit ' +
              'the original mapping entirely and only map the generated position. If so, pass ' +
              'null for the original mapping instead of an object with empty or null values.'
          );
      }

      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator$1.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = '';

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util$2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ',';
          }
        }

        next += base64VLQ$1.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ$1.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;

          // lines are stored 0-based in SourceMap spec version 3
          next += base64VLQ$1.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          next += base64VLQ$1.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ$1.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }

        result += next;
      }

      return result;
    };

  SourceMapGenerator$1.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util$2.relative(aSourceRoot, source);
        }
        var key = util$2.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator$1.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator$1.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator$1;

  var sourceMapConsumer = {};

  var binarySearch$1 = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  (function (exports) {
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };
  }(binarySearch$1));

  var quickSort$1 = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  quickSort$1.quickSort = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var util$1 = util$5;
  var binarySearch = binarySearch$1;
  var ArraySet = arraySet.ArraySet;
  var base64VLQ = base64Vlq;
  var quickSort = quickSort$1.quickSort;

  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap)
      : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        if (source != null && sourceRoot != null) {
          source = util$1.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: Optional. the column number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util$1.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
        source: util$1.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util$1.getArg(aArgs, 'column', 0)
      };

      if (this.sourceRoot != null) {
        needle.source = util$1.relative(this.sourceRoot, needle.source);
      }
      if (!this._sources.has(needle.source)) {
        return [];
      }
      needle.source = this._sources.indexOf(needle.source);

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util$1.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we found. Since
          // mappings are sorted, this is guaranteed to find all mappings for
          // the line we found.
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util$1.getArg(mapping, 'generatedLine', null),
              column: util$1.getArg(mapping, 'generatedColumn', null),
              lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we were searching for.
          // Since mappings are sorted, this is guaranteed to find all mappings for
          // the line we are searching for.
          while (mapping &&
                 mapping.originalLine === line &&
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util$1.getArg(mapping, 'generatedLine', null),
              column: util$1.getArg(mapping, 'generatedColumn', null),
              lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util$1.getArg(sourceMap, 'version');
    var sources = util$1.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util$1.getArg(sourceMap, 'names', []);
    var sourceRoot = util$1.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util$1.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util$1.getArg(sourceMap, 'mappings');
    var file = util$1.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources
      .map(String)
      // Some source maps produce relative source paths like "./foo.js" instead of
      // "foo.js".  Normalize these first so that future comparisons will succeed.
      // See bugzil.la/1090768.
      .map(util$1.normalize)
      // Always ensure that absolute sources are internally stored relative to
      // the source root, if the source root is absolute. Not doing this would
      // be particularly problematic when the source root is a prefix of the
      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
      .map(function (source) {
        return sourceRoot && util$1.isAbsolute(sourceRoot) && util$1.isAbsolute(source)
          ? util$1.relative(sourceRoot, source)
          : source;
      });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util$1.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util$1.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        }
        else if (aStr.charAt(index) === ',') {
          index++;
        }
        else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          // Because each offset is encoded relative to the previous one,
          // many segments often have the same encoding. We can exploit this
          // fact by caching the parsed variable length fields of each segment,
          // allowing us to avoid a second parse if we encounter the same
          // segment again.
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column.
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source.
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line.
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;

            // Original column.
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              // Original name.
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort(generatedMappings, util$1.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util$1.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util$1.getArg(aArgs, 'line'),
        generatedColumn: util$1.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util$1.compareByGeneratedPositionsDeflated,
        util$1.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util$1.getArg(mapping, 'source', null);
          if (source !== null) {
            source = this._sources.at(source);
            if (this.sourceRoot != null) {
              source = util$1.join(this.sourceRoot, source);
            }
          }
          var name = util$1.getArg(mapping, 'name', null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util$1.getArg(mapping, 'originalLine', null),
            column: util$1.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) { return sc == null; });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util$1.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util$1.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util$1.getArg(aArgs, 'source');
      if (this.sourceRoot != null) {
        source = util$1.relative(this.sourceRoot, source);
      }
      if (!this._sources.has(source)) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      source = this._sources.indexOf(source);

      var needle = {
        source: source,
        originalLine: util$1.getArg(aArgs, 'line'),
        originalColumn: util$1.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util$1.compareByOriginalPositions,
        util$1.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util$1.getArg(mapping, 'generatedLine', null),
            column: util$1.getArg(mapping, 'generatedColumn', null),
            lastColumn: util$1.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The only parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util$1.getArg(sourceMap, 'version');
    var sections = util$1.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util$1.getArg(s, 'offset');
      var offsetLine = util$1.getArg(offset, 'line');
      var offsetColumn = util$1.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util$1.getArg(s, 'map'))
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util$1.getArg(aArgs, 'line'),
        generatedColumn: util$1.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0),
        bias: aArgs.bias
      });
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer.sources.indexOf(util$1.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];

          var source = section.consumer._sources.at(mapping.source);
          if (section.consumer.sourceRoot !== null) {
            source = util$1.join(section.consumer.sourceRoot, source);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);

          var name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
              ? section.generatedOffset.generatedColumn - 1
              : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }

      quickSort(this.__generatedMappings, util$1.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util$1.compareByOriginalPositions);
    };

  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

  var sourceNode = {};

  /* -*- Mode: js; js-indent-level: 2; -*- */

  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
  var util = util$5;

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are accessed by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;

        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ?
              remainingLines[remainingLinesIndex++] : undefined;
        }
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[remainingLinesIndex];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  sourceNode.SourceNode = SourceNode;

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  sourceMap.SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
  sourceMap.SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
  sourceMap.SourceNode = sourceNode.SourceNode;

  Object.defineProperty(sourceMap$1, "__esModule", {
    value: true
  });
  sourceMap$1.default = void 0;

  var _sourceMap$1 = sourceMap;

  class SourceMap {
    constructor(opts, code) {
      this._cachedMap = void 0;
      this._code = void 0;
      this._opts = void 0;
      this._rawMappings = void 0;
      this._lastGenLine = void 0;
      this._lastSourceLine = void 0;
      this._lastSourceColumn = void 0;
      this._cachedMap = null;
      this._code = code;
      this._opts = opts;
      this._rawMappings = [];
    }

    get() {
      if (!this._cachedMap) {
        const map = this._cachedMap = new _sourceMap$1.SourceMapGenerator({
          sourceRoot: this._opts.sourceRoot
        });
        const code = this._code;

        if (typeof code === "string") {
          map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
        } else if (typeof code === "object") {
          Object.keys(code).forEach(sourceFileName => {
            map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          });
        }

        this._rawMappings.forEach(mapping => map.addMapping(mapping), map);
      }

      return this._cachedMap.toJSON();
    }

    getRawMappings() {
      return this._rawMappings.slice();
    }

    mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
      if (this._lastGenLine !== generatedLine && line === null) return;

      if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
        return;
      }

      this._cachedMap = null;
      this._lastGenLine = generatedLine;
      this._lastSourceLine = line;
      this._lastSourceColumn = column;

      this._rawMappings.push({
        name: identifierName || undefined,
        generated: {
          line: generatedLine,
          column: generatedColumn
        },
        source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
        original: line == null ? undefined : {
          line: line,
          column: column
        }
      });
    }

  }

  sourceMap$1.default = SourceMap;

  var printer = {};

  var buffer = {};

  Object.defineProperty(buffer, "__esModule", {
    value: true
  });
  buffer.default = void 0;
  const SPACES_RE = /^[ \t]+$/;

  class Buffer {
    constructor(map) {
      this._map = null;
      this._buf = [];
      this._last = "";
      this._queue = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: null,
        line: null,
        column: null,
        filename: null
      };
      this._disallowedPop = null;
      this._map = map;
    }

    get() {
      this._flush();

      const map = this._map;
      const result = {
        code: this._buf.join("").trimRight(),
        map: null,
        rawMappings: map == null ? void 0 : map.getRawMappings()
      };

      if (map) {
        Object.defineProperty(result, "map", {
          configurable: true,
          enumerable: true,

          get() {
            return this.map = map.get();
          },

          set(value) {
            Object.defineProperty(this, "map", {
              value,
              writable: true
            });
          }

        });
      }

      return result;
    }

    append(str) {
      this._flush();

      const {
        line,
        column,
        filename,
        identifierName,
        force
      } = this._sourcePosition;

      this._append(str, line, column, identifierName, filename, force);
    }

    queue(str) {
      if (str === "\n") {
        while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
          this._queue.shift();
        }
      }

      const {
        line,
        column,
        filename,
        identifierName,
        force
      } = this._sourcePosition;

      this._queue.unshift([str, line, column, identifierName, filename, force]);
    }

    _flush() {
      let item;

      while (item = this._queue.pop()) {
        this._append(...item);
      }
    }

    _append(str, line, column, identifierName, filename, force) {
      this._buf.push(str);

      this._last = str[str.length - 1];
      let i = str.indexOf("\n");
      let last = 0;

      if (i !== 0) {
        this._mark(line, column, identifierName, filename, force);
      }

      while (i !== -1) {
        this._position.line++;
        this._position.column = 0;
        last = i + 1;

        if (last < str.length) {
          this._mark(++line, 0, identifierName, filename, force);
        }

        i = str.indexOf("\n", last);
      }

      this._position.column += str.length - last;
    }

    _mark(line, column, identifierName, filename, force) {
      var _this$_map;

      (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
    }

    removeTrailingNewline() {
      if (this._queue.length > 0 && this._queue[0][0] === "\n") {
        this._queue.shift();
      }
    }

    removeLastSemicolon() {
      if (this._queue.length > 0 && this._queue[0][0] === ";") {
        this._queue.shift();
      }
    }

    endsWith(suffix) {
      if (suffix.length === 1) {
        let last;

        if (this._queue.length > 0) {
          const str = this._queue[0][0];
          last = str[str.length - 1];
        } else {
          last = this._last;
        }

        return last === suffix;
      }

      const end = this._last + this._queue.reduce((acc, item) => item[0] + acc, "");

      if (suffix.length <= end.length) {
        return end.slice(-suffix.length) === suffix;
      }

      return false;
    }

    hasContent() {
      return this._queue.length > 0 || !!this._last;
    }

    exactSource(loc, cb) {
      this.source("start", loc, true);
      cb();
      this.source("end", loc);

      this._disallowPop("start", loc);
    }

    source(prop, loc, force) {
      if (prop && !loc) return;

      this._normalizePosition(prop, loc, this._sourcePosition, force);
    }

    withSource(prop, loc, cb) {
      if (!this._map) return cb();
      const originalLine = this._sourcePosition.line;
      const originalColumn = this._sourcePosition.column;
      const originalFilename = this._sourcePosition.filename;
      const originalIdentifierName = this._sourcePosition.identifierName;
      this.source(prop, loc);
      cb();

      if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
        this._sourcePosition.line = originalLine;
        this._sourcePosition.column = originalColumn;
        this._sourcePosition.filename = originalFilename;
        this._sourcePosition.identifierName = originalIdentifierName;
        this._sourcePosition.force = false;
        this._disallowedPop = null;
      }
    }

    _disallowPop(prop, loc) {
      if (prop && !loc) return;
      this._disallowedPop = this._normalizePosition(prop, loc);
    }

    _normalizePosition(prop, loc, targetObj, force) {
      const pos = loc ? loc[prop] : null;

      if (targetObj === undefined) {
        targetObj = {
          identifierName: null,
          line: null,
          column: null,
          filename: null,
          force: false
        };
      }

      const origLine = targetObj.line;
      const origColumn = targetObj.column;
      const origFilename = targetObj.filename;
      targetObj.identifierName = prop === "start" && (loc == null ? void 0 : loc.identifierName) || null;
      targetObj.line = pos == null ? void 0 : pos.line;
      targetObj.column = pos == null ? void 0 : pos.column;
      targetObj.filename = loc == null ? void 0 : loc.filename;

      if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
        targetObj.force = force;
      }

      return targetObj;
    }

    getCurrentColumn() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, "");

      const lastIndex = extra.lastIndexOf("\n");
      return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
    }

    getCurrentLine() {
      const extra = this._queue.reduce((acc, item) => item[0] + acc, "");

      let count = 0;

      for (let i = 0; i < extra.length; i++) {
        if (extra[i] === "\n") count++;
      }

      return this._position.line + count;
    }

  }

  buffer.default = Buffer;

  var node = {};

  var whitespace$1 = {};

  Object.defineProperty(whitespace$1, "__esModule", {
    value: true
  });
  whitespace$1.list = whitespace$1.nodes = void 0;

  var t$s = lib$9;

  function crawl(node, state = {}) {
    if (t$s.isMemberExpression(node) || t$s.isOptionalMemberExpression(node)) {
      crawl(node.object, state);
      if (node.computed) crawl(node.property, state);
    } else if (t$s.isBinary(node) || t$s.isAssignmentExpression(node)) {
      crawl(node.left, state);
      crawl(node.right, state);
    } else if (t$s.isCallExpression(node) || t$s.isOptionalCallExpression(node)) {
      state.hasCall = true;
      crawl(node.callee, state);
    } else if (t$s.isFunction(node)) {
      state.hasFunction = true;
    } else if (t$s.isIdentifier(node)) {
      state.hasHelper = state.hasHelper || isHelper(node.callee);
    }

    return state;
  }

  function isHelper(node) {
    if (t$s.isMemberExpression(node)) {
      return isHelper(node.object) || isHelper(node.property);
    } else if (t$s.isIdentifier(node)) {
      return node.name === "require" || node.name[0] === "_";
    } else if (t$s.isCallExpression(node)) {
      return isHelper(node.callee);
    } else if (t$s.isBinary(node) || t$s.isAssignmentExpression(node)) {
      return t$s.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
      return false;
    }
  }

  function isType(node) {
    return t$s.isLiteral(node) || t$s.isObjectExpression(node) || t$s.isArrayExpression(node) || t$s.isIdentifier(node) || t$s.isMemberExpression(node);
  }

  const nodes = {
    AssignmentExpression(node) {
      const state = crawl(node.right);

      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return {
          before: state.hasFunction,
          after: true
        };
      }
    },

    SwitchCase(node, parent) {
      return {
        before: !!node.consequent.length || parent.cases[0] === node,
        after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
      };
    },

    LogicalExpression(node) {
      if (t$s.isFunction(node.left) || t$s.isFunction(node.right)) {
        return {
          after: true
        };
      }
    },

    Literal(node) {
      if (t$s.isStringLiteral(node) && node.value === "use strict") {
        return {
          after: true
        };
      }
    },

    CallExpression(node) {
      if (t$s.isFunction(node.callee) || isHelper(node)) {
        return {
          before: true,
          after: true
        };
      }
    },

    OptionalCallExpression(node) {
      if (t$s.isFunction(node.callee)) {
        return {
          before: true,
          after: true
        };
      }
    },

    VariableDeclaration(node) {
      for (let i = 0; i < node.declarations.length; i++) {
        const declar = node.declarations[i];
        let enabled = isHelper(declar.id) && !isType(declar.init);

        if (!enabled) {
          const state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }

        if (enabled) {
          return {
            before: true,
            after: true
          };
        }
      }
    },

    IfStatement(node) {
      if (t$s.isBlockStatement(node.consequent)) {
        return {
          before: true,
          after: true
        };
      }
    }

  };
  whitespace$1.nodes = nodes;

  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
    if (parent.properties[0] === node) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeCallProperty = function (node, parent) {
    var _parent$properties;

    if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeIndexer = function (node, parent) {
    var _parent$properties2, _parent$callPropertie;

    if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeInternalSlot = function (node, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;

    if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return {
        before: true
      };
    }
  };

  const list = {
    VariableDeclaration(node) {
      return node.declarations.map(decl => decl.init);
    },

    ArrayExpression(node) {
      return node.elements;
    },

    ObjectExpression(node) {
      return node.properties;
    }

  };
  whitespace$1.list = list;
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function ([type, amounts]) {
    if (typeof amounts === "boolean") {
      amounts = {
        after: amounts,
        before: amounts
      };
    }

    [type].concat(t$s.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
      nodes[type] = function () {
        return amounts;
      };
    });
  });

  var parentheses = {};

  Object.defineProperty(parentheses, "__esModule", {
    value: true
  });
  parentheses.NullableTypeAnnotation = NullableTypeAnnotation;
  parentheses.FunctionTypeAnnotation = FunctionTypeAnnotation;
  parentheses.UpdateExpression = UpdateExpression$1;
  parentheses.ObjectExpression = ObjectExpression$1;
  parentheses.DoExpression = DoExpression$1;
  parentheses.Binary = Binary;
  parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation;
  parentheses.OptionalIndexedAccessType = OptionalIndexedAccessType;
  parentheses.TSAsExpression = TSAsExpression$1;
  parentheses.TSTypeAssertion = TSTypeAssertion$1;
  parentheses.TSIntersectionType = parentheses.TSUnionType = TSUnionType$1;
  parentheses.TSInferType = TSInferType$1;
  parentheses.BinaryExpression = BinaryExpression;
  parentheses.SequenceExpression = SequenceExpression$1;
  parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression$1;
  parentheses.ClassExpression = ClassExpression;
  parentheses.UnaryLike = UnaryLike;
  parentheses.FunctionExpression = FunctionExpression$1;
  parentheses.ArrowFunctionExpression = ArrowFunctionExpression$1;
  parentheses.ConditionalExpression = ConditionalExpression$1;
  parentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression$1;
  parentheses.AssignmentExpression = AssignmentExpression$1;
  parentheses.LogicalExpression = LogicalExpression;
  parentheses.Identifier = Identifier$1;

  var t$r = lib$9;

  const PRECEDENCE = {
    "||": 0,
    "??": 0,
    "&&": 1,
    "|": 2,
    "^": 3,
    "&": 4,
    "==": 5,
    "===": 5,
    "!=": 5,
    "!==": 5,
    "<": 6,
    ">": 6,
    "<=": 6,
    ">=": 6,
    in: 6,
    instanceof: 6,
    ">>": 7,
    "<<": 7,
    ">>>": 7,
    "+": 8,
    "-": 8,
    "*": 9,
    "/": 9,
    "%": 9,
    "**": 10
  };

  const isClassExtendsClause = (node, parent) => (t$r.isClassDeclaration(parent) || t$r.isClassExpression(parent)) && parent.superClass === node;

  const hasPostfixPart = (node, parent) => (t$r.isMemberExpression(parent) || t$r.isOptionalMemberExpression(parent)) && parent.object === node || (t$r.isCallExpression(parent) || t$r.isOptionalCallExpression(parent) || t$r.isNewExpression(parent)) && parent.callee === node || t$r.isTaggedTemplateExpression(parent) && parent.tag === node || t$r.isTSNonNullExpression(parent);

  function NullableTypeAnnotation(node, parent) {
    return t$r.isArrayTypeAnnotation(parent);
  }

  function FunctionTypeAnnotation(node, parent, printStack) {
    return t$r.isUnionTypeAnnotation(parent) || t$r.isIntersectionTypeAnnotation(parent) || t$r.isArrayTypeAnnotation(parent) || t$r.isTypeAnnotation(parent) && t$r.isArrowFunctionExpression(printStack[printStack.length - 3]);
  }

  function UpdateExpression$1(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
  }

  function ObjectExpression$1(node, parent, printStack) {
    return isFirstInContext(printStack, {
      expressionStatement: true,
      arrowBody: true
    });
  }

  function DoExpression$1(node, parent, printStack) {
    return !node.async && isFirstInContext(printStack, {
      expressionStatement: true
    });
  }

  function Binary(node, parent) {
    if (node.operator === "**" && t$r.isBinaryExpression(parent, {
      operator: "**"
    })) {
      return parent.left === node;
    }

    if (isClassExtendsClause(node, parent)) {
      return true;
    }

    if (hasPostfixPart(node, parent) || t$r.isUnaryLike(parent) || t$r.isAwaitExpression(parent)) {
      return true;
    }

    if (t$r.isBinary(parent)) {
      const parentOp = parent.operator;
      const parentPos = PRECEDENCE[parentOp];
      const nodeOp = node.operator;
      const nodePos = PRECEDENCE[nodeOp];

      if (parentPos === nodePos && parent.right === node && !t$r.isLogicalExpression(parent) || parentPos > nodePos) {
        return true;
      }
    }
  }

  function UnionTypeAnnotation(node, parent) {
    return t$r.isArrayTypeAnnotation(parent) || t$r.isNullableTypeAnnotation(parent) || t$r.isIntersectionTypeAnnotation(parent) || t$r.isUnionTypeAnnotation(parent);
  }

  function OptionalIndexedAccessType(node, parent) {
    return t$r.isIndexedAccessType(parent, {
      objectType: node
    });
  }

  function TSAsExpression$1() {
    return true;
  }

  function TSTypeAssertion$1() {
    return true;
  }

  function TSUnionType$1(node, parent) {
    return t$r.isTSArrayType(parent) || t$r.isTSOptionalType(parent) || t$r.isTSIntersectionType(parent) || t$r.isTSUnionType(parent) || t$r.isTSRestType(parent);
  }

  function TSInferType$1(node, parent) {
    return t$r.isTSArrayType(parent) || t$r.isTSOptionalType(parent);
  }

  function BinaryExpression(node, parent) {
    return node.operator === "in" && (t$r.isVariableDeclarator(parent) || t$r.isFor(parent));
  }

  function SequenceExpression$1(node, parent) {
    if (t$r.isForStatement(parent) || t$r.isThrowStatement(parent) || t$r.isReturnStatement(parent) || t$r.isIfStatement(parent) && parent.test === node || t$r.isWhileStatement(parent) && parent.test === node || t$r.isForInStatement(parent) && parent.right === node || t$r.isSwitchStatement(parent) && parent.discriminant === node || t$r.isExpressionStatement(parent) && parent.expression === node) {
      return false;
    }

    return true;
  }

  function YieldExpression$1(node, parent) {
    return t$r.isBinary(parent) || t$r.isUnaryLike(parent) || hasPostfixPart(node, parent) || t$r.isAwaitExpression(parent) && t$r.isYieldExpression(node) || t$r.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
  }

  function ClassExpression(node, parent, printStack) {
    return isFirstInContext(printStack, {
      expressionStatement: true,
      exportDefault: true
    });
  }

  function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent) || t$r.isBinaryExpression(parent, {
      operator: "**",
      left: node
    }) || isClassExtendsClause(node, parent);
  }

  function FunctionExpression$1(node, parent, printStack) {
    return isFirstInContext(printStack, {
      expressionStatement: true,
      exportDefault: true
    });
  }

  function ArrowFunctionExpression$1(node, parent) {
    return t$r.isExportDeclaration(parent) || ConditionalExpression$1(node, parent);
  }

  function ConditionalExpression$1(node, parent) {
    if (t$r.isUnaryLike(parent) || t$r.isBinary(parent) || t$r.isConditionalExpression(parent, {
      test: node
    }) || t$r.isAwaitExpression(parent) || t$r.isTSTypeAssertion(parent) || t$r.isTSAsExpression(parent)) {
      return true;
    }

    return UnaryLike(node, parent);
  }

  function OptionalMemberExpression$1(node, parent) {
    return t$r.isCallExpression(parent, {
      callee: node
    }) || t$r.isMemberExpression(parent, {
      object: node
    });
  }

  function AssignmentExpression$1(node, parent) {
    if (t$r.isObjectPattern(node.left)) {
      return true;
    } else {
      return ConditionalExpression$1(node, parent);
    }
  }

  function LogicalExpression(node, parent) {
    switch (node.operator) {
      case "||":
        if (!t$r.isLogicalExpression(parent)) return false;
        return parent.operator === "??" || parent.operator === "&&";

      case "&&":
        return t$r.isLogicalExpression(parent, {
          operator: "??"
        });

      case "??":
        return t$r.isLogicalExpression(parent) && parent.operator !== "??";
    }
  }

  function Identifier$1(node, parent, printStack) {
    if (node.name === "let") {
      const isFollowedByBracket = t$r.isMemberExpression(parent, {
        object: node,
        computed: true
      }) || t$r.isOptionalMemberExpression(parent, {
        object: node,
        computed: true,
        optional: false
      });
      return isFirstInContext(printStack, {
        expressionStatement: isFollowedByBracket,
        forHead: isFollowedByBracket,
        forInHead: isFollowedByBracket,
        forOfHead: true
      });
    }

    return node.name === "async" && t$r.isForOfStatement(parent) && node === parent.left;
  }

  function isFirstInContext(printStack, {
    expressionStatement = false,
    arrowBody = false,
    exportDefault = false,
    forHead = false,
    forInHead = false,
    forOfHead = false
  }) {
    let i = printStack.length - 1;
    let node = printStack[i];
    i--;
    let parent = printStack[i];

    while (i >= 0) {
      if (expressionStatement && t$r.isExpressionStatement(parent, {
        expression: node
      }) || exportDefault && t$r.isExportDefaultDeclaration(parent, {
        declaration: node
      }) || arrowBody && t$r.isArrowFunctionExpression(parent, {
        body: node
      }) || forHead && t$r.isForStatement(parent, {
        init: node
      }) || forInHead && t$r.isForInStatement(parent, {
        left: node
      }) || forOfHead && t$r.isForOfStatement(parent, {
        left: node
      })) {
        return true;
      }

      if (hasPostfixPart(node, parent) && !t$r.isNewExpression(parent) || t$r.isSequenceExpression(parent) && parent.expressions[0] === node || t$r.isConditional(parent, {
        test: node
      }) || t$r.isBinary(parent, {
        left: node
      }) || t$r.isAssignmentExpression(parent, {
        left: node
      })) {
        node = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }

    return false;
  }

  Object.defineProperty(node, "__esModule", {
    value: true
  });
  node.needsWhitespace = needsWhitespace;
  node.needsWhitespaceBefore = needsWhitespaceBefore;
  node.needsWhitespaceAfter = needsWhitespaceAfter;
  node.needsParens = needsParens;

  var whitespace = whitespace$1;

  var parens = parentheses;

  var t$q = lib$9;

  function expandAliases(obj) {
    const newObj = {};

    function add(type, func) {
      const fn = newObj[type];
      newObj[type] = fn ? function (node, parent, stack) {
        const result = fn(node, parent, stack);
        return result == null ? func(node, parent, stack) : result;
      } : func;
    }

    for (const type of Object.keys(obj)) {
      const aliases = t$q.FLIPPED_ALIAS_KEYS[type];

      if (aliases) {
        for (const alias of aliases) {
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }

    return newObj;
  }

  const expandedParens = expandAliases(parens);
  const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
  const expandedWhitespaceList = expandAliases(whitespace.list);

  function find$1(obj, node, parent, printStack) {
    const fn = obj[node.type];
    return fn ? fn(node, parent, printStack) : null;
  }

  function isOrHasCallExpression(node) {
    if (t$q.isCallExpression(node)) {
      return true;
    }

    return t$q.isMemberExpression(node) && isOrHasCallExpression(node.object);
  }

  function needsWhitespace(node, parent, type) {
    if (!node) return 0;

    if (t$q.isExpressionStatement(node)) {
      node = node.expression;
    }

    let linesInfo = find$1(expandedWhitespaceNodes, node, parent);

    if (!linesInfo) {
      const items = find$1(expandedWhitespaceList, node, parent);

      if (items) {
        for (let i = 0; i < items.length; i++) {
          linesInfo = needsWhitespace(items[i], node, type);
          if (linesInfo) break;
        }
      }
    }

    if (typeof linesInfo === "object" && linesInfo !== null) {
      return linesInfo[type] || 0;
    }

    return 0;
  }

  function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, "before");
  }

  function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, "after");
  }

  function needsParens(node, parent, printStack) {
    if (!parent) return false;

    if (t$q.isNewExpression(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node)) return true;
    }

    return find$1(expandedParens, node, parent, printStack);
  }

  var generators = {};

  var templateLiterals = {};

  Object.defineProperty(templateLiterals, "__esModule", {
    value: true
  });
  templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
  templateLiterals.TemplateElement = TemplateElement;
  templateLiterals.TemplateLiteral = TemplateLiteral;

  function TaggedTemplateExpression(node) {
    this.print(node.tag, node);
    this.print(node.typeParameters, node);
    this.print(node.quasi, node);
  }

  function TemplateElement(node, parent) {
    const isFirst = parent.quasis[0] === node;
    const isLast = parent.quasis[parent.quasis.length - 1] === node;
    const value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
    this.token(value);
  }

  function TemplateLiteral(node) {
    const quasis = node.quasis;

    for (let i = 0; i < quasis.length; i++) {
      this.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        this.print(node.expressions[i], node);
      }
    }
  }

  var expressions = {};

  Object.defineProperty(expressions, "__esModule", {
    value: true
  });
  expressions.UnaryExpression = UnaryExpression;
  expressions.DoExpression = DoExpression;
  expressions.ParenthesizedExpression = ParenthesizedExpression;
  expressions.UpdateExpression = UpdateExpression;
  expressions.ConditionalExpression = ConditionalExpression;
  expressions.NewExpression = NewExpression;
  expressions.SequenceExpression = SequenceExpression;
  expressions.ThisExpression = ThisExpression;
  expressions.Super = Super;
  expressions.Decorator = Decorator;
  expressions.OptionalMemberExpression = OptionalMemberExpression;
  expressions.OptionalCallExpression = OptionalCallExpression;
  expressions.CallExpression = CallExpression;
  expressions.Import = Import;
  expressions.EmptyStatement = EmptyStatement;
  expressions.ExpressionStatement = ExpressionStatement;
  expressions.AssignmentPattern = AssignmentPattern;
  expressions.LogicalExpression = expressions.BinaryExpression = expressions.AssignmentExpression = AssignmentExpression;
  expressions.BindExpression = BindExpression;
  expressions.MemberExpression = MemberExpression;
  expressions.MetaProperty = MetaProperty;
  expressions.PrivateName = PrivateName;
  expressions.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
  expressions.ModuleExpression = ModuleExpression;
  expressions.AwaitExpression = expressions.YieldExpression = void 0;

  var t$p = lib$9;

  var n$1 = node;

  function UnaryExpression(node) {
    if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
      this.word(node.operator);
      this.space();
    } else {
      this.token(node.operator);
    }

    this.print(node.argument, node);
  }

  function DoExpression(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    this.word("do");
    this.space();
    this.print(node.body, node);
  }

  function ParenthesizedExpression(node) {
    this.token("(");
    this.print(node.expression, node);
    this.token(")");
  }

  function UpdateExpression(node) {
    if (node.prefix) {
      this.token(node.operator);
      this.print(node.argument, node);
    } else {
      this.startTerminatorless(true);
      this.print(node.argument, node);
      this.endTerminatorless();
      this.token(node.operator);
    }
  }

  function ConditionalExpression(node) {
    this.print(node.test, node);
    this.space();
    this.token("?");
    this.space();
    this.print(node.consequent, node);
    this.space();
    this.token(":");
    this.space();
    this.print(node.alternate, node);
  }

  function NewExpression(node, parent) {
    this.word("new");
    this.space();
    this.print(node.callee, node);

    if (this.format.minified && node.arguments.length === 0 && !node.optional && !t$p.isCallExpression(parent, {
      callee: node
    }) && !t$p.isMemberExpression(parent) && !t$p.isNewExpression(parent)) {
      return;
    }

    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }

  function SequenceExpression(node) {
    this.printList(node.expressions, node);
  }

  function ThisExpression() {
    this.word("this");
  }

  function Super() {
    this.word("super");
  }

  function Decorator(node) {
    this.token("@");
    this.print(node.expression, node);
    this.newline();
  }

  function OptionalMemberExpression(node) {
    this.print(node.object, node);

    if (!node.computed && t$p.isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    let computed = node.computed;

    if (t$p.isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (node.optional) {
      this.token("?.");
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      if (!node.optional) {
        this.token(".");
      }

      this.print(node.property, node);
    }
  }

  function OptionalCallExpression(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }

  function CallExpression(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }

  function Import() {
    this.word("import");
  }

  function buildYieldAwait(keyword) {
    return function (node) {
      this.word(keyword);

      if (node.delegate) {
        this.token("*");
      }

      if (node.argument) {
        this.space();
        const terminatorState = this.startTerminatorless();
        this.print(node.argument, node);
        this.endTerminatorless(terminatorState);
      }
    };
  }

  const YieldExpression = buildYieldAwait("yield");
  expressions.YieldExpression = YieldExpression;
  const AwaitExpression = buildYieldAwait("await");
  expressions.AwaitExpression = AwaitExpression;

  function EmptyStatement() {
    this.semicolon(true);
  }

  function ExpressionStatement(node) {
    this.print(node.expression, node);
    this.semicolon();
  }

  function AssignmentPattern(node) {
    this.print(node.left, node);
    if (node.left.optional) this.token("?");
    this.print(node.left.typeAnnotation, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
  }

  function AssignmentExpression(node, parent) {
    const parens = this.inForStatementInitCounter && node.operator === "in" && !n$1.needsParens(node, parent);

    if (parens) {
      this.token("(");
    }

    this.print(node.left, node);
    this.space();

    if (node.operator === "in" || node.operator === "instanceof") {
      this.word(node.operator);
    } else {
      this.token(node.operator);
    }

    this.space();
    this.print(node.right, node);

    if (parens) {
      this.token(")");
    }
  }

  function BindExpression(node) {
    this.print(node.object, node);
    this.token("::");
    this.print(node.callee, node);
  }

  function MemberExpression(node) {
    this.print(node.object, node);

    if (!node.computed && t$p.isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    let computed = node.computed;

    if (t$p.isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      this.token(".");
      this.print(node.property, node);
    }
  }

  function MetaProperty(node) {
    this.print(node.meta, node);
    this.token(".");
    this.print(node.property, node);
  }

  function PrivateName(node) {
    this.token("#");
    this.print(node.id, node);
  }

  function V8IntrinsicIdentifier(node) {
    this.token("%");
    this.word(node.name);
  }

  function ModuleExpression(node) {
    this.word("module");
    this.space();
    this.token("{");

    if (node.body.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.printSequence(node.body.body, node, {
        indent: true
      });
      this.rightBrace();
    }
  }

  var statements$2 = {};

  Object.defineProperty(statements$2, "__esModule", {
    value: true
  });
  statements$2.WithStatement = WithStatement;
  statements$2.IfStatement = IfStatement;
  statements$2.ForStatement = ForStatement;
  statements$2.WhileStatement = WhileStatement;
  statements$2.DoWhileStatement = DoWhileStatement;
  statements$2.LabeledStatement = LabeledStatement;
  statements$2.TryStatement = TryStatement;
  statements$2.CatchClause = CatchClause;
  statements$2.SwitchStatement = SwitchStatement;
  statements$2.SwitchCase = SwitchCase;
  statements$2.DebuggerStatement = DebuggerStatement;
  statements$2.VariableDeclaration = VariableDeclaration;
  statements$2.VariableDeclarator = VariableDeclarator;
  statements$2.ThrowStatement = statements$2.BreakStatement = statements$2.ReturnStatement = statements$2.ContinueStatement = statements$2.ForOfStatement = statements$2.ForInStatement = void 0;

  var t$o = lib$9;

  function WithStatement(node) {
    this.word("with");
    this.space();
    this.token("(");
    this.print(node.object, node);
    this.token(")");
    this.printBlock(node);
  }

  function IfStatement(node) {
    this.word("if");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.space();
    const needsBlock = node.alternate && t$o.isIfStatement(getLastStatement(node.consequent));

    if (needsBlock) {
      this.token("{");
      this.newline();
      this.indent();
    }

    this.printAndIndentOnComments(node.consequent, node);

    if (needsBlock) {
      this.dedent();
      this.newline();
      this.token("}");
    }

    if (node.alternate) {
      if (this.endsWith("}")) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node.alternate, node);
    }
  }

  function getLastStatement(statement) {
    if (!t$o.isStatement(statement.body)) return statement;
    return getLastStatement(statement.body);
  }

  function ForStatement(node) {
    this.word("for");
    this.space();
    this.token("(");
    this.inForStatementInitCounter++;
    this.print(node.init, node);
    this.inForStatementInitCounter--;
    this.token(";");

    if (node.test) {
      this.space();
      this.print(node.test, node);
    }

    this.token(";");

    if (node.update) {
      this.space();
      this.print(node.update, node);
    }

    this.token(")");
    this.printBlock(node);
  }

  function WhileStatement(node) {
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.printBlock(node);
  }

  const buildForXStatement = function (op) {
    return function (node) {
      this.word("for");
      this.space();

      if (op === "of" && node.await) {
        this.word("await");
        this.space();
      }

      this.token("(");
      this.print(node.left, node);
      this.space();
      this.word(op);
      this.space();
      this.print(node.right, node);
      this.token(")");
      this.printBlock(node);
    };
  };

  const ForInStatement = buildForXStatement("in");
  statements$2.ForInStatement = ForInStatement;
  const ForOfStatement = buildForXStatement("of");
  statements$2.ForOfStatement = ForOfStatement;

  function DoWhileStatement(node) {
    this.word("do");
    this.space();
    this.print(node.body, node);
    this.space();
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.semicolon();
  }

  function buildLabelStatement(prefix, key = "label") {
    return function (node) {
      this.word(prefix);
      const label = node[key];

      if (label) {
        this.space();
        const isLabel = key == "label";
        const terminatorState = this.startTerminatorless(isLabel);
        this.print(label, node);
        this.endTerminatorless(terminatorState);
      }

      this.semicolon();
    };
  }

  const ContinueStatement = buildLabelStatement("continue");
  statements$2.ContinueStatement = ContinueStatement;
  const ReturnStatement = buildLabelStatement("return", "argument");
  statements$2.ReturnStatement = ReturnStatement;
  const BreakStatement = buildLabelStatement("break");
  statements$2.BreakStatement = BreakStatement;
  const ThrowStatement = buildLabelStatement("throw", "argument");
  statements$2.ThrowStatement = ThrowStatement;

  function LabeledStatement(node) {
    this.print(node.label, node);
    this.token(":");
    this.space();
    this.print(node.body, node);
  }

  function TryStatement(node) {
    this.word("try");
    this.space();
    this.print(node.block, node);
    this.space();

    if (node.handlers) {
      this.print(node.handlers[0], node);
    } else {
      this.print(node.handler, node);
    }

    if (node.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node.finalizer, node);
    }
  }

  function CatchClause(node) {
    this.word("catch");
    this.space();

    if (node.param) {
      this.token("(");
      this.print(node.param, node);
      this.print(node.param.typeAnnotation, node);
      this.token(")");
      this.space();
    }

    this.print(node.body, node);
  }

  function SwitchStatement(node) {
    this.word("switch");
    this.space();
    this.token("(");
    this.print(node.discriminant, node);
    this.token(")");
    this.space();
    this.token("{");
    this.printSequence(node.cases, node, {
      indent: true,

      addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      }

    });
    this.token("}");
  }

  function SwitchCase(node) {
    if (node.test) {
      this.word("case");
      this.space();
      this.print(node.test, node);
      this.token(":");
    } else {
      this.word("default");
      this.token(":");
    }

    if (node.consequent.length) {
      this.newline();
      this.printSequence(node.consequent, node, {
        indent: true
      });
    }
  }

  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }

  function variableDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (let i = 0; i < 4; i++) this.space(true);
  }

  function constDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (let i = 0; i < 6; i++) this.space(true);
  }

  function VariableDeclaration(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this.word(node.kind);
    this.space();
    let hasInits = false;

    if (!t$o.isFor(parent)) {
      for (const declar of node.declarations) {
        if (declar.init) {
          hasInits = true;
        }
      }
    }

    let separator;

    if (hasInits) {
      separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
    }

    this.printList(node.declarations, node, {
      separator
    });

    if (t$o.isFor(parent)) {
      if (t$o.isForStatement(parent)) {
        if (parent.init === node) return;
      } else {
        if (parent.left === node) return;
      }
    }

    this.semicolon();
  }

  function VariableDeclarator(node) {
    this.print(node.id, node);
    if (node.definite) this.token("!");
    this.print(node.id.typeAnnotation, node);

    if (node.init) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.init, node);
    }
  }

  var classes = {};

  Object.defineProperty(classes, "__esModule", {
    value: true
  });
  classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
  classes.ClassBody = ClassBody;
  classes.ClassProperty = ClassProperty;
  classes.ClassPrivateProperty = ClassPrivateProperty;
  classes.ClassMethod = ClassMethod;
  classes.ClassPrivateMethod = ClassPrivateMethod;
  classes._classMethodHead = _classMethodHead;
  classes.StaticBlock = StaticBlock;

  var t$n = lib$9;

  function ClassDeclaration(node, parent) {
    if (!this.format.decoratorsBeforeExport || !t$n.isExportDefaultDeclaration(parent) && !t$n.isExportNamedDeclaration(parent)) {
      this.printJoin(node.decorators, node);
    }

    if (node.declare) {
      this.word("declare");
      this.space();
    }

    if (node.abstract) {
      this.word("abstract");
      this.space();
    }

    this.word("class");

    if (node.id) {
      this.space();
      this.print(node.id, node);
    }

    this.print(node.typeParameters, node);

    if (node.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.superClass, node);
      this.print(node.superTypeParameters, node);
    }

    if (node.implements) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node.implements, node);
    }

    this.space();
    this.print(node.body, node);
  }

  function ClassBody(node) {
    this.token("{");
    this.printInnerComments(node);

    if (node.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.indent();
      this.printSequence(node.body, node);
      this.dedent();
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    }
  }

  function ClassProperty(node) {
    this.printJoin(node.decorators, node);
    this.source("end", node.key.loc);
    this.tsPrintClassMemberModifiers(node, true);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      this._variance(node);

      this.print(node.key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    if (node.definite) {
      this.token("!");
    }

    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }

  function ClassPrivateProperty(node) {
    this.printJoin(node.decorators, node);

    if (node.static) {
      this.word("static");
      this.space();
    }

    this.print(node.key, node);
    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }

  function ClassMethod(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }

  function ClassPrivateMethod(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }

  function _classMethodHead(node) {
    this.printJoin(node.decorators, node);
    this.source("end", node.key.loc);
    this.tsPrintClassMemberModifiers(node, false);

    this._methodHead(node);
  }

  function StaticBlock(node) {
    this.word("static");
    this.space();
    this.token("{");

    if (node.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.printSequence(node.body, node, {
        indent: true
      });
      this.rightBrace();
    }
  }

  var methods = {};

  Object.defineProperty(methods, "__esModule", {
    value: true
  });
  methods._params = _params;
  methods._parameters = _parameters;
  methods._param = _param;
  methods._methodHead = _methodHead;
  methods._predicate = _predicate;
  methods._functionHead = _functionHead;
  methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
  methods.ArrowFunctionExpression = ArrowFunctionExpression;

  var t$m = lib$9;

  function _params(node) {
    this.print(node.typeParameters, node);
    this.token("(");

    this._parameters(node.params, node);

    this.token(")");
    this.print(node.returnType, node);
  }

  function _parameters(parameters, parent) {
    for (let i = 0; i < parameters.length; i++) {
      this._param(parameters[i], parent);

      if (i < parameters.length - 1) {
        this.token(",");
        this.space();
      }
    }
  }

  function _param(parameter, parent) {
    this.printJoin(parameter.decorators, parameter);
    this.print(parameter, parent);
    if (parameter.optional) this.token("?");
    this.print(parameter.typeAnnotation, parameter);
  }

  function _methodHead(node) {
    const kind = node.kind;
    const key = node.key;

    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }

    if (node.async) {
      this._catchUp("start", key.loc);

      this.word("async");
      this.space();
    }

    if (kind === "method" || kind === "init") {
      if (node.generator) {
        this.token("*");
      }
    }

    if (node.computed) {
      this.token("[");
      this.print(key, node);
      this.token("]");
    } else {
      this.print(key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    this._params(node);
  }

  function _predicate(node) {
    if (node.predicate) {
      if (!node.returnType) {
        this.token(":");
      }

      this.space();
      this.print(node.predicate, node);
    }
  }

  function _functionHead(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    this.word("function");
    if (node.generator) this.token("*");
    this.space();

    if (node.id) {
      this.print(node.id, node);
    }

    this._params(node);

    this._predicate(node);
  }

  function FunctionExpression(node) {
    this._functionHead(node);

    this.space();
    this.print(node.body, node);
  }

  function ArrowFunctionExpression(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    const firstParam = node.params[0];

    if (!this.format.retainLines && !this.format.auxiliaryCommentBefore && !this.format.auxiliaryCommentAfter && node.params.length === 1 && t$m.isIdentifier(firstParam) && !hasTypesOrComments(node, firstParam)) {
      this.print(firstParam, node);
    } else {
      this._params(node);
    }

    this._predicate(node);

    this.space();
    this.token("=>");
    this.space();
    this.print(node.body, node);
  }

  function hasTypesOrComments(node, param) {
    var _param$leadingComment, _param$trailingCommen;

    return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
  }

  var modules = {};

  Object.defineProperty(modules, "__esModule", {
    value: true
  });
  modules.ImportSpecifier = ImportSpecifier;
  modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
  modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
  modules.ExportSpecifier = ExportSpecifier;
  modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
  modules.ExportAllDeclaration = ExportAllDeclaration;
  modules.ExportNamedDeclaration = ExportNamedDeclaration;
  modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
  modules.ImportDeclaration = ImportDeclaration;
  modules.ImportAttribute = ImportAttribute;
  modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;

  var t$l = lib$9;

  function ImportSpecifier(node) {
    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    this.print(node.imported, node);

    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.local, node);
    }
  }

  function ImportDefaultSpecifier(node) {
    this.print(node.local, node);
  }

  function ExportDefaultSpecifier(node) {
    this.print(node.exported, node);
  }

  function ExportSpecifier(node) {
    this.print(node.local, node);

    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported, node);
    }
  }

  function ExportNamespaceSpecifier(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }

  function ExportAllDeclaration(node) {
    this.word("export");
    this.space();

    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    this.token("*");
    this.space();
    this.word("from");
    this.space();
    this.print(node.source, node);
    this.printAssertions(node);
    this.semicolon();
  }

  function ExportNamedDeclaration(node) {
    if (this.format.decoratorsBeforeExport && t$l.isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }

  function ExportDefaultDeclaration(node) {
    if (this.format.decoratorsBeforeExport && t$l.isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    this.word("default");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }

  function ExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar, node);
      if (!t$l.isStatement(declar)) this.semicolon();
    } else {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }

      const specifiers = node.specifiers.slice(0);
      let hasSpecial = false;

      for (;;) {
        const first = specifiers[0];

        if (t$l.isExportDefaultSpecifier(first) || t$l.isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length || !specifiers.length && !hasSpecial) {
        this.token("{");

        if (specifiers.length) {
          this.space();
          this.printList(specifiers, node);
          this.space();
        }

        this.token("}");
      }

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
        this.printAssertions(node);
      }

      this.semicolon();
    }
  }

  function ImportDeclaration(node) {
    this.word("import");
    this.space();

    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    const specifiers = node.specifiers.slice(0);

    if (specifiers != null && specifiers.length) {
      for (;;) {
        const first = specifiers[0];

        if (t$l.isImportDefaultSpecifier(first) || t$l.isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length) {
        this.token("{");
        this.space();
        this.printList(specifiers, node);
        this.space();
        this.token("}");
      }

      this.space();
      this.word("from");
      this.space();
    }

    this.print(node.source, node);
    this.printAssertions(node);
    {
      var _node$attributes;

      if ((_node$attributes = node.attributes) != null && _node$attributes.length) {
        this.space();
        this.word("with");
        this.space();
        this.printList(node.attributes, node);
      }
    }
    this.semicolon();
  }

  function ImportAttribute(node) {
    this.print(node.key);
    this.token(":");
    this.space();
    this.print(node.value);
  }

  function ImportNamespaceSpecifier(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }

  var types = {};

  const object = {};
  const hasOwnProperty = object.hasOwnProperty;
  const forOwn = (object, callback) => {
  	for (const key in object) {
  		if (hasOwnProperty.call(object, key)) {
  			callback(key, object[key]);
  		}
  	}
  };

  const extend = (destination, source) => {
  	if (!source) {
  		return destination;
  	}
  	forOwn(source, (key, value) => {
  		destination[key] = value;
  	});
  	return destination;
  };

  const forEach = (array, callback) => {
  	const length = array.length;
  	let index = -1;
  	while (++index < length) {
  		callback(array[index]);
  	}
  };

  const toString = object.toString;
  const isArray = Array.isArray;
  const isBuffer = Buffer$1.isBuffer;
  const isObject = (value) => {
  	// This is a very simple check, but it’s good enough for what we need.
  	return toString.call(value) == '[object Object]';
  };
  const isString = (value) => {
  	return typeof value == 'string' ||
  		toString.call(value) == '[object String]';
  };
  const isNumber = (value) => {
  	return typeof value == 'number' ||
  		toString.call(value) == '[object Number]';
  };
  const isFunction = (value) => {
  	return typeof value == 'function';
  };
  const isMap = (value) => {
  	return toString.call(value) == '[object Map]';
  };
  const isSet = (value) => {
  	return toString.call(value) == '[object Set]';
  };

  /*--------------------------------------------------------------------------*/

  // https://mathiasbynens.be/notes/javascript-escapes#single
  const singleEscapes = {
  	'"': '\\"',
  	'\'': '\\\'',
  	'\\': '\\\\',
  	'\b': '\\b',
  	'\f': '\\f',
  	'\n': '\\n',
  	'\r': '\\r',
  	'\t': '\\t'
  	// `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
  	// '\v': '\\x0B'
  };
  const regexSingleEscape = /["'\\\b\f\n\r\t]/;

  const regexDigit = /[0-9]/;
  const regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

  const jsesc = (argument, options) => {
  	const increaseIndentation = () => {
  		oldIndent = indent;
  		++options.indentLevel;
  		indent = options.indent.repeat(options.indentLevel);
  	};
  	// Handle options
  	const defaults = {
  		'escapeEverything': false,
  		'minimal': false,
  		'isScriptContext': false,
  		'quotes': 'single',
  		'wrap': false,
  		'es6': false,
  		'json': false,
  		'compact': true,
  		'lowercaseHex': false,
  		'numbers': 'decimal',
  		'indent': '\t',
  		'indentLevel': 0,
  		'__inline1__': false,
  		'__inline2__': false
  	};
  	const json = options && options.json;
  	if (json) {
  		defaults.quotes = 'double';
  		defaults.wrap = true;
  	}
  	options = extend(defaults, options);
  	if (
  		options.quotes != 'single' &&
  		options.quotes != 'double' &&
  		options.quotes != 'backtick'
  	) {
  		options.quotes = 'single';
  	}
  	const quote = options.quotes == 'double' ?
  		'"' :
  		(options.quotes == 'backtick' ?
  			'`' :
  			'\''
  		);
  	const compact = options.compact;
  	const lowercaseHex = options.lowercaseHex;
  	let indent = options.indent.repeat(options.indentLevel);
  	let oldIndent = '';
  	const inline1 = options.__inline1__;
  	const inline2 = options.__inline2__;
  	const newLine = compact ? '' : '\n';
  	let result;
  	let isEmpty = true;
  	const useBinNumbers = options.numbers == 'binary';
  	const useOctNumbers = options.numbers == 'octal';
  	const useDecNumbers = options.numbers == 'decimal';
  	const useHexNumbers = options.numbers == 'hexadecimal';

  	if (json && argument && isFunction(argument.toJSON)) {
  		argument = argument.toJSON();
  	}

  	if (!isString(argument)) {
  		if (isMap(argument)) {
  			if (argument.size == 0) {
  				return 'new Map()';
  			}
  			if (!compact) {
  				options.__inline1__ = true;
  				options.__inline2__ = false;
  			}
  			return 'new Map(' + jsesc(Array.from(argument), options) + ')';
  		}
  		if (isSet(argument)) {
  			if (argument.size == 0) {
  				return 'new Set()';
  			}
  			return 'new Set(' + jsesc(Array.from(argument), options) + ')';
  		}
  		if (isBuffer(argument)) {
  			if (argument.length == 0) {
  				return 'Buffer.from([])';
  			}
  			return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
  		}
  		if (isArray(argument)) {
  			result = [];
  			options.wrap = true;
  			if (inline1) {
  				options.__inline1__ = false;
  				options.__inline2__ = true;
  			}
  			if (!inline2) {
  				increaseIndentation();
  			}
  			forEach(argument, (value) => {
  				isEmpty = false;
  				if (inline2) {
  					options.__inline2__ = false;
  				}
  				result.push(
  					(compact || inline2 ? '' : indent) +
  					jsesc(value, options)
  				);
  			});
  			if (isEmpty) {
  				return '[]';
  			}
  			if (inline2) {
  				return '[' + result.join(', ') + ']';
  			}
  			return '[' + newLine + result.join(',' + newLine) + newLine +
  				(compact ? '' : oldIndent) + ']';
  		} else if (isNumber(argument)) {
  			if (json) {
  				// Some number values (e.g. `Infinity`) cannot be represented in JSON.
  				return JSON.stringify(argument);
  			}
  			if (useDecNumbers) {
  				return String(argument);
  			}
  			if (useHexNumbers) {
  				let hexadecimal = argument.toString(16);
  				if (!lowercaseHex) {
  					hexadecimal = hexadecimal.toUpperCase();
  				}
  				return '0x' + hexadecimal;
  			}
  			if (useBinNumbers) {
  				return '0b' + argument.toString(2);
  			}
  			if (useOctNumbers) {
  				return '0o' + argument.toString(8);
  			}
  		} else if (!isObject(argument)) {
  			if (json) {
  				// For some values (e.g. `undefined`, `function` objects),
  				// `JSON.stringify(value)` returns `undefined` (which isn’t valid
  				// JSON) instead of `'null'`.
  				return JSON.stringify(argument) || 'null';
  			}
  			return String(argument);
  		} else { // it’s an object
  			result = [];
  			options.wrap = true;
  			increaseIndentation();
  			forOwn(argument, (key, value) => {
  				isEmpty = false;
  				result.push(
  					(compact ? '' : indent) +
  					jsesc(key, options) + ':' +
  					(compact ? '' : ' ') +
  					jsesc(value, options)
  				);
  			});
  			if (isEmpty) {
  				return '{}';
  			}
  			return '{' + newLine + result.join(',' + newLine) + newLine +
  				(compact ? '' : oldIndent) + '}';
  		}
  	}

  	const string = argument;
  	// Loop over each code unit in the string and escape it
  	let index = -1;
  	const length = string.length;
  	result = '';
  	while (++index < length) {
  		const character = string.charAt(index);
  		if (options.es6) {
  			const first = string.charCodeAt(index);
  			if ( // check if it’s the start of a surrogate pair
  				first >= 0xD800 && first <= 0xDBFF && // high surrogate
  				length > index + 1 // there is a next code unit
  			) {
  				const second = string.charCodeAt(index + 1);
  				if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
  					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  					const codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
  					let hexadecimal = codePoint.toString(16);
  					if (!lowercaseHex) {
  						hexadecimal = hexadecimal.toUpperCase();
  					}
  					result += '\\u{' + hexadecimal + '}';
  					++index;
  					continue;
  				}
  			}
  		}
  		if (!options.escapeEverything) {
  			if (regexWhitelist.test(character)) {
  				// It’s a printable ASCII character that is not `"`, `'` or `\`,
  				// so don’t escape it.
  				result += character;
  				continue;
  			}
  			if (character == '"') {
  				result += quote == character ? '\\"' : character;
  				continue;
  			}
  			if (character == '`') {
  				result += quote == character ? '\\`' : character;
  				continue;
  			}
  			if (character == '\'') {
  				result += quote == character ? '\\\'' : character;
  				continue;
  			}
  		}
  		if (
  			character == '\0' &&
  			!json &&
  			!regexDigit.test(string.charAt(index + 1))
  		) {
  			result += '\\0';
  			continue;
  		}
  		if (regexSingleEscape.test(character)) {
  			// no need for a `hasOwnProperty` check here
  			result += singleEscapes[character];
  			continue;
  		}
  		const charCode = character.charCodeAt(0);
  		if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
  			result += character;
  			continue;
  		}
  		let hexadecimal = charCode.toString(16);
  		if (!lowercaseHex) {
  			hexadecimal = hexadecimal.toUpperCase();
  		}
  		const longhand = hexadecimal.length > 2 || json;
  		const escaped = '\\' + (longhand ? 'u' : 'x') +
  			('0000' + hexadecimal).slice(longhand ? -4 : -2);
  		result += escaped;
  		continue;
  	}
  	if (options.wrap) {
  		result = quote + result + quote;
  	}
  	if (quote == '`') {
  		result = result.replace(/\$\{/g, '\\\$\{');
  	}
  	if (options.isScriptContext) {
  		// https://mathiasbynens.be/notes/etago
  		return result
  			.replace(/<\/(script|style)/gi, '<\\/$1')
  			.replace(/<!--/g, json ? '\\u003C!--' : '\\x3C!--');
  	}
  	return result;
  };

  jsesc.version = '2.5.2';

  var jsesc_1 = jsesc;

  Object.defineProperty(types, "__esModule", {
    value: true
  });
  types.Identifier = Identifier;
  types.ArgumentPlaceholder = ArgumentPlaceholder;
  types.SpreadElement = types.RestElement = RestElement;
  types.ObjectPattern = types.ObjectExpression = ObjectExpression;
  types.ObjectMethod = ObjectMethod;
  types.ObjectProperty = ObjectProperty;
  types.ArrayPattern = types.ArrayExpression = ArrayExpression;
  types.RecordExpression = RecordExpression;
  types.TupleExpression = TupleExpression;
  types.RegExpLiteral = RegExpLiteral;
  types.BooleanLiteral = BooleanLiteral;
  types.NullLiteral = NullLiteral;
  types.NumericLiteral = NumericLiteral;
  types.StringLiteral = StringLiteral;
  types.BigIntLiteral = BigIntLiteral;
  types.DecimalLiteral = DecimalLiteral;
  types.PipelineTopicExpression = PipelineTopicExpression;
  types.PipelineBareFunction = PipelineBareFunction;
  types.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;

  var t$k = lib$9;

  var _jsesc = jsesc_1;

  function Identifier(node) {
    this.exactSource(node.loc, () => {
      this.word(node.name);
    });
  }

  function ArgumentPlaceholder() {
    this.token("?");
  }

  function RestElement(node) {
    this.token("...");
    this.print(node.argument, node);
  }

  function ObjectExpression(node) {
    const props = node.properties;
    this.token("{");
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token("}");
  }

  function ObjectMethod(node) {
    this.printJoin(node.decorators, node);

    this._methodHead(node);

    this.space();
    this.print(node.body, node);
  }

  function ObjectProperty(node) {
    this.printJoin(node.decorators, node);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      if (t$k.isAssignmentPattern(node.value) && t$k.isIdentifier(node.key) && node.key.name === node.value.left.name) {
        this.print(node.value, node);
        return;
      }

      this.print(node.key, node);

      if (node.shorthand && t$k.isIdentifier(node.key) && t$k.isIdentifier(node.value) && node.key.name === node.value.name) {
        return;
      }
    }

    this.token(":");
    this.space();
    this.print(node.value, node);
  }

  function ArrayExpression(node) {
    const elems = node.elements;
    const len = elems.length;
    this.token("[");
    this.printInnerComments(node);

    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      } else {
        this.token(",");
      }
    }

    this.token("]");
  }

  function RecordExpression(node) {
    const props = node.properties;
    let startToken;
    let endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "{|";
      endToken = "|}";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#{";
      endToken = "}";
    } else {
      throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
    }

    this.token(startToken);
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token(endToken);
  }

  function TupleExpression(node) {
    const elems = node.elements;
    const len = elems.length;
    let startToken;
    let endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "[|";
      endToken = "|]";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#[";
      endToken = "]";
    } else {
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    }

    this.token(startToken);
    this.printInnerComments(node);

    for (let i = 0; i < elems.length; i++) {
      const elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      }
    }

    this.token(endToken);
  }

  function RegExpLiteral(node) {
    this.word(`/${node.pattern}/${node.flags}`);
  }

  function BooleanLiteral(node) {
    this.word(node.value ? "true" : "false");
  }

  function NullLiteral() {
    this.word("null");
  }

  function NumericLiteral(node) {
    const raw = this.getPossibleRaw(node);
    const opts = this.format.jsescOption;
    const value = node.value + "";

    if (opts.numbers) {
      this.number(_jsesc(node.value, opts));
    } else if (raw == null) {
      this.number(value);
    } else if (this.format.minified) {
      this.number(raw.length < value.length ? raw : value);
    } else {
      this.number(raw);
    }
  }

  function StringLiteral(node) {
    const raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.token(raw);
      return;
    }

    const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
      json: true
    }));

    return this.token(val);
  }

  function BigIntLiteral(node) {
    const raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.word(raw);
      return;
    }

    this.word(node.value + "n");
  }

  function DecimalLiteral(node) {
    const raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.word(raw);
      return;
    }

    this.word(node.value + "m");
  }

  function PipelineTopicExpression(node) {
    this.print(node.expression, node);
  }

  function PipelineBareFunction(node) {
    this.print(node.callee, node);
  }

  function PipelinePrimaryTopicReference() {
    this.token("#");
  }

  var flow = {};

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AnyTypeAnnotation = AnyTypeAnnotation;
  exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
  exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
  exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
  exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
  exports.DeclareClass = DeclareClass;
  exports.DeclareFunction = DeclareFunction;
  exports.InferredPredicate = InferredPredicate;
  exports.DeclaredPredicate = DeclaredPredicate;
  exports.DeclareInterface = DeclareInterface;
  exports.DeclareModule = DeclareModule;
  exports.DeclareModuleExports = DeclareModuleExports;
  exports.DeclareTypeAlias = DeclareTypeAlias;
  exports.DeclareOpaqueType = DeclareOpaqueType;
  exports.DeclareVariable = DeclareVariable;
  exports.DeclareExportDeclaration = DeclareExportDeclaration;
  exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
  exports.EnumDeclaration = EnumDeclaration;
  exports.EnumBooleanBody = EnumBooleanBody;
  exports.EnumNumberBody = EnumNumberBody;
  exports.EnumStringBody = EnumStringBody;
  exports.EnumSymbolBody = EnumSymbolBody;
  exports.EnumDefaultedMember = EnumDefaultedMember;
  exports.EnumBooleanMember = EnumBooleanMember;
  exports.EnumNumberMember = EnumNumberMember;
  exports.EnumStringMember = EnumStringMember;
  exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
  exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
  exports.FunctionTypeParam = FunctionTypeParam;
  exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
  exports._interfaceish = _interfaceish;
  exports._variance = _variance;
  exports.InterfaceDeclaration = InterfaceDeclaration;
  exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
  exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
  exports.MixedTypeAnnotation = MixedTypeAnnotation;
  exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
  exports.NullableTypeAnnotation = NullableTypeAnnotation;
  exports.NumberTypeAnnotation = NumberTypeAnnotation;
  exports.StringTypeAnnotation = StringTypeAnnotation;
  exports.ThisTypeAnnotation = ThisTypeAnnotation;
  exports.TupleTypeAnnotation = TupleTypeAnnotation;
  exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
  exports.TypeAlias = TypeAlias;
  exports.TypeAnnotation = TypeAnnotation;
  exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
  exports.TypeParameter = TypeParameter;
  exports.OpaqueType = OpaqueType;
  exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
  exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
  exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
  exports.ObjectTypeIndexer = ObjectTypeIndexer;
  exports.ObjectTypeProperty = ObjectTypeProperty;
  exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
  exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
  exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
  exports.UnionTypeAnnotation = UnionTypeAnnotation;
  exports.TypeCastExpression = TypeCastExpression;
  exports.Variance = Variance;
  exports.VoidTypeAnnotation = VoidTypeAnnotation;
  exports.IndexedAccessType = IndexedAccessType;
  exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
  Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _types2.NumericLiteral;
    }
  });
  Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
    enumerable: true,
    get: function () {
      return _types2.StringLiteral;
    }
  });

  var t = lib$9;

  var _modules = modules;

  var _types2 = types;

  function AnyTypeAnnotation() {
    this.word("any");
  }

  function ArrayTypeAnnotation(node) {
    this.print(node.elementType, node);
    this.token("[");
    this.token("]");
  }

  function BooleanTypeAnnotation() {
    this.word("boolean");
  }

  function BooleanLiteralTypeAnnotation(node) {
    this.word(node.value ? "true" : "false");
  }

  function NullLiteralTypeAnnotation() {
    this.word("null");
  }

  function DeclareClass(node, parent) {
    if (!t.isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("class");
    this.space();

    this._interfaceish(node);
  }

  function DeclareFunction(node, parent) {
    if (!t.isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("function");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation.typeAnnotation, node);

    if (node.predicate) {
      this.space();
      this.print(node.predicate, node);
    }

    this.semicolon();
  }

  function InferredPredicate() {
    this.token("%");
    this.word("checks");
  }

  function DeclaredPredicate(node) {
    this.token("%");
    this.word("checks");
    this.token("(");
    this.print(node.value, node);
    this.token(")");
  }

  function DeclareInterface(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }

  function DeclareModule(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id, node);
    this.space();
    this.print(node.body, node);
  }

  function DeclareModuleExports(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.token(".");
    this.word("exports");
    this.print(node.typeAnnotation, node);
  }

  function DeclareTypeAlias(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }

  function DeclareOpaqueType(node, parent) {
    if (!t.isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.OpaqueType(node);
  }

  function DeclareVariable(node, parent) {
    if (!t.isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("var");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation, node);
    this.semicolon();
  }

  function DeclareExportDeclaration(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();

    if (node.default) {
      this.word("default");
      this.space();
    }

    FlowExportDeclaration.apply(this, arguments);
  }

  function DeclareExportAllDeclaration() {
    this.word("declare");
    this.space();

    _modules.ExportAllDeclaration.apply(this, arguments);
  }

  function EnumDeclaration(node) {
    const {
      id,
      body
    } = node;
    this.word("enum");
    this.space();
    this.print(id, node);
    this.print(body, node);
  }

  function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
      context.space();
      context.word("of");
      context.space();
      context.word(name);
    }

    context.space();
  }

  function enumBody(context, node) {
    const {
      members
    } = node;
    context.token("{");
    context.indent();
    context.newline();

    for (const member of members) {
      context.print(member, node);
      context.newline();
    }

    if (node.hasUnknownMembers) {
      context.token("...");
      context.newline();
    }

    context.dedent();
    context.token("}");
  }

  function EnumBooleanBody(node) {
    const {
      explicitType
    } = node;
    enumExplicitType(this, "boolean", explicitType);
    enumBody(this, node);
  }

  function EnumNumberBody(node) {
    const {
      explicitType
    } = node;
    enumExplicitType(this, "number", explicitType);
    enumBody(this, node);
  }

  function EnumStringBody(node) {
    const {
      explicitType
    } = node;
    enumExplicitType(this, "string", explicitType);
    enumBody(this, node);
  }

  function EnumSymbolBody(node) {
    enumExplicitType(this, "symbol", true);
    enumBody(this, node);
  }

  function EnumDefaultedMember(node) {
    const {
      id
    } = node;
    this.print(id, node);
    this.token(",");
  }

  function enumInitializedMember(context, node) {
    const {
      id,
      init
    } = node;
    context.print(id, node);
    context.space();
    context.token("=");
    context.space();
    context.print(init, node);
    context.token(",");
  }

  function EnumBooleanMember(node) {
    enumInitializedMember(this, node);
  }

  function EnumNumberMember(node) {
    enumInitializedMember(this, node);
  }

  function EnumStringMember(node) {
    enumInitializedMember(this, node);
  }

  function FlowExportDeclaration(node) {
    if (node.declaration) {
      const declar = node.declaration;
      this.print(declar, node);
      if (!t.isStatement(declar)) this.semicolon();
    } else {
      this.token("{");

      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers, node);
        this.space();
      }

      this.token("}");

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
      }

      this.semicolon();
    }
  }

  function ExistsTypeAnnotation() {
    this.token("*");
  }

  function FunctionTypeAnnotation(node, parent) {
    this.print(node.typeParameters, node);
    this.token("(");

    if (node.this) {
      this.word("this");
      this.token(":");
      this.space();
      this.print(node.this.typeAnnotation, node);

      if (node.params.length || node.rest) {
        this.token(",");
        this.space();
      }
    }

    this.printList(node.params, node);

    if (node.rest) {
      if (node.params.length) {
        this.token(",");
        this.space();
      }

      this.token("...");
      this.print(node.rest, node);
    }

    this.token(")");

    if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
      this.token(":");
    } else {
      this.space();
      this.token("=>");
    }

    this.space();
    this.print(node.returnType, node);
  }

  function FunctionTypeParam(node) {
    this.print(node.name, node);
    if (node.optional) this.token("?");

    if (node.name) {
      this.token(":");
      this.space();
    }

    this.print(node.typeAnnotation, node);
  }

  function InterfaceExtends(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
  }

  function _interfaceish(node) {
    var _node$extends;

    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if ((_node$extends = node.extends) != null && _node$extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends, node);
    }

    if (node.mixins && node.mixins.length) {
      this.space();
      this.word("mixins");
      this.space();
      this.printList(node.mixins, node);
    }

    if (node.implements && node.implements.length) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node.implements, node);
    }

    this.space();
    this.print(node.body, node);
  }

  function _variance(node) {
    if (node.variance) {
      if (node.variance.kind === "plus") {
        this.token("+");
      } else if (node.variance.kind === "minus") {
        this.token("-");
      }
    }
  }

  function InterfaceDeclaration(node) {
    this.word("interface");
    this.space();

    this._interfaceish(node);
  }

  function andSeparator() {
    this.space();
    this.token("&");
    this.space();
  }

  function InterfaceTypeAnnotation(node) {
    this.word("interface");

    if (node.extends && node.extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node.extends, node);
    }

    this.space();
    this.print(node.body, node);
  }

  function IntersectionTypeAnnotation(node) {
    this.printJoin(node.types, node, {
      separator: andSeparator
    });
  }

  function MixedTypeAnnotation() {
    this.word("mixed");
  }

  function EmptyTypeAnnotation() {
    this.word("empty");
  }

  function NullableTypeAnnotation(node) {
    this.token("?");
    this.print(node.typeAnnotation, node);
  }

  function NumberTypeAnnotation() {
    this.word("number");
  }

  function StringTypeAnnotation() {
    this.word("string");
  }

  function ThisTypeAnnotation() {
    this.word("this");
  }

  function TupleTypeAnnotation(node) {
    this.token("[");
    this.printList(node.types, node);
    this.token("]");
  }

  function TypeofTypeAnnotation(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument, node);
  }

  function TypeAlias(node) {
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
    this.semicolon();
  }

  function TypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }

  function TypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }

  function TypeParameter(node) {
    this._variance(node);

    this.word(node.name);

    if (node.bound) {
      this.print(node.bound, node);
    }

    if (node.default) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.default, node);
    }
  }

  function OpaqueType(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if (node.supertype) {
      this.token(":");
      this.space();
      this.print(node.supertype, node);
    }

    if (node.impltype) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.impltype, node);
    }

    this.semicolon();
  }

  function ObjectTypeAnnotation(node) {
    if (node.exact) {
      this.token("{|");
    } else {
      this.token("{");
    }

    const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];

    if (props.length) {
      this.space();
      this.printJoin(props, node, {
        addNewlines(leading) {
          if (leading && !props[0]) return 1;
        },

        indent: true,
        statement: true,
        iterator: () => {
          if (props.length !== 1 || node.inexact) {
            this.token(",");
            this.space();
          }
        }
      });
      this.space();
    }

    if (node.inexact) {
      this.indent();
      this.token("...");

      if (props.length) {
        this.newline();
      }

      this.dedent();
    }

    if (node.exact) {
      this.token("|}");
    } else {
      this.token("}");
    }
  }

  function ObjectTypeInternalSlot(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }

    this.token("[");
    this.token("[");
    this.print(node.id, node);
    this.token("]");
    this.token("]");
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }

  function ObjectTypeCallProperty(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }

    this.print(node.value, node);
  }

  function ObjectTypeIndexer(node) {
    if (node.static) {
      this.word("static");
      this.space();
    }

    this._variance(node);

    this.token("[");

    if (node.id) {
      this.print(node.id, node);
      this.token(":");
      this.space();
    }

    this.print(node.key, node);
    this.token("]");
    this.token(":");
    this.space();
    this.print(node.value, node);
  }

  function ObjectTypeProperty(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }

    if (node.static) {
      this.word("static");
      this.space();
    }

    if (node.kind === "get" || node.kind === "set") {
      this.word(node.kind);
      this.space();
    }

    this._variance(node);

    this.print(node.key, node);
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }

  function ObjectTypeSpreadProperty(node) {
    this.token("...");
    this.print(node.argument, node);
  }

  function QualifiedTypeIdentifier(node) {
    this.print(node.qualification, node);
    this.token(".");
    this.print(node.id, node);
  }

  function SymbolTypeAnnotation() {
    this.word("symbol");
  }

  function orSeparator() {
    this.space();
    this.token("|");
    this.space();
  }

  function UnionTypeAnnotation(node) {
    this.printJoin(node.types, node, {
      separator: orSeparator
    });
  }

  function TypeCastExpression(node) {
    this.token("(");
    this.print(node.expression, node);
    this.print(node.typeAnnotation, node);
    this.token(")");
  }

  function Variance(node) {
    if (node.kind === "plus") {
      this.token("+");
    } else {
      this.token("-");
    }
  }

  function VoidTypeAnnotation() {
    this.word("void");
  }

  function IndexedAccessType(node) {
    this.print(node.objectType, node);
    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }

  function OptionalIndexedAccessType(node) {
    this.print(node.objectType, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }
  }(flow));

  var base = {};

  Object.defineProperty(base, "__esModule", {
    value: true
  });
  base.File = File;
  base.Program = Program;
  base.BlockStatement = BlockStatement;
  base.Directive = Directive;
  base.DirectiveLiteral = DirectiveLiteral;
  base.InterpreterDirective = InterpreterDirective;
  base.Placeholder = Placeholder;

  function File(node) {
    if (node.program) {
      this.print(node.program.interpreter, node);
    }

    this.print(node.program, node);
  }

  function Program(node) {
    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }

  function BlockStatement(node) {
    var _node$directives;

    this.token("{");
    this.printInnerComments(node);
    const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;

    if (node.body.length || hasDirectives) {
      this.newline();
      this.printSequence(node.directives, node, {
        indent: true
      });
      if (hasDirectives) this.newline();
      this.printSequence(node.body, node, {
        indent: true
      });
      this.removeTrailingNewline();
      this.source("end", node.loc);
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    } else {
      this.source("end", node.loc);
      this.token("}");
    }
  }

  function Directive(node) {
    this.print(node.value, node);
    this.semicolon();
  }

  const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;

  function DirectiveLiteral(node) {
    const raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
      return;
    }

    const {
      value
    } = node;

    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token(`"${value}"`);
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token(`'${value}'`);
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }

  function InterpreterDirective(node) {
    this.token(`#!${node.value}\n`);
  }

  function Placeholder(node) {
    this.token("%%");
    this.print(node.name);
    this.token("%%");

    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }

  var jsx = {};

  Object.defineProperty(jsx, "__esModule", {
    value: true
  });
  jsx.JSXAttribute = JSXAttribute;
  jsx.JSXIdentifier = JSXIdentifier;
  jsx.JSXNamespacedName = JSXNamespacedName;
  jsx.JSXMemberExpression = JSXMemberExpression;
  jsx.JSXSpreadAttribute = JSXSpreadAttribute;
  jsx.JSXExpressionContainer = JSXExpressionContainer;
  jsx.JSXSpreadChild = JSXSpreadChild;
  jsx.JSXText = JSXText;
  jsx.JSXElement = JSXElement;
  jsx.JSXOpeningElement = JSXOpeningElement;
  jsx.JSXClosingElement = JSXClosingElement;
  jsx.JSXEmptyExpression = JSXEmptyExpression;
  jsx.JSXFragment = JSXFragment;
  jsx.JSXOpeningFragment = JSXOpeningFragment;
  jsx.JSXClosingFragment = JSXClosingFragment;

  function JSXAttribute(node) {
    this.print(node.name, node);

    if (node.value) {
      this.token("=");
      this.print(node.value, node);
    }
  }

  function JSXIdentifier(node) {
    this.word(node.name);
  }

  function JSXNamespacedName(node) {
    this.print(node.namespace, node);
    this.token(":");
    this.print(node.name, node);
  }

  function JSXMemberExpression(node) {
    this.print(node.object, node);
    this.token(".");
    this.print(node.property, node);
  }

  function JSXSpreadAttribute(node) {
    this.token("{");
    this.token("...");
    this.print(node.argument, node);
    this.token("}");
  }

  function JSXExpressionContainer(node) {
    this.token("{");
    this.print(node.expression, node);
    this.token("}");
  }

  function JSXSpreadChild(node) {
    this.token("{");
    this.token("...");
    this.print(node.expression, node);
    this.token("}");
  }

  function JSXText(node) {
    const raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
    } else {
      this.token(node.value);
    }
  }

  function JSXElement(node) {
    const open = node.openingElement;
    this.print(open, node);
    if (open.selfClosing) return;
    this.indent();

    for (const child of node.children) {
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingElement, node);
  }

  function spaceSeparator() {
    this.space();
  }

  function JSXOpeningElement(node) {
    this.token("<");
    this.print(node.name, node);
    this.print(node.typeParameters, node);

    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, node, {
        separator: spaceSeparator
      });
    }

    if (node.selfClosing) {
      this.space();
      this.token("/>");
    } else {
      this.token(">");
    }
  }

  function JSXClosingElement(node) {
    this.token("</");
    this.print(node.name, node);
    this.token(">");
  }

  function JSXEmptyExpression(node) {
    this.printInnerComments(node);
  }

  function JSXFragment(node) {
    this.print(node.openingFragment, node);
    this.indent();

    for (const child of node.children) {
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingFragment, node);
  }

  function JSXOpeningFragment() {
    this.token("<");
    this.token(">");
  }

  function JSXClosingFragment() {
    this.token("</");
    this.token(">");
  }

  var typescript = {};

  Object.defineProperty(typescript, "__esModule", {
    value: true
  });
  typescript.TSTypeAnnotation = TSTypeAnnotation;
  typescript.TSTypeParameterDeclaration = typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
  typescript.TSTypeParameter = TSTypeParameter;
  typescript.TSParameterProperty = TSParameterProperty;
  typescript.TSDeclareFunction = TSDeclareFunction;
  typescript.TSDeclareMethod = TSDeclareMethod;
  typescript.TSQualifiedName = TSQualifiedName;
  typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
  typescript.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
  typescript.TSPropertySignature = TSPropertySignature;
  typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
  typescript.TSMethodSignature = TSMethodSignature;
  typescript.TSIndexSignature = TSIndexSignature;
  typescript.TSAnyKeyword = TSAnyKeyword;
  typescript.TSBigIntKeyword = TSBigIntKeyword;
  typescript.TSUnknownKeyword = TSUnknownKeyword;
  typescript.TSNumberKeyword = TSNumberKeyword;
  typescript.TSObjectKeyword = TSObjectKeyword;
  typescript.TSBooleanKeyword = TSBooleanKeyword;
  typescript.TSStringKeyword = TSStringKeyword;
  typescript.TSSymbolKeyword = TSSymbolKeyword;
  typescript.TSVoidKeyword = TSVoidKeyword;
  typescript.TSUndefinedKeyword = TSUndefinedKeyword;
  typescript.TSNullKeyword = TSNullKeyword;
  typescript.TSNeverKeyword = TSNeverKeyword;
  typescript.TSIntrinsicKeyword = TSIntrinsicKeyword;
  typescript.TSThisType = TSThisType;
  typescript.TSFunctionType = TSFunctionType;
  typescript.TSConstructorType = TSConstructorType;
  typescript.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
  typescript.TSTypeReference = TSTypeReference;
  typescript.TSTypePredicate = TSTypePredicate;
  typescript.TSTypeQuery = TSTypeQuery;
  typescript.TSTypeLiteral = TSTypeLiteral;
  typescript.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
  typescript.tsPrintBraced = tsPrintBraced;
  typescript.TSArrayType = TSArrayType;
  typescript.TSTupleType = TSTupleType;
  typescript.TSOptionalType = TSOptionalType;
  typescript.TSRestType = TSRestType;
  typescript.TSNamedTupleMember = TSNamedTupleMember;
  typescript.TSUnionType = TSUnionType;
  typescript.TSIntersectionType = TSIntersectionType;
  typescript.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;
  typescript.TSConditionalType = TSConditionalType;
  typescript.TSInferType = TSInferType;
  typescript.TSParenthesizedType = TSParenthesizedType;
  typescript.TSTypeOperator = TSTypeOperator;
  typescript.TSIndexedAccessType = TSIndexedAccessType;
  typescript.TSMappedType = TSMappedType;
  typescript.TSLiteralType = TSLiteralType;
  typescript.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
  typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
  typescript.TSInterfaceBody = TSInterfaceBody;
  typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
  typescript.TSAsExpression = TSAsExpression;
  typescript.TSTypeAssertion = TSTypeAssertion;
  typescript.TSEnumDeclaration = TSEnumDeclaration;
  typescript.TSEnumMember = TSEnumMember;
  typescript.TSModuleDeclaration = TSModuleDeclaration;
  typescript.TSModuleBlock = TSModuleBlock;
  typescript.TSImportType = TSImportType;
  typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
  typescript.TSExternalModuleReference = TSExternalModuleReference;
  typescript.TSNonNullExpression = TSNonNullExpression;
  typescript.TSExportAssignment = TSExportAssignment;
  typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
  typescript.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
  typescript.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;

  function TSTypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }

  function TSTypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }

  function TSTypeParameter(node) {
    this.word(node.name);

    if (node.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.constraint, node);
    }

    if (node.default) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.default, node);
    }
  }

  function TSParameterProperty(node) {
    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node.readonly) {
      this.word("readonly");
      this.space();
    }

    this._param(node.parameter);
  }

  function TSDeclareFunction(node) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this._functionHead(node);

    this.token(";");
  }

  function TSDeclareMethod(node) {
    this._classMethodHead(node);

    this.token(";");
  }

  function TSQualifiedName(node) {
    this.print(node.left, node);
    this.token(".");
    this.print(node.right, node);
  }

  function TSCallSignatureDeclaration(node) {
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }

  function TSConstructSignatureDeclaration(node) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }

  function TSPropertySignature(node) {
    const {
      readonly,
      initializer
    } = node;

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(";");
  }

  function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
      this.token("[");
    }

    this.print(node.key, node);

    if (node.computed) {
      this.token("]");
    }

    if (node.optional) {
      this.token("?");
    }
  }

  function TSMethodSignature(node) {
    const {
      kind
    } = node;

    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }

    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }

  function TSIndexSignature(node) {
    const {
      readonly,
      static: isStatic
    } = node;

    if (isStatic) {
      this.word("static");
      this.space();
    }

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.token("[");

    this._parameters(node.parameters, node);

    this.token("]");
    this.print(node.typeAnnotation, node);
    this.token(";");
  }

  function TSAnyKeyword() {
    this.word("any");
  }

  function TSBigIntKeyword() {
    this.word("bigint");
  }

  function TSUnknownKeyword() {
    this.word("unknown");
  }

  function TSNumberKeyword() {
    this.word("number");
  }

  function TSObjectKeyword() {
    this.word("object");
  }

  function TSBooleanKeyword() {
    this.word("boolean");
  }

  function TSStringKeyword() {
    this.word("string");
  }

  function TSSymbolKeyword() {
    this.word("symbol");
  }

  function TSVoidKeyword() {
    this.word("void");
  }

  function TSUndefinedKeyword() {
    this.word("undefined");
  }

  function TSNullKeyword() {
    this.word("null");
  }

  function TSNeverKeyword() {
    this.word("never");
  }

  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }

  function TSThisType() {
    this.word("this");
  }

  function TSFunctionType(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }

  function TSConstructorType(node) {
    if (node.abstract) {
      this.word("abstract");
      this.space();
    }

    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
  }

  function tsPrintFunctionOrConstructorType(node) {
    const {
      typeParameters,
      parameters
    } = node;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.space();
    this.token("=>");
    this.space();
    this.print(node.typeAnnotation.typeAnnotation, node);
  }

  function TSTypeReference(node) {
    this.print(node.typeName, node);
    this.print(node.typeParameters, node);
  }

  function TSTypePredicate(node) {
    if (node.asserts) {
      this.word("asserts");
      this.space();
    }

    this.print(node.parameterName);

    if (node.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
  }

  function TSTypeQuery(node) {
    this.word("typeof");
    this.space();
    this.print(node.exprName);
  }

  function TSTypeLiteral(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
  }

  function tsPrintTypeLiteralOrInterfaceBody(members, node) {
    this.tsPrintBraced(members, node);
  }

  function tsPrintBraced(members, node) {
    this.token("{");

    if (members.length) {
      this.indent();
      this.newline();

      for (const member of members) {
        this.print(member, node);
        this.newline();
      }

      this.dedent();
      this.rightBrace();
    } else {
      this.token("}");
    }
  }

  function TSArrayType(node) {
    this.print(node.elementType, node);
    this.token("[]");
  }

  function TSTupleType(node) {
    this.token("[");
    this.printList(node.elementTypes, node);
    this.token("]");
  }

  function TSOptionalType(node) {
    this.print(node.typeAnnotation, node);
    this.token("?");
  }

  function TSRestType(node) {
    this.token("...");
    this.print(node.typeAnnotation, node);
  }

  function TSNamedTupleMember(node) {
    this.print(node.label, node);
    if (node.optional) this.token("?");
    this.token(":");
    this.space();
    this.print(node.elementType, node);
  }

  function TSUnionType(node) {
    this.tsPrintUnionOrIntersectionType(node, "|");
  }

  function TSIntersectionType(node) {
    this.tsPrintUnionOrIntersectionType(node, "&");
  }

  function tsPrintUnionOrIntersectionType(node, sep) {
    this.printJoin(node.types, node, {
      separator() {
        this.space();
        this.token(sep);
        this.space();
      }

    });
  }

  function TSConditionalType(node) {
    this.print(node.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node.extendsType);
    this.space();
    this.token("?");
    this.space();
    this.print(node.trueType);
    this.space();
    this.token(":");
    this.space();
    this.print(node.falseType);
  }

  function TSInferType(node) {
    this.token("infer");
    this.space();
    this.print(node.typeParameter);
  }

  function TSParenthesizedType(node) {
    this.token("(");
    this.print(node.typeAnnotation, node);
    this.token(")");
  }

  function TSTypeOperator(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation, node);
  }

  function TSIndexedAccessType(node) {
    this.print(node.objectType, node);
    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }

  function TSMappedType(node) {
    const {
      nameType,
      optional,
      readonly,
      typeParameter
    } = node;
    this.token("{");
    this.space();

    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }

    this.token("[");
    this.word(typeParameter.name);
    this.space();
    this.word("in");
    this.space();
    this.print(typeParameter.constraint, typeParameter);

    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType, node);
    }

    this.token("]");

    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.token("?");
    }

    this.token(":");
    this.space();
    this.print(node.typeAnnotation, node);
    this.space();
    this.token("}");
  }

  function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
      self.token(tok);
    }
  }

  function TSLiteralType(node) {
    this.print(node.literal, node);
  }

  function TSExpressionWithTypeArguments(node) {
    this.print(node.expression, node);
    this.print(node.typeParameters, node);
  }

  function TSInterfaceDeclaration(node) {
    const {
      declare,
      id,
      typeParameters,
      extends: extendz,
      body
    } = node;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("interface");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);

    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz, node);
    }

    this.space();
    this.print(body, node);
  }

  function TSInterfaceBody(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
  }

  function TSTypeAliasDeclaration(node) {
    const {
      declare,
      id,
      typeParameters,
      typeAnnotation
    } = node;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("type");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(typeAnnotation, node);
    this.token(";");
  }

  function TSAsExpression(node) {
    const {
      expression,
      typeAnnotation
    } = node;
    this.print(expression, node);
    this.space();
    this.word("as");
    this.space();
    this.print(typeAnnotation, node);
  }

  function TSTypeAssertion(node) {
    const {
      typeAnnotation,
      expression
    } = node;
    this.token("<");
    this.print(typeAnnotation, node);
    this.token(">");
    this.space();
    this.print(expression, node);
  }

  function TSEnumDeclaration(node) {
    const {
      declare,
      const: isConst,
      id,
      members
    } = node;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (isConst) {
      this.word("const");
      this.space();
    }

    this.word("enum");
    this.space();
    this.print(id, node);
    this.space();
    this.tsPrintBraced(members, node);
  }

  function TSEnumMember(node) {
    const {
      id,
      initializer
    } = node;
    this.print(id, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(",");
  }

  function TSModuleDeclaration(node) {
    const {
      declare,
      id
    } = node;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (!node.global) {
      this.word(id.type === "Identifier" ? "namespace" : "module");
      this.space();
    }

    this.print(id, node);

    if (!node.body) {
      this.token(";");
      return;
    }

    let body = node.body;

    while (body.type === "TSModuleDeclaration") {
      this.token(".");
      this.print(body.id, body);
      body = body.body;
    }

    this.space();
    this.print(body, node);
  }

  function TSModuleBlock(node) {
    this.tsPrintBraced(node.body, node);
  }

  function TSImportType(node) {
    const {
      argument,
      qualifier,
      typeParameters
    } = node;
    this.word("import");
    this.token("(");
    this.print(argument, node);
    this.token(")");

    if (qualifier) {
      this.token(".");
      this.print(qualifier, node);
    }

    if (typeParameters) {
      this.print(typeParameters, node);
    }
  }

  function TSImportEqualsDeclaration(node) {
    const {
      isExport,
      id,
      moduleReference
    } = node;

    if (isExport) {
      this.word("export");
      this.space();
    }

    this.word("import");
    this.space();
    this.print(id, node);
    this.space();
    this.token("=");
    this.space();
    this.print(moduleReference, node);
    this.token(";");
  }

  function TSExternalModuleReference(node) {
    this.token("require(");
    this.print(node.expression, node);
    this.token(")");
  }

  function TSNonNullExpression(node) {
    this.print(node.expression, node);
    this.token("!");
  }

  function TSExportAssignment(node) {
    this.word("export");
    this.space();
    this.token("=");
    this.space();
    this.print(node.expression, node);
    this.token(";");
  }

  function TSNamespaceExportDeclaration(node) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node.id, node);
  }

  function tsPrintSignatureDeclarationBase(node) {
    const {
      typeParameters,
      parameters
    } = node;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.print(node.typeAnnotation, node);
  }

  function tsPrintClassMemberModifiers(node, isField) {
    if (isField && node.declare) {
      this.word("declare");
      this.space();
    }

    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node.static) {
      this.word("static");
      this.space();
    }

    if (node.override) {
      this.word("override");
      this.space();
    }

    if (node.abstract) {
      this.word("abstract");
      this.space();
    }

    if (isField && node.readonly) {
      this.word("readonly");
      this.space();
    }
  }

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _templateLiterals = templateLiterals;

  Object.keys(_templateLiterals).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _templateLiterals[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _templateLiterals[key];
      }
    });
  });

  var _expressions = expressions;

  Object.keys(_expressions).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _expressions[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _expressions[key];
      }
    });
  });

  var _statements = statements$2;

  Object.keys(_statements).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _statements[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _statements[key];
      }
    });
  });

  var _classes = classes;

  Object.keys(_classes).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _classes[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _classes[key];
      }
    });
  });

  var _methods = methods;

  Object.keys(_methods).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _methods[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _methods[key];
      }
    });
  });

  var _modules = modules;

  Object.keys(_modules).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _modules[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _modules[key];
      }
    });
  });

  var _types = types;

  Object.keys(_types).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _types[key];
      }
    });
  });

  var _flow = flow;

  Object.keys(_flow).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _flow[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _flow[key];
      }
    });
  });

  var _base = base;

  Object.keys(_base).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _base[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _base[key];
      }
    });
  });

  var _jsx = jsx;

  Object.keys(_jsx).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _jsx[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _jsx[key];
      }
    });
  });

  var _typescript = typescript;

  Object.keys(_typescript).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _typescript[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function () {
        return _typescript[key];
      }
    });
  });
  }(generators));

  Object.defineProperty(printer, "__esModule", {
    value: true
  });
  printer.default = void 0;

  var _buffer = buffer;

  var n = node;

  var t$j = lib$9;

  var generatorFunctions = generators;

  const SCIENTIFIC_NOTATION = /e/i;
  const ZERO_DECIMAL_INTEGER = /\.0+$/;
  const NON_DECIMAL_LITERAL = /^0[box]/;
  const PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;

  class Printer {
    constructor(format, map) {
      this.inForStatementInitCounter = 0;
      this._printStack = [];
      this._indent = 0;
      this._insideAux = false;
      this._parenPushNewlineState = null;
      this._noLineTerminator = false;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = new WeakSet();
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this.format = format;
      this._buf = new _buffer.default(map);
    }

    generate(ast) {
      this.print(ast);

      this._maybeAddAuxComment();

      return this._buf.get();
    }

    indent() {
      if (this.format.compact || this.format.concise) return;
      this._indent++;
    }

    dedent() {
      if (this.format.compact || this.format.concise) return;
      this._indent--;
    }

    semicolon(force = false) {
      this._maybeAddAuxComment();

      this._append(";", !force);
    }

    rightBrace() {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }

      this.token("}");
    }

    space(force = false) {
      if (this.format.compact) return;

      if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
        this._space();
      }
    }

    word(str) {
      if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);

      this._endsWithWord = true;
    }

    number(str) {
      this.word(str);
      this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
    }

    token(str) {
      if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);
    }

    newline(i) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      if (this.endsWith("\n\n")) return;
      if (typeof i !== "number") i = 1;
      i = Math.min(2, i);
      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
      if (i <= 0) return;

      for (let j = 0; j < i; j++) {
        this._newline();
      }
    }

    endsWith(str) {
      return this._buf.endsWith(str);
    }

    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }

    exactSource(loc, cb) {
      this._catchUp("start", loc);

      this._buf.exactSource(loc, cb);
    }

    source(prop, loc) {
      this._catchUp(prop, loc);

      this._buf.source(prop, loc);
    }

    withSource(prop, loc, cb) {
      this._catchUp(prop, loc);

      this._buf.withSource(prop, loc, cb);
    }

    _space() {
      this._append(" ", true);
    }

    _newline() {
      this._append("\n", true);
    }

    _append(str, queue = false) {
      this._maybeAddParen(str);

      this._maybeIndent(str);

      if (queue) this._buf.queue(str);else this._buf.append(str);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }

    _maybeIndent(str) {
      if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
        this._buf.queue(this._getIndent());
      }
    }

    _maybeAddParen(str) {
      const parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState) return;
      let i;

      for (i = 0; i < str.length && str[i] === " "; i++) continue;

      if (i === str.length) {
        return;
      }

      const cha = str[i];

      if (cha !== "\n") {
        if (cha !== "/" || i + 1 === str.length) {
          this._parenPushNewlineState = null;
          return;
        }

        const chaPost = str[i + 1];

        if (chaPost === "*") {
          if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
            return;
          }
        } else if (chaPost !== "/") {
          this._parenPushNewlineState = null;
          return;
        }
      }

      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    }

    _catchUp(prop, loc) {
      if (!this.format.retainLines) return;
      const pos = loc ? loc[prop] : null;

      if ((pos == null ? void 0 : pos.line) != null) {
        const count = pos.line - this._buf.getCurrentLine();

        for (let i = 0; i < count; i++) {
          this._newline();
        }
      }
    }

    _getIndent() {
      return this.format.indent.style.repeat(this._indent);
    }

    startTerminatorless(isLabel = false) {
      if (isLabel) {
        this._noLineTerminator = true;
        return null;
      } else {
        return this._parenPushNewlineState = {
          printed: false
        };
      }
    }

    endTerminatorless(state) {
      this._noLineTerminator = false;

      if (state != null && state.printed) {
        this.dedent();
        this.newline();
        this.token(")");
      }
    }

    print(node, parent) {
      if (!node) return;
      const oldConcise = this.format.concise;

      if (node._compact) {
        this.format.concise = true;
      }

      const printMethod = this[node.type];

      if (!printMethod) {
        throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);
      }

      this._printStack.push(node);

      const oldInAux = this._insideAux;
      this._insideAux = !node.loc;

      this._maybeAddAuxComment(this._insideAux && !oldInAux);

      let needsParens = n.needsParens(node, parent, this._printStack);

      if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
        needsParens = true;
      }

      if (needsParens) this.token("(");

      this._printLeadingComments(node);

      const loc = t$j.isProgram(node) || t$j.isFile(node) ? null : node.loc;
      this.withSource("start", loc, () => {
        printMethod.call(this, node, parent);
      });

      this._printTrailingComments(node);

      if (needsParens) this.token(")");

      this._printStack.pop();

      this.format.concise = oldConcise;
      this._insideAux = oldInAux;
    }

    _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    }

    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      const comment = this.format.auxiliaryCommentBefore;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    }

    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      const comment = this.format.auxiliaryCommentAfter;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    }

    getPossibleRaw(node) {
      const extra = node.extra;

      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    }

    printJoin(nodes, parent, opts = {}) {
      if (!(nodes != null && nodes.length)) return;
      if (opts.indent) this.indent();
      const newlineOpts = {
        addNewlines: opts.addNewlines
      };

      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!node) continue;
        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
        this.print(node, parent);

        if (opts.iterator) {
          opts.iterator(node, i);
        }

        if (opts.separator && i < nodes.length - 1) {
          opts.separator.call(this);
        }

        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
      }

      if (opts.indent) this.dedent();
    }

    printAndIndentOnComments(node, parent) {
      const indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node, parent);
      if (indent) this.dedent();
    }

    printBlock(parent) {
      const node = parent.body;

      if (!t$j.isEmptyStatement(node)) {
        this.space();
      }

      this.print(node, parent);
    }

    _printTrailingComments(node) {
      this._printComments(this._getComments(false, node));
    }

    _printLeadingComments(node) {
      this._printComments(this._getComments(true, node), true);
    }

    printInnerComments(node, indent = true) {
      var _node$innerComments;

      if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;
      if (indent) this.indent();

      this._printComments(node.innerComments);

      if (indent) this.dedent();
    }

    printSequence(nodes, parent, opts = {}) {
      opts.statement = true;
      return this.printJoin(nodes, parent, opts);
    }

    printList(items, parent, opts = {}) {
      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }

      return this.printJoin(items, parent, opts);
    }

    _printNewline(leading, node, parent, opts) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      let lines = 0;

      if (this._buf.hasContent()) {
        if (!leading) lines++;
        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
        const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
        if (needs(node, parent)) lines++;
      }

      this.newline(lines);
    }

    _getComments(leading, node) {
      return node && (leading ? node.leadingComments : node.trailingComments) || [];
    }

    _printComment(comment, skipNewLines) {
      if (!this.format.shouldPrintComment(comment.value)) return;
      if (comment.ignore) return;
      if (this._printedComments.has(comment)) return;

      this._printedComments.add(comment);

      const isBlockComment = comment.type === "CommentBlock";
      const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent()) this.newline(1);
      if (!this.endsWith("[") && !this.endsWith("{")) this.space();
      let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\n` : `/*${comment.value}*/`;

      if (isBlockComment && this.format.indent.adjustMultilineComment) {
        var _comment$loc;

        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;

        if (offset) {
          const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, `\n${" ".repeat(indentSize)}`);
      }

      if (this.endsWith("/")) this._space();
      this.withSource("start", comment.loc, () => {
        this._append(val);
      });
      if (printNewLines) this.newline(1);
    }

    _printComments(comments, inlinePureAnnotation) {
      if (!(comments != null && comments.length)) return;

      if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
        this._printComment(comments[0], this._buf.hasContent() && !this.endsWith("\n"));
      } else {
        for (const comment of comments) {
          this._printComment(comment);
        }
      }
    }

    printAssertions(node) {
      var _node$assertions;

      if ((_node$assertions = node.assertions) != null && _node$assertions.length) {
        this.space();
        this.word("assert");
        this.space();
        this.token("{");
        this.space();
        this.printList(node.assertions, node);
        this.space();
        this.token("}");
      }
    }

  }

  Object.assign(Printer.prototype, generatorFunctions);
  {
    Printer.prototype.Noop = function Noop() {};
  }
  var _default$7 = Printer;
  printer.default = _default$7;

  function commaSeparator() {
    this.token(",");
    this.space();
  }

  Object.defineProperty(lib$6, "__esModule", {
    value: true
  });
  var _default$6 = lib$6.default = generate;
  lib$6.CodeGenerator = void 0;

  var _sourceMap = sourceMap$1;

  var _printer = printer;

  class Generator extends _printer.default {
    constructor(ast, opts = {}, code) {
      const format = normalizeOptions(code, opts);
      const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      super(format, map);
      this.ast = void 0;
      this.ast = ast;
    }

    generate() {
      return super.generate(this.ast);
    }

  }

  function normalizeOptions(code, opts) {
    const format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  ",
        base: 0
      },
      decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, opts.jsescOption),
      recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType
    };
    {
      format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
    }

    if (format.minified) {
      format.compact = true;

      format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);
    } else {
      format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0);
    }

    if (format.compact === "auto") {
      format.compact = code.length > 500000;

      if (format.compact) {
        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);
      }
    }

    if (format.compact) {
      format.indent.adjustMultilineComment = false;
    }

    return format;
  }

  class CodeGenerator {
    constructor(ast, opts, code) {
      this._generator = void 0;
      this._generator = new Generator(ast, opts, code);
    }

    generate() {
      return this._generator.generate();
    }

  }

  lib$6.CodeGenerator = CodeGenerator;

  function generate(ast, opts, code) {
    const gen = new Generator(ast, opts, code);
    return gen.generate();
  }

  var ancestry = {};

  Object.defineProperty(ancestry, "__esModule", {
    value: true
  });
  ancestry.findParent = findParent;
  ancestry.find = find;
  ancestry.getFunctionParent = getFunctionParent;
  ancestry.getStatementParent = getStatementParent;
  ancestry.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
  ancestry.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
  ancestry.getAncestry = getAncestry;
  ancestry.isAncestor = isAncestor;
  ancestry.isDescendant = isDescendant;
  ancestry.inType = inType;

  var t$i = lib$9;

  function findParent(callback) {
    let path = this;

    while (path = path.parentPath) {
      if (callback(path)) return path;
    }

    return null;
  }

  function find(callback) {
    let path = this;

    do {
      if (callback(path)) return path;
    } while (path = path.parentPath);

    return null;
  }

  function getFunctionParent() {
    return this.findParent(p => p.isFunction());
  }

  function getStatementParent() {
    let path = this;

    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);

    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }

    return path;
  }

  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
      let earliest;
      const keys = t$i.VISITOR_KEYS[deepest.type];

      for (const ancestry of ancestries) {
        const path = ancestry[i + 1];

        if (!earliest) {
          earliest = path;
          continue;
        }

        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }

        const earliestKeyIndex = keys.indexOf(earliest.parentKey);
        const currentKeyIndex = keys.indexOf(path.parentKey);

        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }

      return earliest;
    });
  }

  function getDeepestCommonAncestorFrom(paths, filter) {
    if (!paths.length) {
      return this;
    }

    if (paths.length === 1) {
      return paths[0];
    }

    let minDepth = Infinity;
    let lastCommonIndex, lastCommon;
    const ancestries = paths.map(path => {
      const ancestry = [];

      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== this);

      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }

      return ancestry;
    });
    const first = ancestries[0];

    depthLoop: for (let i = 0; i < minDepth; i++) {
      const shouldMatch = first[i];

      for (const ancestry of ancestries) {
        if (ancestry[i] !== shouldMatch) {
          break depthLoop;
        }
      }

      lastCommonIndex = i;
      lastCommon = shouldMatch;
    }

    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }

  function getAncestry() {
    let path = this;
    const paths = [];

    do {
      paths.push(path);
    } while (path = path.parentPath);

    return paths;
  }

  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }

  function isDescendant(maybeAncestor) {
    return !!this.findParent(parent => parent === maybeAncestor);
  }

  function inType(...candidateTypes) {
    let path = this;

    while (path) {
      for (const type of candidateTypes) {
        if (path.node.type === type) return true;
      }

      path = path.parentPath;
    }

    return false;
  }

  var inference = {};

  var inferers$1 = {};

  var infererReference = {};

  Object.defineProperty(infererReference, "__esModule", {
    value: true
  });
  infererReference.default = _default$5;

  var t$h = lib$9;

  function _default$5(node) {
    if (!this.isReferenced()) return;
    const binding = this.scope.getBinding(node.name);

    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
      }
    }

    if (node.name === "undefined") {
      return t$h.voidTypeAnnotation();
    } else if (node.name === "NaN" || node.name === "Infinity") {
      return t$h.numberTypeAnnotation();
    } else if (node.name === "arguments") ;
  }

  function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    const types = [];
    const functionConstantViolations = [];
    let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    const testType = getConditionalAnnotation(binding, path, name);

    if (testType) {
      const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
      constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);
      types.push(testType.typeAnnotation);
    }

    if (constantViolations.length) {
      constantViolations = constantViolations.concat(functionConstantViolations);

      for (const violation of constantViolations) {
        types.push(violation.getTypeAnnotation());
      }
    }

    if (!types.length) {
      return;
    }

    if (t$h.isTSTypeAnnotation(types[0]) && t$h.createTSUnionType) {
      return t$h.createTSUnionType(types);
    }

    if (t$h.createFlowUnionType) {
      return t$h.createFlowUnionType(types);
    }

    return t$h.createUnionTypeAnnotation(types);
  }

  function getConstantViolationsBefore(binding, path, functions) {
    const violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter(violation => {
      violation = violation.resolve();

      const status = violation._guessExecutionStatusRelativeTo(path);

      if (functions && status === "unknown") functions.push(violation);
      return status === "before";
    });
  }

  function inferAnnotationFromBinaryExpression(name, path) {
    const operator = path.node.operator;
    const right = path.get("right").resolve();
    const left = path.get("left").resolve();
    let target;

    if (left.isIdentifier({
      name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name
    })) {
      target = left;
    }

    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }

      if (t$h.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return t$h.numberTypeAnnotation();
      }

      return;
    }

    if (operator !== "===" && operator !== "==") return;
    let typeofPath;
    let typePath;

    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }

    if (!typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name
    })) return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    const typeValue = typePath.node.value;
    if (typeof typeValue !== "string") return;
    return t$h.createTypeAnnotationBasedOnTypeof(typeValue);
  }

  function getParentConditionalPath(binding, path, name) {
    let parentPath;

    while (parentPath = path.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path.key === "test") {
          return;
        }

        return parentPath;
      }

      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
      }

      path = parentPath;
    }
  }

  function getConditionalAnnotation(binding, path, name) {
    const ifStatement = getParentConditionalPath(binding, path, name);
    if (!ifStatement) return;
    const test = ifStatement.get("test");
    const paths = [test];
    const types = [];

    for (let i = 0; i < paths.length; i++) {
      const path = paths[i];

      if (path.isLogicalExpression()) {
        if (path.node.operator === "&&") {
          paths.push(path.get("left"));
          paths.push(path.get("right"));
        }
      } else if (path.isBinaryExpression()) {
        const type = inferAnnotationFromBinaryExpression(name, path);
        if (type) types.push(type);
      }
    }

    if (types.length) {
      if (t$h.isTSTypeAnnotation(types[0]) && t$h.createTSUnionType) {
        return {
          typeAnnotation: t$h.createTSUnionType(types),
          ifStatement
        };
      }

      if (t$h.createFlowUnionType) {
        return {
          typeAnnotation: t$h.createFlowUnionType(types),
          ifStatement
        };
      }

      return {
        typeAnnotation: t$h.createUnionTypeAnnotation(types),
        ifStatement
      };
    }

    return getConditionalAnnotation(ifStatement, name);
  }

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.VariableDeclarator = VariableDeclarator;
  exports.TypeCastExpression = TypeCastExpression;
  exports.NewExpression = NewExpression;
  exports.TemplateLiteral = TemplateLiteral;
  exports.UnaryExpression = UnaryExpression;
  exports.BinaryExpression = BinaryExpression;
  exports.LogicalExpression = LogicalExpression;
  exports.ConditionalExpression = ConditionalExpression;
  exports.SequenceExpression = SequenceExpression;
  exports.ParenthesizedExpression = ParenthesizedExpression;
  exports.AssignmentExpression = AssignmentExpression;
  exports.UpdateExpression = UpdateExpression;
  exports.StringLiteral = StringLiteral;
  exports.NumericLiteral = NumericLiteral;
  exports.BooleanLiteral = BooleanLiteral;
  exports.NullLiteral = NullLiteral;
  exports.RegExpLiteral = RegExpLiteral;
  exports.ObjectExpression = ObjectExpression;
  exports.ArrayExpression = ArrayExpression;
  exports.RestElement = RestElement;
  exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
  exports.CallExpression = CallExpression;
  exports.TaggedTemplateExpression = TaggedTemplateExpression;
  Object.defineProperty(exports, "Identifier", {
    enumerable: true,
    get: function () {
      return _infererReference.default;
    }
  });

  var t = lib$9;

  var _infererReference = infererReference;

  function VariableDeclarator() {
    var _type;

    const id = this.get("id");
    if (!id.isIdentifier()) return;
    const init = this.get("init");
    let type = init.getTypeAnnotation();

    if (((_type = type) == null ? void 0 : _type.type) === "AnyTypeAnnotation") {
      if (init.isCallExpression() && init.get("callee").isIdentifier({
        name: "Array"
      }) && !init.scope.hasBinding("Array", true)) {
        type = ArrayExpression();
      }
    }

    return type;
  }

  function TypeCastExpression(node) {
    return node.typeAnnotation;
  }

  TypeCastExpression.validParent = true;

  function NewExpression(node) {
    if (this.get("callee").isIdentifier()) {
      return t.genericTypeAnnotation(node.callee);
    }
  }

  function TemplateLiteral() {
    return t.stringTypeAnnotation();
  }

  function UnaryExpression(node) {
    const operator = node.operator;

    if (operator === "void") {
      return t.voidTypeAnnotation();
    } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return t.numberTypeAnnotation();
    } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return t.stringTypeAnnotation();
    } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return t.booleanTypeAnnotation();
    }
  }

  function BinaryExpression(node) {
    const operator = node.operator;

    if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return t.numberTypeAnnotation();
    } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return t.booleanTypeAnnotation();
    } else if (operator === "+") {
      const right = this.get("right");
      const left = this.get("left");

      if (left.isBaseType("number") && right.isBaseType("number")) {
        return t.numberTypeAnnotation();
      } else if (left.isBaseType("string") || right.isBaseType("string")) {
        return t.stringTypeAnnotation();
      }

      return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);
    }
  }

  function LogicalExpression() {
    const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];

    if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {
      return t.createTSUnionType(argumentTypes);
    }

    if (t.createFlowUnionType) {
      return t.createFlowUnionType(argumentTypes);
    }

    return t.createUnionTypeAnnotation(argumentTypes);
  }

  function ConditionalExpression() {
    const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];

    if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {
      return t.createTSUnionType(argumentTypes);
    }

    if (t.createFlowUnionType) {
      return t.createFlowUnionType(argumentTypes);
    }

    return t.createUnionTypeAnnotation(argumentTypes);
  }

  function SequenceExpression() {
    return this.get("expressions").pop().getTypeAnnotation();
  }

  function ParenthesizedExpression() {
    return this.get("expression").getTypeAnnotation();
  }

  function AssignmentExpression() {
    return this.get("right").getTypeAnnotation();
  }

  function UpdateExpression(node) {
    const operator = node.operator;

    if (operator === "++" || operator === "--") {
      return t.numberTypeAnnotation();
    }
  }

  function StringLiteral() {
    return t.stringTypeAnnotation();
  }

  function NumericLiteral() {
    return t.numberTypeAnnotation();
  }

  function BooleanLiteral() {
    return t.booleanTypeAnnotation();
  }

  function NullLiteral() {
    return t.nullLiteralTypeAnnotation();
  }

  function RegExpLiteral() {
    return t.genericTypeAnnotation(t.identifier("RegExp"));
  }

  function ObjectExpression() {
    return t.genericTypeAnnotation(t.identifier("Object"));
  }

  function ArrayExpression() {
    return t.genericTypeAnnotation(t.identifier("Array"));
  }

  function RestElement() {
    return ArrayExpression();
  }

  RestElement.validParent = true;

  function Func() {
    return t.genericTypeAnnotation(t.identifier("Function"));
  }

  const isArrayFrom = t.buildMatchMemberExpression("Array.from");
  const isObjectKeys = t.buildMatchMemberExpression("Object.keys");
  const isObjectValues = t.buildMatchMemberExpression("Object.values");
  const isObjectEntries = t.buildMatchMemberExpression("Object.entries");

  function CallExpression() {
    const {
      callee
    } = this.node;

    if (isObjectKeys(callee)) {
      return t.arrayTypeAnnotation(t.stringTypeAnnotation());
    } else if (isArrayFrom(callee) || isObjectValues(callee)) {
      return t.arrayTypeAnnotation(t.anyTypeAnnotation());
    } else if (isObjectEntries(callee)) {
      return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));
    }

    return resolveCall(this.get("callee"));
  }

  function TaggedTemplateExpression() {
    return resolveCall(this.get("tag"));
  }

  function resolveCall(callee) {
    callee = callee.resolve();

    if (callee.isFunction()) {
      if (callee.is("async")) {
        if (callee.is("generator")) {
          return t.genericTypeAnnotation(t.identifier("AsyncIterator"));
        } else {
          return t.genericTypeAnnotation(t.identifier("Promise"));
        }
      } else {
        if (callee.node.returnType) {
          return callee.node.returnType;
        }
      }
    }
  }
  }(inferers$1));

  Object.defineProperty(inference, "__esModule", {
    value: true
  });
  inference.getTypeAnnotation = getTypeAnnotation;
  inference._getTypeAnnotation = _getTypeAnnotation;
  inference.isBaseType = isBaseType;
  inference.couldBeBaseType = couldBeBaseType;
  inference.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
  inference.isGenericType = isGenericType;

  var inferers = inferers$1;

  var t$g = lib$9;

  function getTypeAnnotation() {
    if (this.typeAnnotation) return this.typeAnnotation;
    let type = this._getTypeAnnotation() || t$g.anyTypeAnnotation();
    if (t$g.isTypeAnnotation(type)) type = type.typeAnnotation;
    return this.typeAnnotation = type;
  }

  const typeAnnotationInferringNodes = new WeakSet();

  function _getTypeAnnotation() {
    const node = this.node;

    if (!node) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        const declar = this.parentPath.parentPath;
        const declarParent = declar.parentPath;

        if (declar.key === "left" && declarParent.isForInStatement()) {
          return t$g.stringTypeAnnotation();
        }

        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return t$g.anyTypeAnnotation();
        }

        return t$g.voidTypeAnnotation();
      } else {
        return;
      }
    }

    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }

    if (typeAnnotationInferringNodes.has(node)) {
      return;
    }

    typeAnnotationInferringNodes.add(node);

    try {
      var _inferer;

      let inferer = inferers[node.type];

      if (inferer) {
        return inferer.call(this, node);
      }

      inferer = inferers[this.parentPath.type];

      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes.delete(node);
    }
  }

  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }

  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return t$g.isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return t$g.isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return t$g.isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return t$g.isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return t$g.isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return t$g.isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return t$g.isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error(`Unknown base type ${baseName}`);
      }
    }
  }

  function couldBeBaseType(name) {
    const type = this.getTypeAnnotation();
    if (t$g.isAnyTypeAnnotation(type)) return true;

    if (t$g.isUnionTypeAnnotation(type)) {
      for (const type2 of type.types) {
        if (t$g.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }

      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }

  function baseTypeStrictlyMatches(rightArg) {
    const left = this.getTypeAnnotation();
    const right = rightArg.getTypeAnnotation();

    if (!t$g.isAnyTypeAnnotation(left) && t$g.isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }

    return false;
  }

  function isGenericType(genericName) {
    const type = this.getTypeAnnotation();
    return t$g.isGenericTypeAnnotation(type) && t$g.isIdentifier(type.id, {
      name: genericName
    });
  }

  var replacement = {};

  var lib$5 = {};

  var lib$4 = {};

  Object.defineProperty(lib$4, "__esModule", {
    value: true
  });
  lib$4.shouldHighlight = shouldHighlight;
  lib$4.getChalk = getChalk;
  lib$4.default = highlight;

  var _jsTokens = require$$0__default$2['default'];

  var _helperValidatorIdentifier = lib$8;

  var _chalk = require$$2__default$1['default'];

  const sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);

  function getDefs$1(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsxIdentifier: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold
    };
  }

  const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  const BRACKET = /^[()[\]{}]$/;
  let tokenize;
  {
    const JSX_TAG = /^[a-z][\w-]*$/i;

    const getTokenType = function (token, offset, text) {
      if (token.type === "name") {
        if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }

        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsxIdentifier";
        }

        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }

      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }

      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }

      return token.type;
    };

    tokenize = function* (text) {
      let match;

      while (match = _jsTokens.default.exec(text)) {
        const token = _jsTokens.matchToToken(match);

        yield {
          type: getTokenType(token, match.index, text),
          value: token.value
        };
      }
    };
  }

  function highlightTokens(defs, text) {
    let highlighted = "";

    for (const {
      type,
      value
    } of tokenize(text)) {
      const colorize = defs[type];

      if (colorize) {
        highlighted += value.split(NEWLINE$1).map(str => colorize(str)).join("\n");
      } else {
        highlighted += value;
      }
    }

    return highlighted;
  }

  function shouldHighlight(options) {
    return !!_chalk.supportsColor || options.forceColor;
  }

  function getChalk(options) {
    return options.forceColor ? new _chalk.constructor({
      enabled: true,
      level: 1
    }) : _chalk;
  }

  function highlight(code, options = {}) {
    if (shouldHighlight(options)) {
      const chalk = getChalk(options);
      const defs = getDefs$1(chalk);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }

  Object.defineProperty(lib$5, "__esModule", {
    value: true
  });
  lib$5.codeFrameColumns = codeFrameColumns;
  lib$5.default = _default$4;

  var _highlight = lib$4;

  let deprecationWarningShown = false;

  function getDefs(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold
    };
  }

  const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

  function getMarkerLines(loc, source, opts) {
    const startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    const endLoc = Object.assign({}, startLoc, loc.end);
    const {
      linesAbove = 2,
      linesBelow = 3
    } = opts || {};
    const startLine = startLoc.line;
    const startColumn = startLoc.column;
    const endLine = endLoc.line;
    const endColumn = endLoc.column;
    let start = Math.max(startLine - (linesAbove + 1), 0);
    let end = Math.min(source.length, endLine + linesBelow);

    if (startLine === -1) {
      start = 0;
    }

    if (endLine === -1) {
      end = source.length;
    }

    const lineDiff = endLine - startLine;
    const markerLines = {};

    if (lineDiff) {
      for (let i = 0; i <= lineDiff; i++) {
        const lineNumber = i + startLine;

        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          const sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          const sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }

    return {
      start,
      end,
      markerLines
    };
  }

  function codeFrameColumns(rawLines, loc, opts = {}) {
    const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);
    const chalk = (0, _highlight.getChalk)(opts);
    const defs = getDefs(chalk);

    const maybeHighlight = (chalkFn, string) => {
      return highlighted ? chalkFn(string) : string;
    };

    const lines = rawLines.split(NEWLINE);
    const {
      start,
      end,
      markerLines
    } = getMarkerLines(loc, lines, opts);
    const hasColumns = loc.start && typeof loc.start.column === "number";
    const numberMaxWidth = String(end).length;
    const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;
    let frame = highlightedLines.split(NEWLINE).slice(start, end).map((line, index) => {
      const number = start + 1 + index;
      const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
      const gutter = ` ${paddedNumber} |`;
      const hasMarker = markerLines[number];
      const lastMarkerLine = !markerLines[number + 1];

      if (hasMarker) {
        let markerLine = "";

        if (Array.isArray(hasMarker)) {
          const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          const numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }

        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
      } else {
        return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;
      }
    }).join("\n");

    if (opts.message && !hasColumns) {
      frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;
    }

    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  }

  function _default$4(rawLines, lineNumber, colNumber, opts = {}) {
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";

      {
        const deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }

    colNumber = Math.max(colNumber, 0);
    const location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }

  var lib$3 = {};

  Object.defineProperty(lib$3, "__esModule", {
    value: true
  });
  lib$3.default = hoistVariables;

  var t$f = lib$9;

  const visitor$1 = {
    Scope(path, state) {
      if (state.kind === "let") path.skip();
    },

    FunctionParent(path) {
      path.skip();
    },

    VariableDeclaration(path, state) {
      if (state.kind && path.node.kind !== state.kind) return;
      const nodes = [];
      const declarations = path.get("declarations");
      let firstId;

      for (const declar of declarations) {
        firstId = declar.node.id;

        if (declar.node.init) {
          nodes.push(t$f.expressionStatement(t$f.assignmentExpression("=", declar.node.id, declar.node.init)));
        }

        for (const name of Object.keys(declar.getBindingIdentifiers())) {
          state.emit(t$f.identifier(name), name, declar.node.init !== null);
        }
      }

      if (path.parentPath.isFor({
        left: path.node
      })) {
        path.replaceWith(firstId);
      } else {
        path.replaceWithMultiple(nodes);
      }
    }

  };

  function hoistVariables(path, emit, kind = "var") {
    path.traverse(visitor$1, {
      kind,
      emit
    });
  }

  Object.defineProperty(replacement, "__esModule", {
    value: true
  });
  replacement.replaceWithMultiple = replaceWithMultiple;
  replacement.replaceWithSourceString = replaceWithSourceString;
  replacement.replaceWith = replaceWith;
  replacement._replaceWith = _replaceWith;
  replacement.replaceExpressionWithStatements = replaceExpressionWithStatements;
  replacement.replaceInline = replaceInline;

  var _codeFrame$1 = lib$5;

  var _index$5 = lib$a;

  var _index2$1 = path$1;

  var _cache$3 = cache;

  var _parser$1 = lib$b;

  var t$e = lib$9;

  var _helperHoistVariables = lib$3;

  function replaceWithMultiple(nodes) {
    var _pathCache$get;

    this.resync();
    nodes = this._verifyNodeList(nodes);
    t$e.inheritLeadingComments(nodes[0], this.node);
    t$e.inheritTrailingComments(nodes[nodes.length - 1], this.node);
    (_pathCache$get = _cache$3.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);
    this.node = this.container[this.key] = null;
    const paths = this.insertAfter(nodes);

    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }

    return paths;
  }

  function replaceWithSourceString(replacement) {
    this.resync();

    try {
      replacement = `(${replacement})`;
      replacement = (0, _parser$1.parse)(replacement);
    } catch (err) {
      const loc = err.loc;

      if (loc) {
        err.message += " - make sure this is an expression.\n" + (0, _codeFrame$1.codeFrameColumns)(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }

      throw err;
    }

    replacement = replacement.program.body[0].expression;

    _index$5.default.removeProperties(replacement);

    return this.replaceWith(replacement);
  }

  function replaceWith(replacement) {
    this.resync();

    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }

    if (replacement instanceof _index2$1.default) {
      replacement = replacement.node;
    }

    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }

    if (this.node === replacement) {
      return [this];
    }

    if (this.isProgram() && !t$e.isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }

    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }

    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }

    let nodePath = "";

    if (this.isNodeType("Statement") && t$e.isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement = t$e.expressionStatement(replacement);
        nodePath = "expression";
      }
    }

    if (this.isNodeType("Expression") && t$e.isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }

    const oldNode = this.node;

    if (oldNode) {
      t$e.inheritsComments(replacement, oldNode);
      t$e.removeComments(oldNode);
    }

    this._replaceWith(replacement);

    this.type = replacement.type;
    this.setScope();
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }

  function _replaceWith(node) {
    var _pathCache$get2;

    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }

    if (this.inList) {
      t$e.validate(this.parent, this.key, [node]);
    } else {
      t$e.validate(this.parent, this.key, node);
    }

    this.debug(`Replace with ${node == null ? void 0 : node.type}`);
    (_pathCache$get2 = _cache$3.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);
    this.node = this.container[this.key] = node;
  }

  function replaceExpressionWithStatements(nodes) {
    this.resync();
    const toSequenceExpression = t$e.toSequenceExpression(nodes, this.scope);

    if (toSequenceExpression) {
      return this.replaceWith(toSequenceExpression)[0].get("expressions");
    }

    const functionParent = this.getFunctionParent();
    const isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
    const isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
    const container = t$e.arrowFunctionExpression([], t$e.blockStatement(nodes));
    this.replaceWith(t$e.callExpression(container, []));
    const callee = this.get("callee");
    (0, _helperHoistVariables.default)(callee.get("body"), id => {
      this.scope.push({
        id
      });
    }, "var");
    const completionRecords = this.get("callee").getCompletionRecords();

    for (const path of completionRecords) {
      if (!path.isExpressionStatement()) continue;
      const loop = path.findParent(path => path.isLoop());

      if (loop) {
        let uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", t$e.returnStatement(t$e.cloneNode(uid)));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = t$e.identifier(uid.name);
        }

        path.get("expression").replaceWith(t$e.assignmentExpression("=", t$e.cloneNode(uid), path.node.expression));
      } else {
        path.replaceWith(t$e.returnStatement(path.node.expression));
      }
    }

    callee.arrowFunctionToExpression();
    const newCallee = callee;

    const needToAwaitFunction = isParentAsync && _index$5.default.hasType(this.get("callee.body").node, "AwaitExpression", t$e.FUNCTION_TYPES);

    const needToYieldFunction = isParentGenerator && _index$5.default.hasType(this.get("callee.body").node, "YieldExpression", t$e.FUNCTION_TYPES);

    if (needToAwaitFunction) {
      newCallee.set("async", true);

      if (!needToYieldFunction) {
        this.replaceWith(t$e.awaitExpression(this.node));
      }
    }

    if (needToYieldFunction) {
      newCallee.set("generator", true);
      this.replaceWith(t$e.yieldExpression(this.node, true));
    }

    return newCallee.get("body.body");
  }

  function replaceInline(nodes) {
    this.resync();

    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);

        const paths = this._containerInsertAfter(nodes);

        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }

  var evaluation = {};

  Object.defineProperty(evaluation, "__esModule", {
    value: true
  });
  evaluation.evaluateTruthy = evaluateTruthy;
  evaluation.evaluate = evaluate;
  const VALID_CALLEES = ["String", "Number", "Math"];
  const INVALID_METHODS = ["random"];

  function evaluateTruthy() {
    const res = this.evaluate();
    if (res.confident) return !!res.value;
  }

  function deopt(path, state) {
    if (!state.confident) return;
    state.deoptPath = path;
    state.confident = false;
  }

  function evaluateCached(path, state) {
    const {
      node
    } = path;
    const {
      seen
    } = state;

    if (seen.has(node)) {
      const existing = seen.get(node);

      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path, state);
        return;
      }
    } else {
      const item = {
        resolved: false
      };
      seen.set(node, item);

      const val = _evaluate(path, state);

      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }

      return val;
    }
  }

  function _evaluate(path, state) {
    if (!state.confident) return;

    if (path.isSequenceExpression()) {
      const exprs = path.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }

    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return path.node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      return evaluateQuasis(path, path.node.quasis, state);
    }

    if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
      const object = path.get("tag.object");
      const {
        node: {
          name
        }
      } = object;
      const property = path.get("tag.property");

      if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
        return evaluateQuasis(path, path.node.quasi.quasis, state, true);
      }
    }

    if (path.isConditionalExpression()) {
      const testResult = evaluateCached(path.get("test"), state);
      if (!state.confident) return;

      if (testResult) {
        return evaluateCached(path.get("consequent"), state);
      } else {
        return evaluateCached(path.get("alternate"), state);
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluateCached(path.get("expression"), state);
    }

    if (path.isMemberExpression() && !path.parentPath.isCallExpression({
      callee: path.node
    })) {
      const property = path.get("property");
      const object = path.get("object");

      if (object.isLiteral() && property.isIdentifier()) {
        const value = object.node.value;
        const type = typeof value;

        if (type === "number" || type === "string") {
          return value[property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      const binding = path.scope.getBinding(path.node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path, state);
      }

      if (binding && path.node.start < binding.path.node.end) {
        return deopt(binding.path, state);
      }

      if (binding != null && binding.hasValue) {
        return binding.value;
      } else {
        if (path.node.name === "undefined") {
          return binding ? deopt(binding.path, state) : undefined;
        } else if (path.node.name === "Infinity") {
          return binding ? deopt(binding.path, state) : Infinity;
        } else if (path.node.name === "NaN") {
          return binding ? deopt(binding.path, state) : NaN;
        }

        const resolved = path.resolve();

        if (resolved === path) {
          return deopt(path, state);
        } else {
          return evaluateCached(resolved, state);
        }
      }
    }

    if (path.isUnaryExpression({
      prefix: true
    })) {
      if (path.node.operator === "void") {
        return undefined;
      }

      const argument = path.get("argument");

      if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }

      const arg = evaluateCached(argument, state);
      if (!state.confident) return;

      switch (path.node.operator) {
        case "!":
          return !arg;

        case "+":
          return +arg;

        case "-":
          return -arg;

        case "~":
          return ~arg;

        case "typeof":
          return typeof arg;
      }
    }

    if (path.isArrayExpression()) {
      const arr = [];
      const elems = path.get("elements");

      for (const elem of elems) {
        const elemValue = elem.evaluate();

        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          return deopt(elemValue.deopt, state);
        }
      }

      return arr;
    }

    if (path.isObjectExpression()) {
      const obj = {};
      const props = path.get("properties");

      for (const prop of props) {
        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          return deopt(prop, state);
        }

        const keyPath = prop.get("key");
        let key = keyPath;

        if (prop.node.computed) {
          key = key.evaluate();

          if (!key.confident) {
            return deopt(key.deopt, state);
          }

          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }

        const valuePath = prop.get("value");
        let value = valuePath.evaluate();

        if (!value.confident) {
          return deopt(value.deopt, state);
        }

        value = value.value;
        obj[key] = value;
      }

      return obj;
    }

    if (path.isLogicalExpression()) {
      const wasConfident = state.confident;
      const left = evaluateCached(path.get("left"), state);
      const leftConfident = state.confident;
      state.confident = wasConfident;
      const right = evaluateCached(path.get("right"), state);
      const rightConfident = state.confident;

      switch (path.node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;

        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      const left = evaluateCached(path.get("left"), state);
      if (!state.confident) return;
      const right = evaluateCached(path.get("right"), state);
      if (!state.confident) return;

      switch (path.node.operator) {
        case "-":
          return left - right;

        case "+":
          return left + right;

        case "/":
          return left / right;

        case "*":
          return left * right;

        case "%":
          return left % right;

        case "**":
          return Math.pow(left, right);

        case "<":
          return left < right;

        case ">":
          return left > right;

        case "<=":
          return left <= right;

        case ">=":
          return left >= right;

        case "==":
          return left == right;

        case "!=":
          return left != right;

        case "===":
          return left === right;

        case "!==":
          return left !== right;

        case "|":
          return left | right;

        case "&":
          return left & right;

        case "^":
          return left ^ right;

        case "<<":
          return left << right;

        case ">>":
          return left >> right;

        case ">>>":
          return left >>> right;
      }
    }

    if (path.isCallExpression()) {
      const callee = path.get("callee");
      let context;
      let func;

      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
        func = commonjsGlobal[callee.node.name];
      }

      if (callee.isMemberExpression()) {
        const object = callee.get("object");
        const property = callee.get("property");

        if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {
          context = commonjsGlobal[object.node.name];
          func = context[property.node.name];
        }

        if (object.isLiteral() && property.isIdentifier()) {
          const type = typeof object.node.value;

          if (type === "string" || type === "number") {
            context = object.node.value;
            func = context[property.node.name];
          }
        }
      }

      if (func) {
        const args = path.get("arguments").map(arg => evaluateCached(arg, state));
        if (!state.confident) return;
        return func.apply(context, args);
      }
    }

    deopt(path, state);
  }

  function evaluateQuasis(path, quasis, state, raw = false) {
    let str = "";
    let i = 0;
    const exprs = path.get("expressions");

    for (const elem of quasis) {
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      const expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }

    if (!state.confident) return;
    return str;
  }

  function evaluate() {
    const state = {
      confident: true,
      deoptPath: null,
      seen: new Map()
    };
    let value = evaluateCached(this, state);
    if (!state.confident) value = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value
    };
  }

  var conversion = {};

  var lib$2 = {};

  var lib$1 = {};

  Object.defineProperty(lib$1, "__esModule", {
    value: true
  });
  lib$1.default = _default$3;

  var t$d = lib$9;

  function _default$3(node) {
    const params = node.params;

    for (let i = 0; i < params.length; i++) {
      const param = params[i];

      if (t$d.isAssignmentPattern(param) || t$d.isRestElement(param)) {
        return i;
      }
    }

    return params.length;
  }

  var lib = {};

  var formatters$1 = {};

  Object.defineProperty(formatters$1, "__esModule", {
    value: true
  });
  formatters$1.program = formatters$1.expression = formatters$1.statement = formatters$1.statements = formatters$1.smart = void 0;

  var t$c = lib$9;

  function makeStatementFormatter(fn) {
    return {
      code: str => `/* @babel/template */;\n${str}`,
      validate: () => {},
      unwrap: ast => {
        return fn(ast.program.body.slice(1));
      }
    };
  }

  const smart$1 = makeStatementFormatter(body => {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  formatters$1.smart = smart$1;
  const statements$1 = makeStatementFormatter(body => body);
  formatters$1.statements = statements$1;
  const statement$1 = makeStatementFormatter(body => {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }

    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }

    return body[0];
  });
  formatters$1.statement = statement$1;
  const expression$1 = {
    code: str => `(\n${str}\n)`,
    validate: ast => {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }

      if (expression$1.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: ({
      program
    }) => {
      const [stmt] = program.body;
      t$c.assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  formatters$1.expression = expression$1;
  const program$1 = {
    code: str => str,
    validate: () => {},
    unwrap: ast => ast.program
  };
  formatters$1.program = program$1;

  var builder = {};

  var options = {};

  Object.defineProperty(options, "__esModule", {
    value: true
  });
  options.merge = merge$1;
  options.validate = validate;
  options.normalizeReplacements = normalizeReplacements;

  function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function merge$1(a, b) {
    const {
      placeholderWhitelist = a.placeholderWhitelist,
      placeholderPattern = a.placeholderPattern,
      preserveComments = a.preserveComments,
      syntacticPlaceholders = a.syntacticPlaceholders
    } = b;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    };
  }

  function validate(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }

    const _ref = opts || {},
          {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = _ref,
          parser = _objectWithoutPropertiesLoose(_ref, ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]);

    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }

    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }

    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    return {
      parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  }

  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce((acc, replacement, i) => {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || undefined;
    }

    throw new Error("Template replacements must be an array, object, null, or undefined");
  }

  var string = {};

  var parse = {};

  Object.defineProperty(parse, "__esModule", {
    value: true
  });
  parse.default = parseAndBuildMetadata;

  var t$b = lib$9;

  var _parser = lib$b;

  var _codeFrame = lib$5;

  const PATTERN = /^[_$A-Z0-9]+$/;

  function parseAndBuildMetadata(formatter, code, opts) {
    const {
      placeholderWhitelist,
      placeholderPattern,
      preserveComments,
      syntacticPlaceholders
    } = opts;
    const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    t$b.removePropertiesDeep(ast, {
      preserveComments
    });
    formatter.validate(ast);
    const syntactic = {
      placeholders: [],
      placeholderNames: new Set()
    };
    const legacy = {
      placeholders: [],
      placeholderNames: new Set()
    };
    const isLegacyRef = {
      value: undefined
    };
    t$b.traverse(ast, placeholderVisitorHandler, {
      syntactic,
      legacy,
      isLegacyRef,
      placeholderWhitelist,
      placeholderPattern,
      syntacticPlaceholders
    });
    return Object.assign({
      ast
    }, isLegacyRef.value ? legacy : syntactic);
  }

  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;

    let name;

    if (t$b.isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
      } else {
        name = node.name.name;
        state.isLegacyRef.value = false;
      }
    } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
      return;
    } else if (t$b.isIdentifier(node) || t$b.isJSXIdentifier(node)) {
      name = node.name;
      state.isLegacyRef.value = true;
    } else if (t$b.isStringLiteral(node)) {
      name = node.value;
      state.isLegacyRef.value = true;
    } else {
      return;
    }

    if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }

    ancestors = ancestors.slice();
    const {
      node: parent,
      key
    } = ancestors[ancestors.length - 1];
    let type;

    if (t$b.isStringLiteral(node) || t$b.isPlaceholder(node, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (t$b.isNewExpression(parent) && key === "arguments" || t$b.isCallExpression(parent) && key === "arguments" || t$b.isFunction(parent) && key === "params") {
      type = "param";
    } else if (t$b.isExpressionStatement(parent) && !t$b.isPlaceholder(node)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (t$b.isStatement(node) && t$b.isPlaceholder(node)) {
      type = "statement";
    } else {
      type = "other";
    }

    const {
      placeholders,
      placeholderNames
    } = state.isLegacyRef.value ? state.legacy : state.syntactic;
    placeholders.push({
      name,
      type,
      resolve: ast => resolveAncestors(ast, ancestors),
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }

  function resolveAncestors(ast, ancestors) {
    let parent = ast;

    for (let i = 0; i < ancestors.length - 1; i++) {
      const {
        key,
        index
      } = ancestors[i];

      if (index === undefined) {
        parent = parent[key];
      } else {
        parent = parent[key][index];
      }
    }

    const {
      key,
      index
    } = ancestors[ancestors.length - 1];
    return {
      parent,
      key,
      index
    };
  }

  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    const plugins = (parserOpts.plugins || []).slice();

    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }

    parserOpts = Object.assign({
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: "module"
    }, parserOpts, {
      plugins
    });

    try {
      return (0, _parser.parse)(code, parserOpts);
    } catch (err) {
      const loc = err.loc;

      if (loc) {
        err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }

      throw err;
    }
  }

  var populate = {};

  Object.defineProperty(populate, "__esModule", {
    value: true
  });
  populate.default = populatePlaceholders;

  var t$a = lib$9;

  function populatePlaceholders(metadata, replacements) {
    const ast = t$a.cloneNode(metadata.ast);

    if (replacements) {
      metadata.placeholders.forEach(placeholder => {
        if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
          const placeholderName = placeholder.name;
          throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
        }
      });
      Object.keys(replacements).forEach(key => {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error(`Unknown substitution "${key}" given`);
        }
      });
    }

    metadata.placeholders.slice().reverse().forEach(placeholder => {
      try {
        applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
      } catch (e) {
        e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
        throw e;
      }
    });
    return ast;
  }

  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map(node => t$a.cloneNode(node));
      } else if (typeof replacement === "object") {
        replacement = t$a.cloneNode(replacement);
      }
    }

    const {
      parent,
      key,
      index
    } = placeholder.resolve(ast);

    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = t$a.stringLiteral(replacement);
      }

      if (!replacement || !t$a.isStringLiteral(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = t$a.emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = t$a.blockStatement(replacement);
        } else if (typeof replacement === "string") {
          replacement = t$a.expressionStatement(t$a.identifier(replacement));
        } else if (!t$a.isStatement(replacement)) {
          replacement = t$a.expressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = t$a.identifier(replacement);
          }

          if (!t$a.isStatement(replacement)) {
            replacement = t$a.expressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = t$a.identifier(replacement);
      }

      if (index === undefined) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = t$a.identifier(replacement);
      }

      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }

    if (index === undefined) {
      t$a.validate(parent, key, replacement);
      parent[key] = replacement;
    } else {
      const items = parent[key].slice();

      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice(index, 1, ...replacement);
        } else {
          items[index] = replacement;
        }
      } else {
        items[index] = replacement;
      }

      t$a.validate(parent, key, items);
      parent[key] = items;
    }
  }

  Object.defineProperty(string, "__esModule", {
    value: true
  });
  string.default = stringTemplate;

  var _options$2 = options;

  var _parse$1 = parse;

  var _populate$1 = populate;

  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    let metadata;
    return arg => {
      const replacements = (0, _options$2.normalizeReplacements)(arg);
      if (!metadata) metadata = (0, _parse$1.default)(formatter, code, opts);
      return formatter.unwrap((0, _populate$1.default)(metadata, replacements));
    };
  }

  var literal = {};

  Object.defineProperty(literal, "__esModule", {
    value: true
  });
  literal.default = literalTemplate;

  var _options$1 = options;

  var _parse = parse;

  var _populate = populate;

  function literalTemplate(formatter, tpl, opts) {
    const {
      metadata,
      names
    } = buildLiteralData(formatter, tpl, opts);
    return arg => {
      const defaultReplacements = {};
      arg.forEach((replacement, i) => {
        defaultReplacements[names[i]] = replacement;
      });
      return arg => {
        const replacements = (0, _options$1.normalizeReplacements)(arg);

        if (replacements) {
          Object.keys(replacements).forEach(key => {
            if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }

        return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }

  function buildLiteralData(formatter, tpl, opts) {
    let names;
    let nameSet;
    let metadata;
    let prefix = "";

    do {
      prefix += "$";
      const result = buildTemplateCode(tpl, prefix);
      names = result.names;
      nameSet = new Set(names);
      metadata = (0, _parse.default)(formatter, formatter.code(result.code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
    } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));

    return {
      metadata,
      names
    };
  }

  function buildTemplateCode(tpl, prefix) {
    const names = [];
    let code = tpl[0];

    for (let i = 1; i < tpl.length; i++) {
      const value = `${prefix}${i - 1}`;
      names.push(value);
      code += value + tpl[i];
    }

    return {
      names,
      code
    };
  }

  Object.defineProperty(builder, "__esModule", {
    value: true
  });
  builder.default = createTemplateBuilder;

  var _options = options;

  var _string = string;

  var _literal = literal;

  const NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: false
  });

  function createTemplateBuilder(formatter, defaultOpts) {
    const templateFnCache = new WeakMap();
    const templateAstCache = new WeakMap();
    const cachedOpts = defaultOpts || (0, _options.validate)(null);
    return Object.assign((tpl, ...args) => {
      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
      } else if (Array.isArray(tpl)) {
        let builder = templateFnCache.get(tpl);

        if (!builder) {
          builder = (0, _literal.default)(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }

        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
      }

      throw new Error(`Unexpected template param ${typeof tpl}`);
    }, {
      ast: (tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          let builder = templateAstCache.get(tpl);

          if (!builder) {
            builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder);
          }

          return builder(args)();
        }

        throw new Error(`Unexpected template param ${typeof tpl}`);
      }
    });
  }

  function extendedTrace(fn) {
    let rootStack = "";

    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }

    return arg => {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += `\n    =============\n${rootStack}`;
        throw err;
      }
    };
  }

  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  lib.default = lib.program = lib.expression = lib.statements = lib.statement = lib.smart = void 0;

  var formatters = formatters$1;

  var _builder = builder;

  const smart = (0, _builder.default)(formatters.smart);
  lib.smart = smart;
  const statement = (0, _builder.default)(formatters.statement);
  lib.statement = statement;
  const statements = (0, _builder.default)(formatters.statements);
  lib.statements = statements;
  const expression = (0, _builder.default)(formatters.expression);
  lib.expression = expression;
  const program = (0, _builder.default)(formatters.program);
  lib.program = program;

  var _default$2 = Object.assign(smart.bind(undefined), {
    smart,
    statement,
    statements,
    expression,
    program,
    ast: smart.ast
  });

  lib.default = _default$2;

  Object.defineProperty(lib$2, "__esModule", {
    value: true
  });
  lib$2.default = _default$1;

  var _helperGetFunctionArity = lib$1;

  var _template = lib;

  var t$9 = lib$9;

  const buildPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`);
  const buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`);
  const visitor = {
    "ReferencedIdentifier|BindingIdentifier"(path, state) {
      if (path.node.name !== state.name) return;
      const localDeclar = path.scope.getBindingIdentifier(state.name);
      if (localDeclar !== state.outerDeclar) return;
      state.selfReference = true;
      path.stop();
    }

  };

  function getNameFromLiteralId(id) {
    if (t$9.isNullLiteral(id)) {
      return "null";
    }

    if (t$9.isRegExpLiteral(id)) {
      return `_${id.pattern}_${id.flags}`;
    }

    if (t$9.isTemplateLiteral(id)) {
      return id.quasis.map(quasi => quasi.value.raw).join("");
    }

    if (id.value !== undefined) {
      return id.value + "";
    }

    return "";
  }

  function wrap(state, method, id, scope) {
    if (state.selfReference) {
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
      } else {
        if (!t$9.isFunction(method)) return;
        let build = buildPropertyMethodAssignmentWrapper;

        if (method.generator) {
          build = buildGeneratorPropertyMethodAssignmentWrapper;
        }

        const template = build({
          FUNCTION: method,
          FUNCTION_ID: id,
          FUNCTION_KEY: scope.generateUidIdentifier(id.name)
        }).expression;
        const params = template.callee.body.body[0].params;

        for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) {
          params.push(scope.generateUidIdentifier("x"));
        }

        return template;
      }
    }

    method.id = id;
    scope.getProgramParent().references[id.name] = true;
  }

  function visit$1(node, name, scope) {
    const state = {
      selfAssignment: false,
      selfReference: false,
      outerDeclar: scope.getBindingIdentifier(name),
      references: [],
      name: name
    };
    const binding = scope.getOwnBinding(name);

    if (binding) {
      if (binding.kind === "param") {
        state.selfReference = true;
      }
    } else if (state.outerDeclar || scope.hasGlobal(name)) {
      scope.traverse(node, visitor, state);
    }

    return state;
  }

  function _default$1({
    node,
    parent,
    scope,
    id
  }, localBinding = false) {
    if (node.id) return;

    if ((t$9.isObjectProperty(parent) || t$9.isObjectMethod(parent, {
      kind: "method"
    })) && (!parent.computed || t$9.isLiteral(parent.key))) {
      id = parent.key;
    } else if (t$9.isVariableDeclarator(parent)) {
      id = parent.id;

      if (t$9.isIdentifier(id) && !localBinding) {
        const binding = scope.parent.getBinding(id.name);

        if (binding && binding.constant && scope.getBinding(id.name) === binding) {
          node.id = t$9.cloneNode(id);
          node.id[t$9.NOT_LOCAL_BINDING] = true;
          return;
        }
      }
    } else if (t$9.isAssignmentExpression(parent, {
      operator: "="
    })) {
      id = parent.left;
    } else if (!id) {
      return;
    }

    let name;

    if (id && t$9.isLiteral(id)) {
      name = getNameFromLiteralId(id);
    } else if (id && t$9.isIdentifier(id)) {
      name = id.name;
    }

    if (name === undefined) {
      return;
    }

    name = t$9.toBindingIdentifierName(name);
    id = t$9.identifier(name);
    id[t$9.NOT_LOCAL_BINDING] = true;
    const state = visit$1(node, name, scope);
    return wrap(state, node, id, scope) || node;
  }

  Object.defineProperty(conversion, "__esModule", {
    value: true
  });
  conversion.toComputedKey = toComputedKey;
  conversion.ensureBlock = ensureBlock;
  conversion.arrowFunctionToShadowed = arrowFunctionToShadowed;
  conversion.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
  conversion.arrowFunctionToExpression = arrowFunctionToExpression;

  var t$8 = lib$9;

  var _helperFunctionName = lib$2;

  function toComputedKey() {
    let key;

    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError("todo");
    }

    if (!this.node.computed) {
      if (t$8.isIdentifier(key)) key = t$8.stringLiteral(key.name);
    }

    return key;
  }

  function ensureBlock() {
    const body = this.get("body");
    const bodyNode = body.node;

    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }

    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }

    if (body.isBlockStatement()) {
      return bodyNode;
    }

    const statements = [];
    let stringPath = "body";
    let key;
    let listKey;

    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += ".body.0";

      if (this.isFunction()) {
        key = "argument";
        statements.push(t$8.returnStatement(body.node));
      } else {
        key = "expression";
        statements.push(t$8.expressionStatement(body.node));
      }
    }

    this.node.body = t$8.blockStatement(statements);
    const parentPath = this.get(stringPath);
    body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }

  function arrowFunctionToShadowed() {
    if (!this.isArrowFunctionExpression()) return;
    this.arrowFunctionToExpression();
  }

  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }

    hoistFunctionEnvironment(this);
  }

  function arrowFunctionToExpression({
    allowInsertArrow = true,
    specCompliant = false,
    noNewArrows = !specCompliant
  } = {}) {
    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }

    const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);
    this.ensureBlock();
    this.node.type = "FunctionExpression";

    if (!noNewArrows) {
      const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

      if (checkBinding) {
        this.parentPath.scope.push({
          id: checkBinding,
          init: t$8.objectExpression([])
        });
      }

      this.get("body").unshiftContainer("body", t$8.expressionStatement(t$8.callExpression(this.hub.addHelper("newArrowCheck"), [t$8.thisExpression(), checkBinding ? t$8.identifier(checkBinding.name) : t$8.identifier(thisBinding)])));
      this.replaceWith(t$8.callExpression(t$8.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t$8.identifier("bind")), [checkBinding ? t$8.identifier(checkBinding.name) : t$8.thisExpression()]));
    }
  }

  function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {
    const thisEnvFn = fnPath.findParent(p => {
      return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
        static: false
      });
    });
    const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === "constructor";

    if (thisEnvFn.isClassProperty()) {
      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
    }

    const {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    } = getScopeInformation(fnPath);

    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
      }

      const allSuperCalls = [];
      thisEnvFn.traverse({
        Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },

        ClassProperty(child) {
          child.skip();
        },

        CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          allSuperCalls.push(child);
        }

      });
      const superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach(superCall => {
        const callee = t$8.identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }

    if (argumentsPaths.length > 0) {
      const argumentsBinding = getBinding(thisEnvFn, "arguments", () => t$8.identifier("arguments"));
      argumentsPaths.forEach(argumentsChild => {
        const argsRef = t$8.identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }

    if (newTargetPaths.length > 0) {
      const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => t$8.metaProperty(t$8.identifier("new"), t$8.identifier("target")));
      newTargetPaths.forEach(targetChild => {
        const targetRef = t$8.identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }

    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
      }

      const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
      flatSuperProps.forEach(superProp => {
        const key = superProp.node.computed ? "" : superProp.get("property").node.name;
        const isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node
        });
        const isCall = superProp.parentPath.isCallExpression({
          callee: superProp.node
        });
        const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        const args = [];

        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }

        if (isAssignment) {
          const value = superProp.parentPath.node.right;
          args.push(value);
        }

        const call = t$8.callExpression(t$8.identifier(superBinding), args);

        if (isCall) {
          superProp.parentPath.unshiftContainer("arguments", t$8.thisExpression());
          superProp.replaceWith(t$8.memberExpression(call, t$8.identifier("call")));
          thisPaths.push(superProp.parentPath.get("arguments.0"));
        } else if (isAssignment) {
          superProp.parentPath.replaceWith(call);
        } else {
          superProp.replaceWith(call);
        }
      });
    }

    let thisBinding;

    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);

      if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach(thisChild => {
          const thisRef = thisChild.isJSX() ? t$8.jsxIdentifier(thisBinding) : t$8.identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows) thisBinding = null;
      }
    }

    return thisBinding;
  }

  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      const assignmentPath = superProp.parentPath;
      const op = assignmentPath.node.operator.slice(0, -1);
      const value = assignmentPath.node.right;
      assignmentPath.node.operator = "=";

      if (superProp.node.computed) {
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        assignmentPath.get("left").replaceWith(t$8.memberExpression(superProp.node.object, t$8.assignmentExpression("=", tmp, superProp.node.property), true));
        assignmentPath.get("right").replaceWith(t$8.binaryExpression(op, t$8.memberExpression(superProp.node.object, t$8.identifier(tmp.name), true), value));
      } else {
        assignmentPath.get("left").replaceWith(t$8.memberExpression(superProp.node.object, superProp.node.property));
        assignmentPath.get("right").replaceWith(t$8.binaryExpression(op, t$8.memberExpression(superProp.node.object, t$8.identifier(superProp.node.property.name)), value));
      }

      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      const updateExpr = superProp.parentPath;
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      const parts = [t$8.assignmentExpression("=", tmp, t$8.memberExpression(superProp.node.object, computedKey ? t$8.assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t$8.assignmentExpression("=", t$8.memberExpression(superProp.node.object, computedKey ? t$8.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t$8.binaryExpression("+", t$8.identifier(tmp.name), t$8.numericLiteral(1)))];

      if (!superProp.parentPath.node.prefix) {
        parts.push(t$8.identifier(tmp.name));
      }

      updateExpr.replaceWith(t$8.sequenceExpression(parts));
      const left = updateExpr.get("expressions.0.right");
      const right = updateExpr.get("expressions.1.left");
      return [left, right];
    }

    return [superProp];
  }

  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }

  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", thisBinding => {
      if (!inConstructor || !hasSuperClass(thisEnvFn)) return t$8.thisExpression();
      const supers = new WeakSet();
      thisEnvFn.traverse({
        Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },

        ClassProperty(child) {
          child.skip();
        },

        CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          if (supers.has(child.node)) return;
          supers.add(child.node);
          child.replaceWithMultiple([child.node, t$8.assignmentExpression("=", t$8.identifier(thisBinding), t$8.identifier("this"))]);
        }

      });
    });
  }

  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", () => {
      const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return t$8.arrowFunctionExpression([t$8.restElement(argsBinding)], t$8.callExpression(t$8.super(), [t$8.spreadElement(t$8.identifier(argsBinding.name))]));
    });
  }

  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    const op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
      const argsList = [];
      let fnBody;

      if (propName) {
        fnBody = t$8.memberExpression(t$8.super(), t$8.identifier(propName));
      } else {
        const method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = t$8.memberExpression(t$8.super(), t$8.identifier(method.name), true);
      }

      if (isAssignment) {
        const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = t$8.assignmentExpression("=", fnBody, t$8.identifier(valueIdent.name));
      }

      return t$8.arrowFunctionExpression(argsList, fnBody);
    });
  }

  function getBinding(thisEnvFn, key, init) {
    const cacheKey = "binding:" + key;
    let data = thisEnvFn.getData(cacheKey);

    if (!data) {
      const id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id: id,
        init: init(data)
      });
    }

    return data;
  }

  function getScopeInformation(fnPath) {
    const thisPaths = [];
    const argumentsPaths = [];
    const newTargetPaths = [];
    const superProps = [];
    const superCalls = [];
    fnPath.traverse({
      ClassProperty(child) {
        child.skip();
      },

      Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },

      ThisExpression(child) {
        thisPaths.push(child);
      },

      JSXIdentifier(child) {
        if (child.node.name !== "this") return;

        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }

        thisPaths.push(child);
      },

      CallExpression(child) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },

      MemberExpression(child) {
        if (child.get("object").isSuper()) superProps.push(child);
      },

      ReferencedIdentifier(child) {
        if (child.node.name !== "arguments") return;
        argumentsPaths.push(child);
      },

      MetaProperty(child) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }

    });
    return {
      thisPaths,
      argumentsPaths,
      newTargetPaths,
      superProps,
      superCalls
    };
  }

  var introspection = {};

  Object.defineProperty(introspection, "__esModule", {
    value: true
  });
  introspection.matchesPattern = matchesPattern;
  introspection.has = has;
  introspection.isStatic = isStatic;
  introspection.isnt = isnt;
  introspection.equals = equals;
  introspection.isNodeType = isNodeType;
  introspection.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
  introspection.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
  introspection.isCompletionRecord = isCompletionRecord;
  introspection.isStatementOrBlock = isStatementOrBlock;
  introspection.referencesImport = referencesImport;
  introspection.getSource = getSource;
  introspection.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
  introspection._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
  introspection._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;
  introspection.resolve = resolve;
  introspection._resolve = _resolve;
  introspection.isConstantExpression = isConstantExpression;
  introspection.isInStrictMode = isInStrictMode;
  introspection.is = void 0;

  var t$7 = lib$9;

  function matchesPattern(pattern, allowPartial) {
    return t$7.matchesPattern(this.node, pattern, allowPartial);
  }

  function has(key) {
    const val = this.node && this.node[key];

    if (val && Array.isArray(val)) {
      return !!val.length;
    } else {
      return !!val;
    }
  }

  function isStatic() {
    return this.scope.isStatic(this.node);
  }

  const is = has;
  introspection.is = is;

  function isnt(key) {
    return !this.has(key);
  }

  function equals(key, value) {
    return this.node[key] === value;
  }

  function isNodeType(type) {
    return t$7.isType(this.type, type);
  }

  function canHaveVariableDeclarationOrExpression() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }

  function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
      return false;
    }

    if (this.isExpression()) {
      return t$7.isBlockStatement(replacement);
    } else if (this.isBlockStatement()) {
      return t$7.isExpression(replacement);
    }

    return false;
  }

  function isCompletionRecord(allowInsideFunction) {
    let path = this;
    let first = true;

    do {
      const container = path.container;

      if (path.isFunction() && !first) {
        return !!allowInsideFunction;
      }

      first = false;

      if (Array.isArray(container) && path.key !== container.length - 1) {
        return false;
      }
    } while ((path = path.parentPath) && !path.isProgram());

    return true;
  }

  function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || t$7.isBlockStatement(this.container)) {
      return false;
    } else {
      return t$7.STATEMENT_OR_BLOCK_KEYS.includes(this.key);
    }
  }

  function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) {
      if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t$7.isStringLiteral(this.node.property, {
        value: importName
      }) : this.node.property.name === importName)) {
        const object = this.get("object");
        return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
      }

      return false;
    }

    const binding = this.scope.getBinding(this.node.name);
    if (!binding || binding.kind !== "module") return false;
    const path = binding.path;
    const parent = path.parentPath;
    if (!parent.isImportDeclaration()) return false;

    if (parent.node.source.value === moduleSource) {
      if (!importName) return true;
    } else {
      return false;
    }

    if (path.isImportDefaultSpecifier() && importName === "default") {
      return true;
    }

    if (path.isImportNamespaceSpecifier() && importName === "*") {
      return true;
    }

    if (path.isImportSpecifier() && t$7.isIdentifier(path.node.imported, {
      name: importName
    })) {
      return true;
    }

    return false;
  }

  function getSource() {
    const node = this.node;

    if (node.end) {
      const code = this.hub.getCode();
      if (code) return code.slice(node.start, node.end);
    }

    return "";
  }

  function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== "after";
  }

  function getOuterFunction(path) {
    return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
  }

  function isExecutionUncertain(type, key) {
    switch (type) {
      case "LogicalExpression":
        return key === "right";

      case "ConditionalExpression":
      case "IfStatement":
        return key === "consequent" || key === "alternate";

      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return key === "body";

      case "ForStatement":
        return key === "body" || key === "update";

      case "SwitchStatement":
        return key === "cases";

      case "TryStatement":
        return key === "handler";

      case "AssignmentPattern":
        return key === "right";

      case "OptionalMemberExpression":
        return key === "property";

      case "OptionalCallExpression":
        return key === "arguments";

      default:
        return false;
    }
  }

  function isExecutionUncertainInList(paths, maxIndex) {
    for (let i = 0; i < maxIndex; i++) {
      const path = paths[i];

      if (isExecutionUncertain(path.parent.type, path.parentKey)) {
        return true;
      }
    }

    return false;
  }

  function _guessExecutionStatusRelativeTo(target) {
    const funcParent = {
      this: getOuterFunction(this),
      target: getOuterFunction(target)
    };

    if (funcParent.target.node !== funcParent.this.node) {
      return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
    }

    const paths = {
      target: target.getAncestry(),
      this: this.getAncestry()
    };
    if (paths.target.indexOf(this) >= 0) return "after";
    if (paths.this.indexOf(target) >= 0) return "before";
    let commonPath;
    const commonIndex = {
      target: 0,
      this: 0
    };

    while (!commonPath && commonIndex.this < paths.this.length) {
      const path = paths.this[commonIndex.this];
      commonIndex.target = paths.target.indexOf(path);

      if (commonIndex.target >= 0) {
        commonPath = path;
      } else {
        commonIndex.this++;
      }
    }

    if (!commonPath) {
      throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
    }

    if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
      return "unknown";
    }

    const divergence = {
      this: paths.this[commonIndex.this - 1],
      target: paths.target[commonIndex.target - 1]
    };

    if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
      return divergence.target.key > divergence.this.key ? "before" : "after";
    }

    const keys = t$7.VISITOR_KEYS[commonPath.type];
    const keyPosition = {
      this: keys.indexOf(divergence.this.parentKey),
      target: keys.indexOf(divergence.target.parentKey)
    };
    return keyPosition.target > keyPosition.this ? "before" : "after";
  }

  const executionOrderCheckedNodes = new WeakSet();

  function _guessExecutionStatusRelativeToDifferentFunctions(target) {
    if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
      return "unknown";
    }

    const binding = target.scope.getBinding(target.node.id.name);
    if (!binding.references) return "before";
    const referencePaths = binding.referencePaths;
    let allStatus;

    for (const path of referencePaths) {
      const childOfFunction = !!path.find(path => path.node === target.node);
      if (childOfFunction) continue;

      if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
        return "unknown";
      }

      if (executionOrderCheckedNodes.has(path.node)) continue;
      executionOrderCheckedNodes.add(path.node);

      const status = this._guessExecutionStatusRelativeTo(path);

      executionOrderCheckedNodes.delete(path.node);

      if (allStatus && allStatus !== status) {
        return "unknown";
      } else {
        allStatus = status;
      }
    }

    return allStatus;
  }

  function resolve(dangerous, resolved) {
    return this._resolve(dangerous, resolved) || this;
  }

  function _resolve(dangerous, resolved) {
    if (resolved && resolved.indexOf(this) >= 0) return;
    resolved = resolved || [];
    resolved.push(this);

    if (this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) {
        return this.get("init").resolve(dangerous, resolved);
      }
    } else if (this.isReferencedIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      if (!binding) return;
      if (!binding.constant) return;
      if (binding.kind === "module") return;

      if (binding.path !== this) {
        const ret = binding.path.resolve(dangerous, resolved);
        if (this.find(parent => parent.node === ret.node)) return;
        return ret;
      }
    } else if (this.isTypeCastExpression()) {
      return this.get("expression").resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
      const targetKey = this.toComputedKey();
      if (!t$7.isLiteral(targetKey)) return;
      const targetName = targetKey.value;
      const target = this.get("object").resolve(dangerous, resolved);

      if (target.isObjectExpression()) {
        const props = target.get("properties");

        for (const prop of props) {
          if (!prop.isProperty()) continue;
          const key = prop.get("key");
          let match = prop.isnt("computed") && key.isIdentifier({
            name: targetName
          });
          match = match || key.isLiteral({
            value: targetName
          });
          if (match) return prop.get("value").resolve(dangerous, resolved);
        }
      } else if (target.isArrayExpression() && !isNaN(+targetName)) {
        const elems = target.get("elements");
        const elem = elems[targetName];
        if (elem) return elem.resolve(dangerous, resolved);
      }
    }
  }

  function isConstantExpression() {
    if (this.isIdentifier()) {
      const binding = this.scope.getBinding(this.node.name);
      if (!binding) return false;
      return binding.constant;
    }

    if (this.isLiteral()) {
      if (this.isRegExpLiteral()) {
        return false;
      }

      if (this.isTemplateLiteral()) {
        return this.get("expressions").every(expression => expression.isConstantExpression());
      }

      return true;
    }

    if (this.isUnaryExpression()) {
      if (this.node.operator !== "void") {
        return false;
      }

      return this.get("argument").isConstantExpression();
    }

    if (this.isBinaryExpression()) {
      return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }

    return false;
  }

  function isInStrictMode() {
    const start = this.isProgram() ? this : this.parentPath;
    const strictParent = start.find(path => {
      if (path.isProgram({
        sourceType: "module"
      })) return true;
      if (path.isClass()) return true;
      if (!path.isProgram() && !path.isFunction()) return false;

      if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
        return false;
      }

      const body = path.isFunction() ? path.node.body : path.node;

      for (const directive of body.directives) {
        if (directive.value.value === "use strict") {
          return true;
        }
      }
    });
    return !!strictParent;
  }

  var context = {};

  Object.defineProperty(context, "__esModule", {
    value: true
  });
  context.call = call;
  context._call = _call;
  context.isBlacklisted = context.isDenylisted = isDenylisted;
  context.visit = visit;
  context.skip = skip;
  context.skipKey = skipKey;
  context.stop = stop;
  context.setScope = setScope;
  context.setContext = setContext;
  context.resync = resync;
  context._resyncParent = _resyncParent;
  context._resyncKey = _resyncKey;
  context._resyncList = _resyncList;
  context._resyncRemoved = _resyncRemoved;
  context.popContext = popContext;
  context.pushContext = pushContext;
  context.setup = setup;
  context.setKey = setKey;
  context.requeue = requeue;
  context._getQueueContexts = _getQueueContexts;

  var _index$4 = lib$a;

  var _index2 = path$1;

  function call(key) {
    const opts = this.opts;
    this.debug(key);

    if (this.node) {
      if (this._call(opts[key])) return true;
    }

    if (this.node) {
      return this._call(opts[this.node.type] && opts[this.node.type][key]);
    }

    return false;
  }

  function _call(fns) {
    if (!fns) return false;

    for (const fn of fns) {
      if (!fn) continue;
      const node = this.node;
      if (!node) return true;
      const ret = fn.call(this.state, this, this.state);

      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);
      }

      if (ret) {
        throw new Error(`Unexpected return value from visitor method ${fn}`);
      }

      if (this.node !== node) return true;
      if (this._traverseFlags > 0) return true;
    }

    return false;
  }

  function isDenylisted() {
    var _this$opts$denylist;

    const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist && denylist.indexOf(this.node.type) > -1;
  }

  function visit() {
    if (!this.node) {
      return false;
    }

    if (this.isDenylisted()) {
      return false;
    }

    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
      return false;
    }

    if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
      this.debug("Skip...");
      return this.shouldStop;
    }

    this.debug("Recursing into...");

    _index$4.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);

    this.call("exit");
    return this.shouldStop;
  }

  function skip() {
    this.shouldSkip = true;
  }

  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }

    this.skipKeys[key] = true;
  }

  function stop() {
    this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;
  }

  function setScope() {
    if (this.opts && this.opts.noScope) return;
    let path = this.parentPath;
    if (this.key === "key" && path.isMethod()) path = path.parentPath;
    let target;

    while (path && !target) {
      if (path.opts && path.opts.noScope) return;
      target = path.scope;
      path = path.parentPath;
    }

    this.scope = this.getScope(target);
    if (this.scope) this.scope.init();
  }

  function setContext(context) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }

    this._traverseFlags = 0;

    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }

    this.setScope();
    return this;
  }

  function resync() {
    if (this.removed) return;

    this._resyncParent();

    this._resyncList();

    this._resyncKey();
  }

  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }

  function _resyncKey() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) return;

    if (Array.isArray(this.container)) {
      for (let i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          return this.setKey(i);
        }
      }
    } else {
      for (const key of Object.keys(this.container)) {
        if (this.container[key] === this.node) {
          return this.setKey(key);
        }
      }
    }

    this.key = null;
  }

  function _resyncList() {
    if (!this.parent || !this.inList) return;
    const newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }

  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      this._markRemoved();
    }
  }

  function popContext() {
    this.contexts.pop();

    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(undefined);
    }
  }

  function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
  }

  function setup(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    this.setKey(key);
  }

  function setKey(key) {
    var _this$node;

    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
  }

  function requeue(pathToQueue = this) {
    if (pathToQueue.removed) return;
    const contexts = this.contexts;

    for (const context of contexts) {
      context.maybeQueue(pathToQueue);
    }
  }

  function _getQueueContexts() {
    let path = this;
    let contexts = this.contexts;

    while (!contexts.length) {
      path = path.parentPath;
      if (!path) break;
      contexts = path.contexts;
    }

    return contexts;
  }

  var removal = {};

  var removalHooks = {};

  Object.defineProperty(removalHooks, "__esModule", {
    value: true
  });
  removalHooks.hooks = void 0;
  const hooks = [function (self, parent) {
    const removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function (self, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function (self, parent) {
    if (parent.isBinary()) {
      if (self.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }

      return true;
    }
  }, function (self, parent) {
    if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self.replaceWith({
        type: "BlockStatement",
        body: []
      });
      return true;
    }
  }];
  removalHooks.hooks = hooks;

  Object.defineProperty(removal, "__esModule", {
    value: true
  });
  removal.remove = remove;
  removal._removeFromScope = _removeFromScope;
  removal._callRemovalHooks = _callRemovalHooks;
  removal._remove = _remove;
  removal._markRemoved = _markRemoved;
  removal._assertUnremoved = _assertUnremoved;

  var _removalHooks = removalHooks;

  var _cache$2 = cache;

  var _index$3 = path$1;

  function remove() {
    var _this$opts;

    this._assertUnremoved();

    this.resync();

    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      this._removeFromScope();
    }

    if (this._callRemovalHooks()) {
      this._markRemoved();

      return;
    }

    this.shareCommentsWithSiblings();

    this._remove();

    this._markRemoved();
  }

  function _removeFromScope() {
    const bindings = this.getBindingIdentifiers();
    Object.keys(bindings).forEach(name => this.scope.removeBinding(name));
  }

  function _callRemovalHooks() {
    for (const fn of _removalHooks.hooks) {
      if (fn(this, this.parentPath)) return true;
    }
  }

  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this._replaceWith(null);
    }
  }

  function _markRemoved() {
    this._traverseFlags |= _index$3.SHOULD_SKIP | _index$3.REMOVED;
    if (this.parent) _cache$2.path.get(this.parent).delete(this.node);
    this.node = null;
  }

  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }

  var modification = {};

  var hoister = {};

  Object.defineProperty(hoister, "__esModule", {
    value: true
  });
  hoister.default = void 0;

  var t$6 = lib$9;

  const referenceVisitor = {
    ReferencedIdentifier(path, state) {
      if (path.isJSXIdentifier() && t$6.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
        return;
      }

      if (path.node.name === "this") {
        let scope = path.scope;

        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope = scope.parent);

        if (scope) state.breakOnScopePaths.push(scope.path);
      }

      const binding = path.scope.getBinding(path.node.name);
      if (!binding) return;

      for (const violation of binding.constantViolations) {
        if (violation.scope !== binding.path.scope) {
          state.mutableBinding = true;
          path.stop();
          return;
        }
      }

      if (binding !== state.scope.getBinding(path.node.name)) return;
      state.bindings[path.node.name] = binding;
    }

  };

  class PathHoister {
    constructor(path, scope) {
      this.breakOnScopePaths = void 0;
      this.bindings = void 0;
      this.mutableBinding = void 0;
      this.scopes = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.attachAfter = void 0;
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope;
      this.path = path;
      this.attachAfter = false;
    }

    isCompatibleScope(scope) {
      for (const key of Object.keys(this.bindings)) {
        const binding = this.bindings[key];

        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
          return false;
        }
      }

      return true;
    }

    getCompatibleScopes() {
      let scope = this.path.scope;

      do {
        if (this.isCompatibleScope(scope)) {
          this.scopes.push(scope);
        } else {
          break;
        }

        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
          break;
        }
      } while (scope = scope.parent);
    }

    getAttachmentPath() {
      let path = this._getAttachmentPath();

      if (!path) return;
      let targetScope = path.scope;

      if (targetScope.path === path) {
        targetScope = path.scope.parent;
      }

      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (const name of Object.keys(this.bindings)) {
          if (!targetScope.hasOwnBinding(name)) continue;
          const binding = this.bindings[name];

          if (binding.kind === "param" || binding.path.parentKey === "params") {
            continue;
          }

          const bindingParentPath = this.getAttachmentParentForPath(binding.path);

          if (bindingParentPath.key >= path.key) {
            this.attachAfter = true;
            path = binding.path;

            for (const violationPath of binding.constantViolations) {
              if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                path = violationPath;
              }
            }
          }
        }
      }

      return path;
    }

    _getAttachmentPath() {
      const scopes = this.scopes;
      const scope = scopes.pop();
      if (!scope) return;

      if (scope.path.isFunction()) {
        if (this.hasOwnParamBindings(scope)) {
          if (this.scope === scope) return;
          const bodies = scope.path.get("body").get("body");

          for (let i = 0; i < bodies.length; i++) {
            if (bodies[i].node._blockHoist) continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    }

    getNextScopeAttachmentParent() {
      const scope = this.scopes.pop();
      if (scope) return this.getAttachmentParentForPath(scope.path);
    }

    getAttachmentParentForPath(path) {
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          return path;
        }
      } while (path = path.parentPath);
    }

    hasOwnParamBindings(scope) {
      for (const name of Object.keys(this.bindings)) {
        if (!scope.hasOwnBinding(name)) continue;
        const binding = this.bindings[name];
        if (binding.kind === "param" && binding.constant) return true;
      }

      return false;
    }

    run() {
      this.path.traverse(referenceVisitor, this);
      if (this.mutableBinding) return;
      this.getCompatibleScopes();
      const attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      let uid = attachTo.scope.generateUidIdentifier("ref");
      const declarator = t$6.variableDeclarator(uid, this.path.node);
      const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
      const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t$6.variableDeclaration("var", [declarator])]);
      const parent = this.path.parentPath;

      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = t$6.jsxExpressionContainer(uid);
      }

      this.path.replaceWith(t$6.cloneNode(uid));
      return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    }

  }

  hoister.default = PathHoister;

  Object.defineProperty(modification, "__esModule", {
    value: true
  });
  modification.insertBefore = insertBefore;
  modification._containerInsert = _containerInsert;
  modification._containerInsertBefore = _containerInsertBefore;
  modification._containerInsertAfter = _containerInsertAfter;
  modification.insertAfter = insertAfter;
  modification.updateSiblingKeys = updateSiblingKeys;
  modification._verifyNodeList = _verifyNodeList;
  modification.unshiftContainer = unshiftContainer;
  modification.pushContainer = pushContainer;
  modification.hoist = hoist;

  var _cache$1 = cache;

  var _hoister = hoister;

  var _index$2 = path$1;

  var t$5 = lib$9;

  function insertBefore(nodes_) {
    this._assertUnremoved();

    const nodes = this._verifyNodeList(nodes_);

    const {
      parentPath
    } = this;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      const node = this.node;
      const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(t$5.blockStatement(shouldInsertCurrentNode ? [node] : []));
      return this.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }

  function _containerInsert(from, nodes) {
    this.updateSiblingKeys(from, nodes.length);
    const paths = [];
    this.container.splice(from, 0, ...nodes);

    for (let i = 0; i < nodes.length; i++) {
      const to = from + i;
      const path = this.getSibling(to);
      paths.push(path);

      if (this.context && this.context.queue) {
        path.pushContext(this.context);
      }
    }

    const contexts = this._getQueueContexts();

    for (const path of paths) {
      path.setScope();
      path.debug("Inserted.");

      for (const context of contexts) {
        context.maybeQueue(path, true);
      }
    }

    return paths;
  }

  function _containerInsertBefore(nodes) {
    return this._containerInsert(this.key, nodes);
  }

  function _containerInsertAfter(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }

  function insertAfter(nodes_) {
    this._assertUnremoved();

    const nodes = this._verifyNodeList(nodes_);

    const {
      parentPath
    } = this;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map(node => {
        return t$5.isExpression(node) ? t$5.expressionStatement(node) : node;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) {
        const node = this.node;
        let {
          scope
        } = this;

        if (scope.path.isPattern()) {
          t$5.assertExpression(node);
          this.replaceWith(t$5.callExpression(t$5.arrowFunctionExpression([], node), []));
          this.get("callee.body").insertAfter(nodes);
          return [this];
        }

        if (parentPath.isMethod({
          computed: true,
          key: node
        })) {
          scope = scope.parent;
        }

        const temp = scope.generateDeclaredUidIdentifier();
        nodes.unshift(t$5.expressionStatement(t$5.assignmentExpression("=", t$5.cloneNode(temp), node)));
        nodes.push(t$5.expressionStatement(t$5.cloneNode(temp)));
      }

      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      const node = this.node;
      const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(t$5.blockStatement(shouldInsertCurrentNode ? [node] : []));
      return this.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }

  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;

    const paths = _cache$1.path.get(this.parent);

    for (const [, path] of paths) {
      if (path.key >= fromIndex) {
        path.key += incrementBy;
      }
    }
  }

  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }

    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      let msg;

      if (!node) {
        msg = "has falsy node";
      } else if (typeof node !== "object") {
        msg = "contains a non-object node";
      } else if (!node.type) {
        msg = "without a type";
      } else if (node instanceof _index$2.default) {
        msg = "has a NodePath when it expected a raw object";
      }

      if (msg) {
        const type = Array.isArray(node) ? "array" : typeof node;
        throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
      }
    }

    return nodes;
  }

  function unshiftContainer(listKey, nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);

    const path = _index$2.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey,
      key: 0
    }).setContext(this.context);

    return path._containerInsertBefore(nodes);
  }

  function pushContainer(listKey, nodes) {
    this._assertUnremoved();

    const verifiedNodes = this._verifyNodeList(nodes);

    const container = this.node[listKey];

    const path = _index$2.default.get({
      parentPath: this,
      parent: this.node,
      container: container,
      listKey,
      key: container.length
    }).setContext(this.context);

    return path.replaceWithMultiple(verifiedNodes);
  }

  function hoist(scope = this.scope) {
    const hoister = new _hoister.default(this, scope);
    return hoister.run();
  }

  var family = {};

  Object.defineProperty(family, "__esModule", {
    value: true
  });
  family.getOpposite = getOpposite;
  family.getCompletionRecords = getCompletionRecords;
  family.getSibling = getSibling;
  family.getPrevSibling = getPrevSibling;
  family.getNextSibling = getNextSibling;
  family.getAllNextSiblings = getAllNextSiblings;
  family.getAllPrevSiblings = getAllPrevSiblings;
  family.get = get;
  family._getKey = _getKey;
  family._getPattern = _getPattern;
  family.getBindingIdentifiers = getBindingIdentifiers;
  family.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
  family.getBindingIdentifierPaths = getBindingIdentifierPaths;
  family.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;

  var _index$1 = path$1;

  var t$4 = lib$9;

  const NORMAL_COMPLETION = 0;
  const BREAK_COMPLETION = 1;

  function NormalCompletion(path) {
    return {
      type: NORMAL_COMPLETION,
      path
    };
  }

  function BreakCompletion(path) {
    return {
      type: BREAK_COMPLETION,
      path
    };
  }

  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }

    return null;
  }

  function addCompletionRecords(path, records, context) {
    if (path) return records.concat(_getCompletionRecords(path, context));
    return records;
  }

  function completionRecordForSwitch(cases, records, context) {
    let lastNormalCompletions = [];

    for (let i = 0; i < cases.length; i++) {
      const casePath = cases[i];

      const caseCompletions = _getCompletionRecords(casePath, context);

      const normalCompletions = [];
      const breakCompletions = [];

      for (const c of caseCompletions) {
        if (c.type === NORMAL_COMPLETION) {
          normalCompletions.push(c);
        }

        if (c.type === BREAK_COMPLETION) {
          breakCompletions.push(c);
        }
      }

      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }

      records = records.concat(breakCompletions);
    }

    records = records.concat(lastNormalCompletions);
    return records;
  }

  function normalCompletionToBreak(completions) {
    completions.forEach(c => {
      c.type = BREAK_COMPLETION;
    });
  }

  function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach(c => {
      if (c.path.isBreakStatement({
        label: null
      })) {
        if (reachable) {
          c.path.replaceWith(t$4.unaryExpression("void", t$4.numericLiteral(0)));
        } else {
          c.path.remove();
        }
      }
    });
  }

  function getStatementListCompletion(paths, context) {
    let completions = [];

    if (context.canHaveBreak) {
      let lastNormalCompletions = [];

      for (let i = 0; i < paths.length; i++) {
        const path = paths[i];
        const newContext = Object.assign({}, context, {
          inCaseClause: false
        });

        if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
          newContext.shouldPopulateBreak = false;
        }

        const statementCompletions = _getCompletionRecords(path, newContext);

        if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {
          if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({
            label: null
          }))) {
            normalCompletionToBreak(lastNormalCompletions);
            completions = completions.concat(lastNormalCompletions);

            if (lastNormalCompletions.some(c => c.path.isDeclaration())) {
              completions = completions.concat(statementCompletions);
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }

            replaceBreakStatementInBreakCompletion(statementCompletions, false);
          } else {
            completions = completions.concat(statementCompletions);

            if (!context.shouldPopulateBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
          }

          break;
        }

        if (i === paths.length - 1) {
          completions = completions.concat(statementCompletions);
        } else {
          completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));
          lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);
        }
      }
    } else if (paths.length) {
      completions = completions.concat(_getCompletionRecords(paths[paths.length - 1], context));
    }

    return completions;
  }

  function _getCompletionRecords(path, context) {
    let records = [];

    if (path.isIfStatement()) {
      records = addCompletionRecords(path.get("consequent"), records, context);
      records = addCompletionRecords(path.get("alternate"), records, context);
    } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
      records = addCompletionRecords(path.get("body"), records, context);
    } else if (path.isProgram() || path.isBlockStatement()) {
      records = records.concat(getStatementListCompletion(path.get("body"), context));
    } else if (path.isFunction()) {
      return _getCompletionRecords(path.get("body"), context);
    } else if (path.isTryStatement()) {
      records = addCompletionRecords(path.get("block"), records, context);
      records = addCompletionRecords(path.get("handler"), records, context);
    } else if (path.isCatchClause()) {
      records = addCompletionRecords(path.get("body"), records, context);
    } else if (path.isSwitchStatement()) {
      records = completionRecordForSwitch(path.get("cases"), records, context);
    } else if (path.isSwitchCase()) {
      records = records.concat(getStatementListCompletion(path.get("consequent"), {
        canHaveBreak: true,
        shouldPopulateBreak: false,
        inCaseClause: true
      }));
    } else if (path.isBreakStatement()) {
      records.push(BreakCompletion(path));
    } else {
      records.push(NormalCompletion(path));
    }

    return records;
  }

  function getCompletionRecords() {
    const records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false
    });

    return records.map(r => r.path);
  }

  function getSibling(key) {
    return _index$1.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: key
    }).setContext(this.context);
  }

  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }

  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }

  function getAllNextSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(++_key);
    const siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }

    return siblings;
  }

  function getAllPrevSiblings() {
    let _key = this.key;
    let sibling = this.getSibling(--_key);
    const siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }

    return siblings;
  }

  function get(key, context = true) {
    if (context === true) context = this.context;
    const parts = key.split(".");

    if (parts.length === 1) {
      return this._getKey(key, context);
    } else {
      return this._getPattern(parts, context);
    }
  }

  function _getKey(key, context) {
    const node = this.node;
    const container = node[key];

    if (Array.isArray(container)) {
      return container.map((_, i) => {
        return _index$1.default.get({
          listKey: key,
          parentPath: this,
          parent: node,
          container: container,
          key: i
        }).setContext(context);
      });
    } else {
      return _index$1.default.get({
        parentPath: this,
        parent: node,
        container: node,
        key: key
      }).setContext(context);
    }
  }

  function _getPattern(parts, context) {
    let path = this;

    for (const part of parts) {
      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }

    return path;
  }

  function getBindingIdentifiers(duplicates) {
    return t$4.getBindingIdentifiers(this.node, duplicates);
  }

  function getOuterBindingIdentifiers(duplicates) {
    return t$4.getOuterBindingIdentifiers(this.node, duplicates);
  }

  function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
    const path = this;
    let search = [].concat(path);
    const ids = Object.create(null);

    while (search.length) {
      const id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      const keys = t$4.getBindingIdentifiers.keys[id.node.type];

      if (id.isIdentifier()) {
        if (duplicates) {
          const _ids = ids[id.node.name] = ids[id.node.name] || [];

          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }

        continue;
      }

      if (id.isExportDeclaration()) {
        const declaration = id.get("declaration");

        if (declaration.isDeclaration()) {
          search.push(declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }

        if (id.isFunctionExpression()) {
          continue;
        }
      }

      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const child = id.get(key);

          if (Array.isArray(child) || child.node) {
            search = search.concat(child);
          }
        }
      }
    }

    return ids;
  }

  function getOuterBindingIdentifierPaths(duplicates) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }

  var comments = {};

  Object.defineProperty(comments, "__esModule", {
    value: true
  });
  comments.shareCommentsWithSiblings = shareCommentsWithSiblings;
  comments.addComment = addComment;
  comments.addComments = addComments;

  var t$3 = lib$9;

  function shareCommentsWithSiblings() {
    if (typeof this.key === "string") return;
    const node = this.node;
    if (!node) return;
    const trailing = node.trailingComments;
    const leading = node.leadingComments;
    if (!trailing && !leading) return;
    const prev = this.getSibling(this.key - 1);
    const next = this.getSibling(this.key + 1);
    const hasPrev = Boolean(prev.node);
    const hasNext = Boolean(next.node);

    if (hasPrev && !hasNext) {
      prev.addComments("trailing", trailing);
    } else if (hasNext && !hasPrev) {
      next.addComments("leading", leading);
    }
  }

  function addComment(type, content, line) {
    t$3.addComment(this.node, type, content, line);
  }

  function addComments(type, comments) {
    t$3.addComments(this.node, type, comments);
  }

  Object.defineProperty(path$1, "__esModule", {
    value: true
  });
  path$1.default = path$1.SHOULD_SKIP = path$1.SHOULD_STOP = path$1.REMOVED = void 0;

  var virtualTypes$1 = virtualTypes$2;

  var _debug = src.exports;

  var _index = lib$a;

  var _scope = scope$1;

  var t$2 = lib$9;

  var _cache = cache;

  var _generator = lib$6;

  var NodePath_ancestry = ancestry;

  var NodePath_inference = inference;

  var NodePath_replacement = replacement;

  var NodePath_evaluation = evaluation;

  var NodePath_conversion = conversion;

  var NodePath_introspection = introspection;

  var NodePath_context = context;

  var NodePath_removal = removal;

  var NodePath_modification = modification;

  var NodePath_family = family;

  var NodePath_comments = comments;

  const debug = _debug("babel");

  const REMOVED = 1 << 0;
  path$1.REMOVED = REMOVED;
  const SHOULD_STOP = 1 << 1;
  path$1.SHOULD_STOP = SHOULD_STOP;
  const SHOULD_SKIP = 1 << 2;
  path$1.SHOULD_SKIP = SHOULD_SKIP;

  class NodePath {
    constructor(hub, parent) {
      this.contexts = [];
      this.state = null;
      this.opts = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this.parent = parent;
      this.hub = hub;
      this.data = null;
      this.context = null;
      this.scope = null;
    }

    static get({
      hub,
      parentPath,
      parent,
      container,
      listKey,
      key
    }) {
      if (!hub && parentPath) {
        hub = parentPath.hub;
      }

      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }

      const targetNode = container[key];

      let paths = _cache.path.get(parent);

      if (!paths) {
        paths = new Map();

        _cache.path.set(parent, paths);
      }

      let path = paths.get(targetNode);

      if (!path) {
        path = new NodePath(hub, parent);
        if (targetNode) paths.set(targetNode, path);
      }

      path.setup(parentPath, container, listKey, key);
      return path;
    }

    getScope(scope) {
      return this.isScope() ? new _scope.default(this) : scope;
    }

    setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      return this.data[key] = val;
    }

    getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      let val = this.data[key];
      if (val === undefined && def !== undefined) val = this.data[key] = def;
      return val;
    }

    buildCodeFrameError(msg, Error = SyntaxError) {
      return this.hub.buildError(this.node, msg, Error);
    }

    traverse(visitor, state) {
      (0, _index.default)(this.node, visitor, this.scope, state, this);
    }

    set(key, node) {
      t$2.validate(this.node, key, node);
      this.node[key] = node;
    }

    getPathLocation() {
      const parts = [];
      let path = this;

      do {
        let key = path.key;
        if (path.inList) key = `${path.listKey}[${key}]`;
        parts.unshift(key);
      } while (path = path.parentPath);

      return parts.join(".");
    }

    debug(message) {
      if (!debug.enabled) return;
      debug(`${this.getPathLocation()} ${this.type}: ${message}`);
    }

    toString() {
      return (0, _generator.default)(this.node).code;
    }

    get inList() {
      return !!this.listKey;
    }

    set inList(inList) {
      if (!inList) {
        this.listKey = null;
      }
    }

    get parentKey() {
      return this.listKey || this.key;
    }

    get shouldSkip() {
      return !!(this._traverseFlags & SHOULD_SKIP);
    }

    set shouldSkip(v) {
      if (v) {
        this._traverseFlags |= SHOULD_SKIP;
      } else {
        this._traverseFlags &= ~SHOULD_SKIP;
      }
    }

    get shouldStop() {
      return !!(this._traverseFlags & SHOULD_STOP);
    }

    set shouldStop(v) {
      if (v) {
        this._traverseFlags |= SHOULD_STOP;
      } else {
        this._traverseFlags &= ~SHOULD_STOP;
      }
    }

    get removed() {
      return !!(this._traverseFlags & REMOVED);
    }

    set removed(v) {
      if (v) {
        this._traverseFlags |= REMOVED;
      } else {
        this._traverseFlags &= ~REMOVED;
      }
    }

  }

  Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

  for (const type of t$2.TYPES) {
    const typeKey = `is${type}`;
    const fn = t$2[typeKey];

    NodePath.prototype[typeKey] = function (opts) {
      return fn(this.node, opts);
    };

    NodePath.prototype[`assert${type}`] = function (opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError(`Expected node path of type ${type}`);
      }
    };
  }

  for (const type of Object.keys(virtualTypes$1)) {
    if (type[0] === "_") continue;
    if (t$2.TYPES.indexOf(type) < 0) t$2.TYPES.push(type);
    const virtualType = virtualTypes$1[type];

    NodePath.prototype[`is${type}`] = function (opts) {
      return virtualType.checkPath(this, opts);
    };
  }

  var _default = NodePath;
  path$1.default = _default;

  Object.defineProperty(context$1, "__esModule", {
    value: true
  });
  context$1.default = void 0;

  var _path = path$1;

  var t$1 = lib$9;

  class TraversalContext {
    constructor(scope, opts, state, parentPath) {
      this.queue = null;
      this.priorityQueue = null;
      this.parentPath = parentPath;
      this.scope = scope;
      this.state = state;
      this.opts = opts;
    }

    shouldVisit(node) {
      const opts = this.opts;
      if (opts.enter || opts.exit) return true;
      if (opts[node.type]) return true;
      const keys = t$1.VISITOR_KEYS[node.type];
      if (!(keys != null && keys.length)) return false;

      for (const key of keys) {
        if (node[key]) return true;
      }

      return false;
    }

    create(node, obj, key, listKey) {
      return _path.default.get({
        parentPath: this.parentPath,
        parent: node,
        container: obj,
        key: key,
        listKey
      });
    }

    maybeQueue(path, notPriority) {
      if (this.queue) {
        if (notPriority) {
          this.queue.push(path);
        } else {
          this.priorityQueue.push(path);
        }
      }
    }

    visitMultiple(container, parent, listKey) {
      if (container.length === 0) return false;
      const queue = [];

      for (let key = 0; key < container.length; key++) {
        const node = container[key];

        if (node && this.shouldVisit(node)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }

      return this.visitQueue(queue);
    }

    visitSingle(node, key) {
      if (this.shouldVisit(node[key])) {
        return this.visitQueue([this.create(node, node, key)]);
      } else {
        return false;
      }
    }

    visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      const visited = new WeakSet();
      let stop = false;

      for (const path of queue) {
        path.resync();

        if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
          path.pushContext(this);
        }

        if (path.key === null) continue;
        const {
          node
        } = path;
        if (visited.has(node)) continue;
        if (node) visited.add(node);

        if (path.visit()) {
          stop = true;
          break;
        }

        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop) break;
        }
      }

      for (const path of queue) {
        path.popContext();
      }

      this.queue = null;
      return stop;
    }

    visit(node, key) {
      const nodes = node[key];
      if (!nodes) return false;

      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node, key);
      } else {
        return this.visitSingle(node, key);
      }
    }

  }

  context$1.default = TraversalContext;

  var visitors = {};

  Object.defineProperty(visitors, "__esModule", {
    value: true
  });
  visitors.explode = explode;
  visitors.verify = verify;
  visitors.merge = merge;

  var virtualTypes = virtualTypes$2;

  var t = lib$9;

  function explode(visitor) {
    if (visitor._exploded) return visitor;
    visitor._exploded = true;

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const parts = nodeType.split("|");
      if (parts.length === 1) continue;
      const fns = visitor[nodeType];
      delete visitor[nodeType];

      for (const part of parts) {
        visitor[part] = fns;
      }
    }

    verify(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const wrapper = virtualTypes[nodeType];
      if (!wrapper) continue;
      const fns = visitor[nodeType];

      for (const type of Object.keys(fns)) {
        fns[type] = wrapCheck(wrapper, fns[type]);
      }

      delete visitor[nodeType];

      if (wrapper.types) {
        for (const type of wrapper.types) {
          if (visitor[type]) {
            mergePair(visitor[type], fns);
          } else {
            visitor[type] = fns;
          }
        }
      } else {
        mergePair(visitor, fns);
      }
    }

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      const fns = visitor[nodeType];
      let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];
      const deprecatedKey = t.DEPRECATED_KEYS[nodeType];

      if (deprecatedKey) {
        console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);
        aliases = [deprecatedKey];
      }

      if (!aliases) continue;
      delete visitor[nodeType];

      for (const alias of aliases) {
        const existing = visitor[alias];

        if (existing) {
          mergePair(existing, fns);
        } else {
          visitor[alias] = Object.assign({}, fns);
        }
      }
    }

    for (const nodeType of Object.keys(visitor)) {
      if (shouldIgnoreKey(nodeType)) continue;
      ensureCallbackArrays(visitor[nodeType]);
    }

    return visitor;
  }

  function verify(visitor) {
    if (visitor._verified) return;

    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
    }

    for (const nodeType of Object.keys(visitor)) {
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }

      if (shouldIgnoreKey(nodeType)) continue;

      if (t.TYPES.indexOf(nodeType) < 0) {
        throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);
      }

      const visitors = visitor[nodeType];

      if (typeof visitors === "object") {
        for (const visitorKey of Object.keys(visitors)) {
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + `${nodeType} that has the invalid property ${visitorKey}`);
          }
        }
      }
    }

    visitor._verified = true;
  }

  function validateVisitorMethods(path, val) {
    const fns = [].concat(val);

    for (const fn of fns) {
      if (typeof fn !== "function") {
        throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);
      }
    }
  }

  function merge(visitors, states = [], wrapper) {
    const rootVisitor = {};

    for (let i = 0; i < visitors.length; i++) {
      const visitor = visitors[i];
      const state = states[i];
      explode(visitor);

      for (const type of Object.keys(visitor)) {
        let visitorType = visitor[type];

        if (state || wrapper) {
          visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
        }

        const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
        mergePair(nodeVisitor, visitorType);
      }
    }

    return rootVisitor;
  }

  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    const newVisitor = {};

    for (const key of Object.keys(oldVisitor)) {
      let fns = oldVisitor[key];
      if (!Array.isArray(fns)) continue;
      fns = fns.map(function (fn) {
        let newFn = fn;

        if (state) {
          newFn = function (path) {
            return fn.call(state, path, state);
          };
        }

        if (wrapper) {
          newFn = wrapper(state.key, key, newFn);
        }

        if (newFn !== fn) {
          newFn.toString = () => fn.toString();
        }

        return newFn;
      });
      newVisitor[key] = fns;
    }

    return newVisitor;
  }

  function ensureEntranceObjects(obj) {
    for (const key of Object.keys(obj)) {
      if (shouldIgnoreKey(key)) continue;
      const fns = obj[key];

      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }

  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }

  function wrapCheck(wrapper, fn) {
    const newFn = function (path) {
      if (wrapper.checkPath(path)) {
        return fn.apply(this, arguments);
      }
    };

    newFn.toString = () => fn.toString();

    return newFn;
  }

  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

    if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
      return true;
    }

    return false;
  }

  function mergePair(dest, src) {
    for (const key of Object.keys(src)) {
      dest[key] = [].concat(dest[key] || [], src[key]);
    }
  }

  var hub = {};

  Object.defineProperty(hub, "__esModule", {
    value: true
  });
  hub.default = void 0;

  class Hub {
    getCode() {}

    getScope() {}

    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }

    buildError(node, msg, Error = TypeError) {
      return new Error(msg);
    }

  }

  hub.default = Hub;

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "NodePath", {
    enumerable: true,
    get: function () {
      return _path.default;
    }
  });
  Object.defineProperty(exports, "Scope", {
    enumerable: true,
    get: function () {
      return _scope.default;
    }
  });
  Object.defineProperty(exports, "Hub", {
    enumerable: true,
    get: function () {
      return _hub.default;
    }
  });
  exports.visitors = exports.default = void 0;

  var _context = context$1;

  var visitors$1 = visitors;

  exports.visitors = visitors$1;

  var t = lib$9;

  var cache$1 = cache;

  var _path = path$1;

  var _scope = scope$1;

  var _hub = hub;

  function traverse(parent, opts = {}, scope, state, parentPath) {
    if (!parent) return;

    if (!opts.noScope && !scope) {
      if (parent.type !== "Program" && parent.type !== "File") {
        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${parent.type} node without ` + "passing scope and parentPath.");
      }
    }

    if (!t.VISITOR_KEYS[parent.type]) {
      return;
    }

    visitors$1.explode(opts);
    traverse.node(parent, opts, scope, state, parentPath);
  }

  var _default = traverse;
  exports.default = _default;
  traverse.visitors = visitors$1;
  traverse.verify = visitors$1.verify;
  traverse.explode = visitors$1.explode;

  traverse.cheap = function (node, enter) {
    return t.traverseFast(node, enter);
  };

  traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
    const keys = t.VISITOR_KEYS[node.type];
    if (!keys) return;
    const context = new _context.default(scope, opts, state, parentPath);

    for (const key of keys) {
      if (skipKeys && skipKeys[key]) continue;
      if (context.visit(node, key)) return;
    }
  };

  traverse.clearNode = function (node, opts) {
    t.removeProperties(node, opts);
    cache$1.path.delete(node);
  };

  traverse.removeProperties = function (tree, opts) {
    t.traverseFast(tree, traverse.clearNode, opts);
    return tree;
  };

  function hasDenylistedType(path, state) {
    if (path.node.type === state.type) {
      state.has = true;
      path.stop();
    }
  }

  traverse.hasType = function (tree, type, denylistTypes) {
    if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
    if (tree.type === type) return true;
    const state = {
      has: false,
      type: type
    };
    traverse(tree, {
      noScope: true,
      denylist: denylistTypes,
      enter: hasDenylistedType
    }, null, state);
    return state.has;
  };

  traverse.cache = cache$1;
  }(lib$a));

  var traverse = /*@__PURE__*/getDefaultExportFromCjs(lib$a);

  var VueHelpers = /*#__PURE__*/function () {
    function VueHelpers() {
      _classCallCheck(this, VueHelpers);
    }

    _createClass(VueHelpers, [{
      key: "_generate",
      value: function _generate(nodes) {
        var _this = this;

        nodes.map(function (node) {
          if (node.type === 1) {
            _this._generate(node.children);
          }

          if (node.type === 2) ;

          if (node.type === 5) ;
        });
      }
    }, {
      key: "generate",
      value: function generate(vueAST) {
        var content = '';

        if (vueAST.template) {
          this._generate(vueAST.template.children);
        }

        return {
          code: content,
          stack: []
        };
      }
    }, {
      key: "traverse",
      value: function traverse(ast) {
        if (ast) {
          transform$1(ast, {
            nodeTransforms: [function (node, context) {}]
          });
        }

        return ast;
      }
    }, {
      key: "_transform",
      value: function _transform(transform) {
        var _transform$parser = transform.parser,
            ast = _transform$parser.ast,
            vueTemplateNode = _transform$parser.vueTemplateNode,
            _transform = transform._transform; // transform script

        var asted = _transform.call(transform, ast); // transform template


        var template = this.traverse(vueTemplateNode);
        return {
          ast: asted,
          template: template
        };
      }
    }]);

    return VueHelpers;
  }();

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var defaultRenderOptions = {
    retainLines: true,
    jsescOption: {
      quotes: 'single'
    }
  };

  var Transform = /*#__PURE__*/function () {
    function Transform(parser, options) {
      var _this$options;

      _classCallCheck(this, Transform);

      _defineProperty(this, "identifier", '$t');

      this.parser = parser;
      this.options = options;
      this.fnName = ((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.identifier) || this.identifier;
      this.stack = [];
      this.vueHelpers = new VueHelpers();
    }

    _createClass(Transform, [{
      key: "_key",
      value: function _key(node) {
        var _this$options2, _node$loc, _node$loc2;

        return (_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.ruleKey ? this.options.ruleKey(node) : "".concat(node.type, "_").concat((_node$loc = node.loc) === null || _node$loc === void 0 ? void 0 : _node$loc.start.column, "_").concat((_node$loc2 = node.loc) === null || _node$loc2 === void 0 ? void 0 : _node$loc2.end.column);
      }
    }, {
      key: "_StringFunction",
      value: function _StringFunction(node) {
        var key = String(this._key(node));
        this.stack.push(_defineProperty({}, key, node.value));
        return lib$9.expressionStatement(lib$9.callExpression(lib$9.identifier(this.fnName), [lib$9.stringLiteral(key)]));
      }
    }, {
      key: "_TemplateFunction",
      value: function _TemplateFunction(node) {
        var key = String(this._key(node));
        var args = [];
        var index = 0;
        var value = node.quasis.map(function (quasis) {
          if (quasis.value.raw) {
            return quasis.value.raw;
          } else {
            return "{".concat(index++, "}");
          }
        });
        this.stack.push(_defineProperty({}, key, value.join('')));
        node.expressions.map(function (expression) {
          if (!lib$9.isTSType(expression)) {
            args.push(expression);
          }
        });
        return lib$9.expressionStatement(lib$9.callExpression(lib$9.identifier(this.fnName), [lib$9.stringLiteral(key)].concat(args)));
      }
    }, {
      key: "_JSXTextFunction",
      value: function _JSXTextFunction(node) {
        var key = String(this._key(node));
        this.stack.push(_defineProperty({}, key, node.value));
        return lib$9.jSXExpressionContainer(lib$9.callExpression(lib$9.identifier(this.fnName), [lib$9.stringLiteral(key)]));
      }
    }, {
      key: "_JSXAttributeFunction",
      value: function _JSXAttributeFunction(node) {
        var key = String(this._key(node));
        this.stack.push(_defineProperty({}, key, node.value.value));
        var value = lib$9.jSXExpressionContainer(lib$9.callExpression(lib$9.identifier(this.fnName), [lib$9.stringLiteral(key)]));
        return lib$9.jSXAttribute(node.name, value);
      }
    }, {
      key: "_transform",
      value: function _transform(script) {
        var ast = lodash.exports.cloneDeep(script || this.parser.ast);
        var self = this;
        traverse(ast, {
          StringLiteral: function StringLiteral(path) {
            if (isContainChinese(path.node.value)) {
              path.replaceWith(self._StringFunction(path.node));
            }
          },
          TemplateLiteral: function TemplateLiteral(path) {
            if (path.node.quasis.find(function (quasi) {
              return isContainChinese(quasi.value.raw);
            })) {
              path.replaceWith(self._TemplateFunction(path.node));
            }
          },
          JSXText: function JSXText(path) {
            if (isContainChinese(path.node.value)) {
              path.replaceWith(self._JSXTextFunction(path.node));
            }
          },
          JSXAttribute: function JSXAttribute(path) {
            var value = path.node.value;

            if (lib$9.isStringLiteral(value) && isContainChinese(value.value)) {
              path.replaceWith(self._JSXAttributeFunction(path.node));
            }
          }
        });
        return ast;
      }
    }, {
      key: "transform",
      value: function transform() {
        var type = this.parser.type;

        if (type === 'vue') {
          return this.vueHelpers._transform(this);
        }

        return this._transform();
      }
    }, {
      key: "render",
      value: function render() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultRenderOptions;
        var type = this.parser.type;
        var ast = this.transform();

        if (type === 'vue') {
          return this.vueHelpers.generate(ast);
        }

        return _objectSpread(_objectSpread({}, _default$6(ast, options, this.parser.content)), {}, {
          stack: this.stack
        });
      }
    }]);

    return Transform;
  }();

  var transform = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': Transform
  });

  function transformCode(code, config) {
    var parser = new Parser({
      content: code,
      type: config.type
    });
    var transform = new Transform(parser, config);
    return transform.render();
  }

  exports.Parser = parser;
  exports.Transform = transform;
  exports.transformCode = transformCode;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
